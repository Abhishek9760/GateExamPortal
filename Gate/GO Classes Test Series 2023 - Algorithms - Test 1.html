<div><span>Q1</span> - <p>Consider the following recurrence equation T(n)=A n^2+B n+C.<br>
We determine the constants A, B, C using the following recursive equation.<br>
Assume n is a power of 2.<br>

    <br>
    T(n)= 4 T(n / 2)+n+6,    amp; n ≥ 2 
    <br>
    2,    amp; n=1<br>
<br>
What will be the value of A+B+C ?</p>

<ol style="list-style-type:upper-alpha">
	<li>1</li>
	<li>2</li>
	<li>3</li>
	<li>4</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>Suppose you are given k sorted arrays, each with n elements, and you want to combine them into a single array of kn elements. Consider the following approach. Divide the k arrays into k   nbsp;/ 2 pairs of arrays, and use the Merge subroutine of MergeSort to combine each pair. Now you are left with k / 2 sorted arrays, each with 2 n elements.</p>

<p>Repeat this approach until you have a single sorted array with kn elements. What is the running time of this procedure, as a function of k and n?   nbsp;</p>

<ol style="list-style-type:upper-alpha">
	<li>Θ(n k log k)</li>
	<li>Θ(n k^ 2)</li>
	<li>Θ(n k log n)</li>
	<li>Θ(n log k)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <p>If we have an array of size N with only 3 different values for its elements, what is the probability that the first partition results in a completely sorted array? Assume there are an equal number of each element in the array.</p>

<ol style="list-style-type:upper-alpha">
	<li>1 / 2</li>
	<li>1 / 3</li>
	<li>1 / 4</li>
	<li>2 / 3</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - <p>Consider two statements about RANDOMIZED QUICKSORT.</p>

<ul>
	<li>S1: There is some input for which randomized quicksort always runs in time Θ(n^ 2) time.</li>
	<li>S2: An adversary can provide randomized quicksort with an input array of length n that forces the algorithm to run in Θ(n  n) time on that input.</li>
</ul>

<p>Choose the correct option (assume distinct elements in input):</p>

<ol style="list-style-type:upper-alpha">
	<li>Both statements are correct</li>
	<li>S1 is correct, but S 2 is false</li>
	<li>S 1 is false, but S 2 is correct</li>
	<li>Both Statements are incorrect</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - <p>Consider the following pseudo-code of function fun(). fun() takes k arrays as input and return merged array of all. Assume that merge function takes O(p+q) where p is length of first input array to merge and q is length of second input array to merge.<br>
In the pseudo code, size of B and C are kn/2.<br>
Let T(k) is time complexity for fun() if there are k input arrays of size n</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
fun (X1[1...n], X2[1...n],....,Xk[1...n])
    
    if k   gt;1 then
        m = k/2
        𝐵[1...mn] = fun(𝑋1,𝑋2,…,𝑋𝑚)
        𝐶[1⋯(𝑘−𝑚)𝑛] = fun(𝑋𝑚+1,𝑋𝑚+2,…,𝑋𝑘)
        RETURN merge(𝐵,𝐶)

</pre>

<p><br>
<br>
What will be value of T(k) ?</p>

<ol style="list-style-type:upper-alpha">
	<li>T(k)=O(n k log (n k))</li>
	<li>T(k)=O(n k log k)</li>
	<li>T(k)=O(n k log n)</li>
	<li>T(k)=O(n   nbsp;log nk )</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - <p>Consider partition algorithm of randomized quick sort which randomly choose pivot element and split the array into two halves accordingly. Pivot element will not be in any of the subarrays.</p>

<p>Suppose array length is n which is odd then what is the probability that median element lies in second half after partition?</p>

<ol style="list-style-type:upper-alpha">
	<li>1 / 2</li>
	<li>1 / 2-1 / 2n</li>
	<li>1 / 2-2 / n</li>
	<li>1-1 / 2 n</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - <p>Given an unsorted array of n distinct elements, you want to find this set of log n elements: those at positions 1,2,4,8,16, …, n/2 if array were sorted. In other words, find the largest element, the second largest element, the fourth largest element, the eighth largest element and so on, terminating with the median element.<br>
Consider that we have an algorithm to find kth smallest in an array of size n using θ(n) time. Assume n is a power of 2. How fast can you find all these log n elements? (Hint: Similar to binary search, we never have to worry about one of the subarray)</p>

<ol style="list-style-type:upper-alpha">
	<li>Θ(log n)</li>
	<li>Θ(n)</li>
	<li>Θ(n log n)</li>
	<li>Θ(n^2)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - <p>Assume that the inputs of size n of a certain algorithm are of the following types:</p>

<ul>
	<li>Type 1: for each input of this type, the algorithm takes time Θ(n^4). Moreover, the probability that the input is of this type is 1/n^3.</li>
	<li>Type 2: for each input of this type, the algorithm takes time Θ(n^3). Moreover, the probability that the input is of this type is 1/n.</li>
	<li>Type 3 : for each input of this type, the algorithm takes time Θ(n). Moreover, the probability that the input is of this type is 1-1/n^3-1/n.</li>
</ul>

<p>Then the cost of the algorithm in the average case is</p>

<ol style="list-style-type:upper-alpha">
	<li>Θ(n^3)</li>
	<li>Θ(n^4)</li>
	<li>Θ(n)</li>
	<li>Θ(n^2)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - <p>Let A[1 … n] be an array of n distinct numbers. If i   lt;j and A[i]   gt;A[j], then the pair (i, j) is called an inversion of A.</p>

<p>Suppose that each element of A is chosen randomly, independently, and uniformly from the range 1 through n.</p>

<p>What will be the expected number of inversions?</p>

<ol style="list-style-type:upper-alpha">
	<li>n(n-1) / 4</li>
	<li>n</li>
	<li>n(n-1) / 2</li>
	<li>n^ 2 / 2</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>Suppose that a randomized algorithm succeeds with probability p    nbsp;(with 0   lt;p   lt;1).<strong>   nbsp;   nbsp;</strong>Let n be independent trials we need to run the algorithm to ensure that, with probability at least 1-ϵ, at least one trial succeeds.<br>
Which of the following relation must hold true?</p>

<ol style="list-style-type:upper-alpha">
	<li>(1-p)^n≤ϵ</li>
	<li>1-p^n≤ϵ</li>
	<li>p^n≤ϵ</li>
	<li>p^n≤ϵ</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - <p>An inversion in a vector of integers T[0 … n-1] is a pair of positions storing values that are not ordered, that is, a pair (i, j) such that 0 ≤   nbsp;i   lt;j   lt;n and T[i]   gt;T[j].</p>

<p>Let T[0 … 99] be an array of hundred integers. It is also given that T[0]   gt;T [10]. Relation between other elements is not given.<br>
Which of the following is/are true about a number of inversions.</p>

<ol style="list-style-type:upper-alpha">
	<li>There are at most   nbsp;11 inversions in the array.</li>
	<li>There are at least   nbsp;10 inversions in the array.</li>
	<li>There are at most   nbsp;10 inversions in the array.</li>
	<li>There are at least   nbsp;11 inversions in the array.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>Consider a quicksort where splits at every level are in the proportion of α, which means one of the partitions is   nbsp;α n and the other partition is (1-α) n. The recursive equation of time complexity can be written as</p>

<p>
    T(n)=T(α   nbsp;n)+T(1-α) n)+n.
 Consider a recursion tree of function calls and let x be the height of the tree when we hit the base case the first time and let y be the maximum height of the tree then, which of the following is/are true?<br>
Base case is an array containing single element.</p>

<ol style="list-style-type:upper-alpha">
	<li>α^ x n=1 and (1-α)^ y n=1 if α   lt;0.5</li>
	<li>α^ y n=1 and (1-α)^ x n=1 if α   lt;0.5</li>
	<li>α^ x n=1 and (1-α)^ y n=1 if α   gt;0.5</li>
	<li>α^ y n=1 and (1-α)^ x n=1 if α   gt;0.5</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Insertion sort performs best case when input is sorted and worst case when input is sorted backwards.<br>
Compute the average cost of insertion sort to sort a vector with n different integers when with probability log n/n one chooses a vector which is sorted backwards and with probability 1-log n/n one chooses a sorted vector.</p>

<ol style="list-style-type:upper-alpha">
	<li>Θ(n^3)</li>
	<li>Θ(n log n)</li>
	<li>Θ(n)</li>
	<li>Θ(n^2)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q14</span> - <p>Let T(n)=4 T(n / 3)+n^log _3 4. What will be asymptotic bound on T(n)?</p>

<ol style="list-style-type:upper-alpha">
	<li>T(n)=Θ(n^log _3 4log n)</li>
	<li>T(n)=Θ(n log n)</li>
	<li>T(n)=Θ(4^log _3 nloglog n)</li>
	<li>None of these</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q15</span> - <p>You are given a bit-array A[1 … n] (i.e., A[i] ∈{0,1} for each i ) and told that this is a "0 -to-1” bit-array. This means that for some (unknown) index 1 ≤ j   lt;n, A[1], …, A[j] are all 0 's and A[j+1], …, A[n] are all 1 's. The index j for such an array is called the transition index. We design a divide and conquer algorithm for finding the transition index for a given 0 -to- 1 bit-array. The input to the algorithm is an array A and the size n of the array A. What will be the worst case time complexity of best divide and conquer algorithm?   nbsp;</p>

<ol style="list-style-type:upper-alpha">
	<li>Θ(log n)</li>
	<li>Θ(n log n)</li>
	<li>Θ(n)</li>
	<li>Θ(n^2)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q16</span> - <p>3-Way-Merge Sort: Suppose that instead of dividing in half at each step of Merge Sort, you divide into thirds, sort each third, and finally combine all of them using a three-way merge subroutine. What is the overall asymptotic running time of this algorithm? (Hint: Note that the merge step can still be implemented in O(n) time.)</p>

<ol style="list-style-type:upper-alpha">
	<li>n</li>
	<li>n log (n)</li>
	<li>n^2log (n)</li>
	<li>n(log (n))^2</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q17</span> - <p>Recall the Partition subroutine that we used in QuickSort. Suppose that the following array has just been partitioned around some pivot element : 3,1,2,4,5,8,7,6,9.</p>

<p>Which of these element(s) could have been the pivot element?</p>

<ol style="list-style-type:upper-alpha">
	<li>4</li>
	<li>5</li>
	<li>2</li>
	<li>9</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q18</span> - <p>How many calls of merge-sort are performed when sorting an array of size 64 ? Base case is an array containing a single element.</p>

<ol style="list-style-type:upper-alpha">
	<li>2^63</li>
	<li>127</li>
	<li>63</li>
	<li>64</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q19</span> - Consider a constant α = 0.3. If we use randomized quick sort (pivot chosen is uniform random) then what is the probability that the partition method will result in an array such that the size of the smaller subarray is ≥α n where n is the total size of the array?<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q20</span> - <p>Consider an array of n distinct integers. An array element is a peak if it is greater than its neighbors.<br>
For corner elements, we need to consider only one neighbor. The corner element is peak only when it's greater than its neighbors.<br>
If there are more than one peak item, simply return one of them.</p>

<p>Example:</p>

<ul>
	<li>Input : [1, 5, 3, 2, 4, 0] Output : 4</li>
	<li>Input : [1, 2, 3, 4, 5, 6] Output : 6</li>
	<li>Input : [7, 6, 5, 4, 3, 2] Output : 7</li>
</ul>

<p>We design a divide-and-conquer algorithm that solves this problem. The incomplete pseudo-code is given below.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
findPeak(A, i, j)
    if(i==j) //one element
        return i 
    if(i==j-1) //two elements
        if(A[i]   gt; A[j] ) return i
        else return j
    mid = (i+j)/2
    if (A[mid]   gt; A[mid-1] and A[mid]   gt; A[mid+1]) return mid
    if (A[mid-1]   gt; A[mid])
    //line X
    if (A[mid+1]   gt; A[mid])
    //line Y

</pre>

<p>Fill in the blanks for lines X and Y.</p>

<ol style="list-style-type:upper-alpha">
	<li>Line X is return findPeak (A, i, mid-1)</li>
	<li>Line Y is return findPeak( A, mid +1, j)</li>
	<li>Line X is return findPeak (A, mid +1, j)</li>
	<li>Line Y is return findPeak (A, i, mid-1)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let data={'name': 'GO Classes Test Series 2023 | Algorithms | Test 1', 'duration': '60', 'total_qs': '20', 'total_qs_one': 5, 'total_qs_two': 15, 'apti_num_qs': 0, 'technical_num_qs': 20, 'apti_marks': 0, 'technical_marks': 35, 'total_marks': 35, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 20, 'marks': 35, 'question': [{'contents': '', 'post_id': '376688', 'text': '<p>Consider the following recurrence equation $T(n)=A n^{2}+B n+C$.<br>\nWe determine the constants $A, B, C$ using the following recursive equation.<br>\nAssume $n$ is a power of $2.$<br>\n$$<br>\nT(n)= \\begin{cases}4 T(n / 2)+n+6, &amp; n \\geq 2 \\\\<br>\n2, &amp; n=1\\end{cases}<br>\n$$<br>\nWhat will be the value of $A+B+C ?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1$</li>\n\t<li>$2$</li>\n\t<li>$3$</li>\n\t<li>$4$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1-weekly-quiz,goclasses,algorithms,recurrence-relation,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376691', 'text': '<p>Suppose you are given $k$ sorted arrays, each with $n$ elements, and you want to combine them into a single array of kn elements. Consider the following approach. Divide the $k$ arrays into $k&nbsp;/ 2$ pairs of arrays, and use the Merge subroutine of MergeSort to combine each pair. Now you are left with $k / 2$ sorted arrays, each with $2 n$ elements.</p>\n\n<p>Repeat this approach until you have a single sorted array with kn elements. What is the running time of this procedure, as a function of $k$ and $n?$&nbsp;</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta(n k \\log k)$</li>\n\t<li>$\\Theta\\left(n k^ 2\\right)$</li>\n\t<li>$\\Theta(n k \\log n)$</li>\n\t<li>$\\Theta(n \\log k)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,merge-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376704', 'text': '<p>If we have an array of size $\\mathrm{N}$ with only $3$ different values for its elements, what is the probability that the first partition results in a completely sorted array? Assume there are an equal number of each element in the array.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1 / 2$</li>\n\t<li>$1 / 3$</li>\n\t<li>$1 / 4$</li>\n\t<li>$2 / 3$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1-weekly-quiz,goclasses,algorithms,sorting,array,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376686', 'text': '<p>Consider two statements about RANDOMIZED QUICKSORT.</p>\n\n<ul>\n\t<li>$S1:$ There is some input for which randomized quicksort always runs in time $\\Theta\\left(n^ 2\\right)$ time.</li>\n\t<li>$S2:$ An adversary can provide randomized quicksort with an input array of length $n$ that forces the algorithm to run in $\\Theta(n \\lg n)$ time on that input.</li>\n</ul>\n\n<p>Choose the correct option (assume distinct elements in input):</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Both statements are correct</li>\n\t<li>$S1$ is correct, but $S 2$ is false</li>\n\t<li>$S 1$ is false, but $S 2$ is correct</li>\n\t<li>Both Statements are incorrect</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'D', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376681', 'text': '<p>Consider the following pseudo-code of function fun(). fun() takes k arrays as input and return merged array of all. Assume that merge function takes $O(p+q)$ where $p$ is length of first input array to merge and $q$ is length of second input array to merge.<br>\nIn the pseudo code, size of B and C are $kn/2.$<br>\nLet $T(k)$ is time complexity for fun() if there are $k$ input arrays of size $n$</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nfun (X1[1...n], X2[1...n],....,Xk[1...n]){\n    \n    if k&gt;1 then\n        m = k/2\n        𝐵[1...mn] = fun(𝑋1,𝑋2,…,𝑋𝑚)\n        𝐶[1⋯(𝑘−𝑚)𝑛] = fun(𝑋𝑚+1,𝑋𝑚+2,…,𝑋𝑘)\n        RETURN merge(𝐵,𝐶)\n}\n</pre>\n\n<p><br>\n<br>\nWhat will be value of $T(k) ?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$T(k)=O(n k \\log (n k))$</li>\n\t<li>$T(k)=O(n k \\log k)$</li>\n\t<li>$T(k)=O(n k \\log n)$</li>\n\t<li>$T(k)=O(n&nbsp;\\log nk )$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'B', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1-weekly-quiz,goclasses,algorithms,merging,time-complexity,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376696', 'text': '<p>Consider partition algorithm of randomized quick sort which randomly choose pivot element and split the array into two halves accordingly. Pivot element will not be in any of the subarrays.</p>\n\n<p>Suppose array length is $n$ which is odd then what is the probability that median element lies in second half after partition?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1 / 2$</li>\n\t<li>$1 / 2-1 / 2n$</li>\n\t<li>$1 / 2-2 / n$</li>\n\t<li>$1-1 / 2 n$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'B', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376695', 'text': '<p>Given an unsorted array of $n$ distinct elements, you want to find this set of $\\log n$ elements: those at positions $1,2,4,8,16, \\ldots, n/2$ if array were sorted. In other words, find the largest element, the second largest element, the fourth largest element, the eighth largest element and so on, terminating with the median element.<br>\nConsider that we have an algorithm to find $k$th smallest in an array of size $n$ using $\\theta(n)$ time. Assume $n$ is a power of $2.$ How fast can you find all these $\\log n$ elements? (Hint: Similar to binary search, we never have to worry about one of the subarray)</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta(\\log n)$</li>\n\t<li>$\\Theta(n)$</li>\n\t<li>$\\Theta(n \\log n)$</li>\n\t<li>$\\Theta\\left(n^{2}\\right)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1-weekly-quiz,goclasses,algorithms,searching,binary-search,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376683', 'text': '<p>Assume that the inputs of size $n$ of a certain algorithm are of the following types:</p>\n\n<ul>\n\t<li>Type $1:$ for each input of this type, the algorithm takes time $\\Theta\\left(n^{4}\\right)$. Moreover, the probability that the input is of this type is $\\frac{1}{n^{3}}$.</li>\n\t<li>Type $2:$ for each input of this type, the algorithm takes time $\\Theta\\left(n^{3}\\right)$. Moreover, the probability that the input is of this type is $\\frac{1}{n}$.</li>\n\t<li>Type $3 :$ for each input of this type, the algorithm takes time $\\Theta(n)$. Moreover, the probability that the input is of this type is $1-\\frac{1}{n^{3}}-\\frac{1}{n}$.</li>\n</ul>\n\n<p>Then the cost of the algorithm in the average case is</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta\\left(n^{3}\\right)$</li>\n\t<li>$\\Theta\\left(n^{4}\\right)$</li>\n\t<li>$\\Theta(n)$</li>\n\t<li>$\\Theta\\left(n^{2}\\right)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,asymptotic-notation,time-complexity,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376680', 'text': '<p>Let $A[1 \\ldots n]$ be an array of $n$ distinct numbers. If $i&lt;j$ and $A[i]&gt;A[j]$, then the pair $(i, j)$ is called an inversion of $A$.</p>\n\n<p>Suppose that each element of $A$ is chosen randomly, independently, and uniformly from the range $1$ through $n$.</p>\n\n<p>What will be the expected number of inversions?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$n(n-1) / 4$</li>\n\t<li>$n$</li>\n\t<li>$n(n-1) / 2$</li>\n\t<li>$n^ 2 / 2$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,array,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376677', 'text': '<p>Suppose that a randomized algorithm succeeds with probability $p$ &nbsp;(with $0&lt;p&lt;1).$<strong>&nbsp;&nbsp;</strong>Let $n$ be independent trials we need to run the algorithm to ensure that, with probability at least $1-\\epsilon$, at least one trial succeeds.<br>\nWhich of the following relation must hold true?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$(1-p)^{n} \\leq \\epsilon$</li>\n\t<li>$1-p^{n} \\leq \\epsilon$</li>\n\t<li>$p^{n} \\leq \\epsilon$</li>\n\t<li>$p^{n} \\leq \\epsilon$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1-weekly-quiz,goclasses,algorithms,time-complexity,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376685', 'text': '<p>An inversion in a vector of integers $T[0 \\ldots n-1]$ is a pair of positions storing values that are not ordered, that is, a pair $(i, j)$ such that $0 \\leq&nbsp;i&lt;j&lt;n$ and $T[i]&gt;T[j]$.</p>\n\n<p>Let $T[0 \\ldots 99]$ be an array of hundred integers. It is also given that $T[0]&gt;T [10]$. Relation between other elements is not given.<br>\nWhich of the following is/are true about a number of inversions.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>There are at most&nbsp;$11$ inversions in the array.</li>\n\t<li>There are at least&nbsp;$10$ inversions in the array.</li>\n\t<li>There are at most&nbsp;$10$ inversions in the array.</li>\n\t<li>There are at least&nbsp;$11$ inversions in the array.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,array,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376697', 'text': '<p>Consider a quicksort where splits at every level are in the proportion of $\\alpha$, which means one of the partitions is&nbsp;$\\alpha n$ and the other partition is $(1-\\alpha) n$. The recursive equation of time complexity can be written as</p>\n\n<p>$$T(n)=T(\\alpha&nbsp;n)+T(1-\\alpha) n)+n.$$ Consider a recursion tree of function calls and let $x$ be the height of the tree when we hit the base case the first time and let $y$ be the maximum height of the tree then, which of the following is/are true?<br>\nBase case is an array containing single element.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\alpha^ x n=1$ and $(1-\\alpha)^ y n=1$ if $\\alpha&lt;0.5$</li>\n\t<li>$\\alpha^ y n=1$ and $(1-\\alpha)^ x n=1$ if $\\alpha&lt;0.5$</li>\n\t<li>$\\alpha^ x n=1$ and $(1-\\alpha)^ y n=1$ if $\\alpha&gt;0.5$</li>\n\t<li>$\\alpha^ y n=1$ and $(1-\\alpha)^ x n=1$ if $\\alpha&gt;0.5$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;d', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,multiple-selects,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376699', 'text': '<p>Insertion sort performs best case when input is sorted and worst case when input is sorted backwards.<br>\nCompute the average cost of insertion sort to sort a vector with $n$ different integers when with probability $\\frac{\\log n}{n}$ one chooses a vector which is sorted backwards and with probability $1-\\frac{\\log n}{n}$ one chooses a sorted vector.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta\\left(n^{3}\\right)$</li>\n\t<li>$\\Theta(n \\log n)$</li>\n\t<li>$\\Theta(n)$</li>\n\t<li>$\\Theta\\left(n^{2}\\right)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,insertion-sort,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376701', 'text': '<p>Let $T(n)=4 T(n / 3)+n^{\\log _{3} 4}.$ What will be asymptotic bound on $T(n)?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$T(n)=\\Theta\\left(n^{\\log _{3} 4} \\log n\\right)$</li>\n\t<li>$T(n)=\\Theta(n \\log n)$</li>\n\t<li>$T(n)=\\Theta\\left(4^{\\log _{3} n} \\log \\log n\\right)$</li>\n\t<li>None of these</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,asymptotic-notation,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376679', 'text': '<p>You are given a bit-array $A[1 \\ldots n]$ (i.e., $A[i] \\in\\{0,1\\}$ for each $i$ ) and told that this is a "$0$ -to-$1$” bit-array. This means that for some (unknown) index $1 \\leq j&lt;n, A[1], \\ldots, A[j]$ are all $0$ \'s and $A[j+1], \\ldots, A[n]$ are all $1$ \'s. The index $j$ for such an array is called the transition index. We design a divide and conquer algorithm for finding the transition index for a given $0$ -to- $1$ bit-array. The input to the algorithm is an array $A$ and the size $n$ of the array $A$. What will be the worst case time complexity of best divide and conquer algorithm?&nbsp;</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta(\\log n)$</li>\n\t<li>$\\Theta(n \\log n)$</li>\n\t<li>$\\Theta(n)$</li>\n\t<li>$\\Theta\\left(n^{2}\\right)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'A', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1-weekly-quiz,goclasses,algorithms,divide-and-conquer,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376706', 'text': '<p>$3$-Way-Merge Sort: Suppose that instead of dividing in half at each step of Merge Sort, you divide into thirds, sort each third, and finally combine all of them using a three-way merge subroutine. What is the overall asymptotic running time of this algorithm? (Hint: Note that the merge step can still be implemented in $\\mathrm{O}(n)$ time.)</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$n$</li>\n\t<li>$n \\log (n)$</li>\n\t<li>$n^{2} \\log (n)$</li>\n\t<li>$n(\\log (n))^{2}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,merge-sort,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376703', 'text': '<p>Recall the Partition subroutine that we used in QuickSort. Suppose that the following array has just been partitioned around some pivot element $: 3,1,2,4,5,8,7,6,9.$</p>\n\n<p>Which of these element(s) could have been the pivot element?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$4$</li>\n\t<li>$5$</li>\n\t<li>$2$</li>\n\t<li>$9$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b;d', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,multiple-selects,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376693', 'text': '<p>How many calls of merge-sort are performed when sorting an array of size $64 ?$ Base case is an array containing a single element.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2^{63}$</li>\n\t<li>$127$</li>\n\t<li>$63$</li>\n\t<li>$64$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,merge-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376698', 'text': 'Consider a constant $\\alpha = 0.3$. If we use randomized quick sort (pivot chosen is uniform random) then what is the probability that the partition method will result in an array such that the size of the smaller subarray is $\\geq \\alpha n$ where $n$ is the total size of the array?', 'type': 'Numerical', 'answer': '0.4', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,numerical-answers,goclasses,algorithms,sorting,quick-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376690', 'text': '<p>Consider an array of $n$ distinct integers. An array element is a peak if it is greater than its neighbors.<br>\nFor corner elements, we need to consider only one neighbor. The corner element is peak only when it\'s greater than its neighbors.<br>\nIf there are more than one peak item, simply return one of them.</p>\n\n<p>Example:</p>\n\n<ul>\n\t<li>Input $: [1, 5, 3, 2, 4, 0]$ Output $: 4$</li>\n\t<li>Input $: [1, 2, 3, 4, 5, 6]$ Output $: 6$</li>\n\t<li>Input $: [7, 6, 5, 4, 3, 2]$ Output $: 7$</li>\n</ul>\n\n<p>We design a divide-and-conquer algorithm that solves this problem. The incomplete pseudo-code is given below.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nfindPeak(A, i, j){\n    if(i==j) //one element\n        return i \n    if(i==j-1) //two elements\n        if(A[i]&gt; A[j] ) return i\n        else return j\n    mid = (i+j)/2\n    if (A[mid]&gt; A[mid-1] and A[mid]&gt; A[mid+1]) return mid\n    if (A[mid-1]&gt; A[mid])\n    //line X\n    if (A[mid+1]&gt; A[mid])\n    //line Y\n}\n</pre>\n\n<p>Fill in the blanks for lines $X$ and $Y$.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Line $X$ is return findPeak $(A, i,$ mid$-1)$</li>\n\t<li>Line $Y$ is return findPeak( $A$, mid $+1, j)$</li>\n\t<li>Line $X$ is return findPeak $(A$, mid $+1, j)$</li>\n\t<li>Line $Y$ is return findPeak $(A, i,$ mid$-1)$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,divide-and-conquer,multiple-selects,2-marks', 'category': 'Algorithms'}]}]}
      </script>
      