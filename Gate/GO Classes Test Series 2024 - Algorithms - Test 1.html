<div><span>Q1</span> - <p>An inversion in a vector of integers T[0 … n-1] is a pair of positions storing values that are not ordered, that is, a pair (i, j) such that 0 ≤   nbsp;i   lt;j   lt;n and T[i]   gt;T[j].</p>

<p>Let T[0 … 99] be an array of hundred integers. It is also given that T[0]   gt;T [10]. Relation between other elements is not given.<br>
Which of the following is/are true about a number of inversions.</p>

<ol style="list-style-type:upper-alpha">
	<li>There are at most   nbsp;11 inversions in the array.</li>
	<li>There are at least   nbsp;10 inversions in the array.</li>
	<li>There are at most   nbsp;10 inversions in the array.</li>
	<li>There are at least   nbsp;11 inversions in the array.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>Assume that the inputs of size n of a certain algorithm are of the following types:</p>

<ul>
	<li>Type 1: for each input of this type, the algorithm takes time Θ(n^4). Moreover, the probability that the input is of this type is 1/n^3.</li>
	<li>Type 2: for each input of this type, the algorithm takes time Θ(n^3). Moreover, the probability that the input is of this type is 1/n.</li>
	<li>Type 3 : for each input of this type, the algorithm takes time Θ(n). Moreover, the probability that the input is of this type is 1-1/n^3-1/n.</li>
</ul>

<p>Then the cost of the algorithm in the average case is</p>

<ol style="list-style-type:upper-alpha">
	<li>Θ(n^3)</li>
	<li>Θ(n^4)</li>
	<li>Θ(n)</li>
	<li>Θ(n^2)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <p>Consider two statements about RANDOMIZED QUICKSORT.</p>

<ul>
	<li>S1: There is some input for which randomized quicksort always runs in time Θ(n^ 2) time.</li>
	<li>S2: An adversary can provide randomized quicksort with an input array of length n that forces the algorithm to run in Θ(n  n) time on that input.</li>
</ul>

<p>Choose the correct option (assume distinct elements in input):</p>

<ol style="list-style-type:upper-alpha">
	<li>Both statements are correct</li>
	<li>S1 is correct, but S 2 is false</li>
	<li>S 1 is false, but S 2 is correct</li>
	<li>Both Statements are incorrect</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - <p>How many calls of merge-sort are performed when sorting an array of size 64 ? Base case is an array containing a single element.</p>

<ol style="list-style-type:upper-alpha">
	<li>2^63</li>
	<li>127</li>
	<li>63</li>
	<li>64</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - <p>Consider an array of n distinct integers. An array element is a peak if it is greater than its neighbors.<br>
For corner elements, we need to consider only one neighbor. The corner element is peak only when it's greater than its neighbors.<br>
If there are more than one peak item, simply return one of them.</p>

<p>Example:</p>

<ul>
	<li>Input : [1, 5, 3, 2, 4, 0] Output : 4</li>
	<li>Input : [1, 2, 3, 4, 5, 6] Output : 6</li>
	<li>Input : [7, 6, 5, 4, 3, 2] Output : 7</li>
</ul>

<p>We design a divide-and-conquer algorithm that solves this problem. The incomplete pseudo-code is given below.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
findPeak(A, i, j)
    if(i==j) //one element
        return i 
    if(i==j-1) //two elements
        if(A[i]   gt; A[j] ) return i
        else return j
    mid = (i+j)/2
    if (A[mid]   gt; A[mid-1] and A[mid]   gt; A[mid+1]) return mid
    if (A[mid-1]   gt; A[mid])
    //line X
    if (A[mid+1]   gt; A[mid])
    //line Y

</pre>

<p>Fill in the blanks for lines X and Y.</p>

<ol style="list-style-type:upper-alpha">
	<li>Line X is return findPeak (A, i, mid-1)</li>
	<li>Line Y is return findPeak( A, mid +1, j)</li>
	<li>Line X is return findPeak (A, mid +1, j)</li>
	<li>Line Y is return findPeak (A, i, mid-1)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - <p>Let T(n)=4 T(n / 3)+n^log _3 4. What will be asymptotic bound on T(n)?</p>

<ol style="list-style-type:upper-alpha">
	<li>T(n)=Θ(n^log _3 4log n)</li>
	<li>T(n)=Θ(n log n)</li>
	<li>T(n)=Θ(4^log _3 nloglog n)</li>
	<li>None of these</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - <p>Consider a quicksort where splits at every level are in the proportion of α, which means one of the partitions is   nbsp;α n and the other partition is (1-α) n. The recursive equation of time complexity can be written as</p>

<p>
    T(n)=T(α   nbsp;n)+T(1-α) n)+n.
 Consider a recursion tree of function calls and let x be the height of the tree when we hit the base case the first time and let y be the maximum height of the tree then, which of the following is/are true?<br>
Base case is an array containing single element.</p>

<ol style="list-style-type:upper-alpha">
	<li>α^ x n=1 and (1-α)^ y n=1 if α   lt;0.5</li>
	<li>α^ y n=1 and (1-α)^ x n=1 if α   lt;0.5</li>
	<li>α^ x n=1 and (1-α)^ y n=1 if α   gt;0.5</li>
	<li>α^ y n=1 and (1-α)^ x n=1 if α   gt;0.5</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - Consider a constant α = 0.3. If we use randomized quick sort (pivot chosen is uniform random) then what is the probability that the partition method will result in an array such that the size of the smaller subarray is ≥α n where n is the total size of the array?<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - <p>A lazy programmer thinks that implementing the procedure Merge (of the merge sort) is too complicated. To simplify merge sort he eliminates the merge all together, and only recursively "sorts" the two halves of the array. Here is his pseudo-code.</p>

<p>   nbsp;</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
procedure LAZYSORT(A[1..n])
    if n   gt;1 then
        m ←⌊n/2⌋
        LAZYSORT(A[1..m])
        LAZYSORT(A[m+1..n])</pre>

<p>Which of the following is/are TRUE about LAZYSORT?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>The Time Complexity of LAZYSORT is θ(n log n)</li>
	<li>The Time Complexity of LAZYSORT is θ(n)</li>
	<li>LAZYSORT changes the original array in such a way that it exchanges the first half of the array with the second half.</li>
	<li>LAZYSORT does not change array elements at all</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>3-Way-Merge Sort: Suppose that instead of dividing in half at each step of Merge Sort, you divide into thirds, sort each third, and finally combine all of them using a three-way merge subroutine. What is the overall asymptotic running time of this algorithm? (Hint: Note that the merge step can still be implemented in O(n) time.)</p>

<ol style="list-style-type:upper-alpha">
	<li>n</li>
	<li>n log (n)</li>
	<li>n^2log (n)</li>
	<li>n(log (n))^2</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - <p>Recall the Partition subroutine that we used in QuickSort. Suppose that the following array has just been partitioned around some pivot element : 3,1,2,4,5,8,7,6,9.</p>

<p>Which of these element(s) could have been the pivot element?</p>

<ol style="list-style-type:upper-alpha">
	<li>4</li>
	<li>5</li>
	<li>2</li>
	<li>9</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>Consider partition algorithm of randomized quick sort which randomly choose pivot element and split the array into two halves accordingly. Pivot element will not be in any of the subarrays.</p>

<p>Suppose array length is n which is odd then what is the probability that median element lies in second half after partition?</p>

<ol style="list-style-type:upper-alpha">
	<li>1 / 2</li>
	<li>1 / 2-1 / 2n</li>
	<li>1 / 2-2 / n</li>
	<li>1-1 / 2 n</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Suppose you are given k sorted arrays, each with n elements, and you want to combine them into a single array of kn elements. Consider the following approach. Divide the k arrays into k   nbsp;/ 2 pairs of arrays, and use the Merge subroutine of MergeSort to combine each pair. Now you are left with k / 2 sorted arrays, each with 2 n elements.</p>

<p>Repeat this approach until you have a single sorted array with kn elements. What is the running time of this procedure, as a function of k and n?   nbsp;</p>

<ol style="list-style-type:upper-alpha">
	<li>Θ(n k log k)</li>
	<li>Θ(n k^ 2)</li>
	<li>Θ(n k log n)</li>
	<li>Θ(n log k)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q14</span> - <p>Insertion sort performs best case when input is sorted and worst case when input is sorted backwards.<br>
Compute the average cost of insertion sort to sort a vector with n different integers when with probability log n/n one chooses a vector which is sorted backwards and with probability 1-log n/n one chooses a sorted vector.</p>

<ol style="list-style-type:upper-alpha">
	<li>Θ(n^3)</li>
	<li>Θ(n log n)</li>
	<li>Θ(n)</li>
	<li>Θ(n^2)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q15</span> - <p>Let A[1 … n] be an array of n distinct numbers. If i   lt;j and A[i]   gt;A[j], then the pair (i, j) is called an inversion of A.</p>

<p>Suppose that each element of A is chosen randomly, independently, and uniformly from the range 1 through n.</p>

<p>What will be the expected number of inversions?</p>

<ol style="list-style-type:upper-alpha">
	<li>n(n-1) / 4</li>
	<li>n</li>
	<li>n(n-1) / 2</li>
	<li>n^ 2 / 2</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let q = [{'contents': '', 'post_id': '376685', 'text': '<p>An inversion in a vector of integers $T[0 \\ldots n-1]$ is a pair of positions storing values that are not ordered, that is, a pair $(i, j)$ such that $0 \\leq&nbsp;i&lt;j&lt;n$ and $T[i]&gt;T[j]$.</p>\n\n<p>Let $T[0 \\ldots 99]$ be an array of hundred integers. It is also given that $T[0]&gt;T [10]$. Relation between other elements is not given.<br>\nWhich of the following is/are true about a number of inversions.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>There are at most&nbsp;$11$ inversions in the array.</li>\n\t<li>There are at least&nbsp;$10$ inversions in the array.</li>\n\t<li>There are at most&nbsp;$10$ inversions in the array.</li>\n\t<li>There are at least&nbsp;$11$ inversions in the array.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,array,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376683', 'text': '<p>Assume that the inputs of size $n$ of a certain algorithm are of the following types:</p>\n\n<ul>\n\t<li>Type $1:$ for each input of this type, the algorithm takes time $\\Theta\\left(n^{4}\\right)$. Moreover, the probability that the input is of this type is $\\frac{1}{n^{3}}$.</li>\n\t<li>Type $2:$ for each input of this type, the algorithm takes time $\\Theta\\left(n^{3}\\right)$. Moreover, the probability that the input is of this type is $\\frac{1}{n}$.</li>\n\t<li>Type $3 :$ for each input of this type, the algorithm takes time $\\Theta(n)$. Moreover, the probability that the input is of this type is $1-\\frac{1}{n^{3}}-\\frac{1}{n}$.</li>\n</ul>\n\n<p>Then the cost of the algorithm in the average case is</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta\\left(n^{3}\\right)$</li>\n\t<li>$\\Theta\\left(n^{4}\\right)$</li>\n\t<li>$\\Theta(n)$</li>\n\t<li>$\\Theta\\left(n^{2}\\right)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,asymptotic-notation,time-complexity,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376686', 'text': '<p>Consider two statements about RANDOMIZED QUICKSORT.</p>\n\n<ul>\n\t<li>$S1:$ There is some input for which randomized quicksort always runs in time $\\Theta\\left(n^ 2\\right)$ time.</li>\n\t<li>$S2:$ An adversary can provide randomized quicksort with an input array of length $n$ that forces the algorithm to run in $\\Theta(n \\lg n)$ time on that input.</li>\n</ul>\n\n<p>Choose the correct option (assume distinct elements in input):</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Both statements are correct</li>\n\t<li>$S1$ is correct, but $S 2$ is false</li>\n\t<li>$S 1$ is false, but $S 2$ is correct</li>\n\t<li>Both Statements are incorrect</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'D', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376693', 'text': '<p>How many calls of merge-sort are performed when sorting an array of size $64 ?$ Base case is an array containing a single element.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2^{63}$</li>\n\t<li>$127$</li>\n\t<li>$63$</li>\n\t<li>$64$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,merge-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376690', 'text': '<p>Consider an array of $n$ distinct integers. An array element is a peak if it is greater than its neighbors.<br>\nFor corner elements, we need to consider only one neighbor. The corner element is peak only when it\'s greater than its neighbors.<br>\nIf there are more than one peak item, simply return one of them.</p>\n\n<p>Example:</p>\n\n<ul>\n\t<li>Input $: [1, 5, 3, 2, 4, 0]$ Output $: 4$</li>\n\t<li>Input $: [1, 2, 3, 4, 5, 6]$ Output $: 6$</li>\n\t<li>Input $: [7, 6, 5, 4, 3, 2]$ Output $: 7$</li>\n</ul>\n\n<p>We design a divide-and-conquer algorithm that solves this problem. The incomplete pseudo-code is given below.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nfindPeak(A, i, j){\n    if(i==j) //one element\n        return i \n    if(i==j-1) //two elements\n        if(A[i]&gt; A[j] ) return i\n        else return j\n    mid = (i+j)/2\n    if (A[mid]&gt; A[mid-1] and A[mid]&gt; A[mid+1]) return mid\n    if (A[mid-1]&gt; A[mid])\n    //line X\n    if (A[mid+1]&gt; A[mid])\n    //line Y\n}\n</pre>\n\n<p>Fill in the blanks for lines $X$ and $Y$.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Line $X$ is return findPeak $(A, i,$ mid$-1)$</li>\n\t<li>Line $Y$ is return findPeak( $A$, mid $+1, j)$</li>\n\t<li>Line $X$ is return findPeak $(A$, mid $+1, j)$</li>\n\t<li>Line $Y$ is return findPeak $(A, i,$ mid$-1)$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,divide-and-conquer,multiple-selects,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376701', 'text': '<p>Let $T(n)=4 T(n / 3)+n^{\\log _{3} 4}.$ What will be asymptotic bound on $T(n)?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$T(n)=\\Theta\\left(n^{\\log _{3} 4} \\log n\\right)$</li>\n\t<li>$T(n)=\\Theta(n \\log n)$</li>\n\t<li>$T(n)=\\Theta\\left(4^{\\log _{3} n} \\log \\log n\\right)$</li>\n\t<li>None of these</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,asymptotic-notation,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376697', 'text': '<p>Consider a quicksort where splits at every level are in the proportion of $\\alpha$, which means one of the partitions is&nbsp;$\\alpha n$ and the other partition is $(1-\\alpha) n$. The recursive equation of time complexity can be written as</p>\n\n<p>$$T(n)=T(\\alpha&nbsp;n)+T(1-\\alpha) n)+n.$$ Consider a recursion tree of function calls and let $x$ be the height of the tree when we hit the base case the first time and let $y$ be the maximum height of the tree then, which of the following is/are true?<br>\nBase case is an array containing single element.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\alpha^ x n=1$ and $(1-\\alpha)^ y n=1$ if $\\alpha&lt;0.5$</li>\n\t<li>$\\alpha^ y n=1$ and $(1-\\alpha)^ x n=1$ if $\\alpha&lt;0.5$</li>\n\t<li>$\\alpha^ x n=1$ and $(1-\\alpha)^ y n=1$ if $\\alpha&gt;0.5$</li>\n\t<li>$\\alpha^ y n=1$ and $(1-\\alpha)^ x n=1$ if $\\alpha&gt;0.5$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;d', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,multiple-selects,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376698', 'text': 'Consider a constant $\\alpha = 0.3$. If we use randomized quick sort (pivot chosen is uniform random) then what is the probability that the partition method will result in an array such that the size of the smaller subarray is $\\geq \\alpha n$ where $n$ is the total size of the array?', 'type': 'Numerical', 'answer': '0.4', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,numerical-answers,goclasses,algorithms,sorting,quick-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '407824', 'text': '<p>A lazy programmer thinks that implementing the procedure Merge (of the merge sort) is too complicated. To simplify merge sort he eliminates the merge all together, and only recursively "sorts" the two halves of the array. Here is his pseudo-code.</p>\n\n<p>&nbsp;</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nprocedure LAZYSORT(A[1..n])\n    if n&gt;1 then\n        m ←⌊n/2⌋\n        LAZYSORT(A[1..m])\n        LAZYSORT(A[m+1..n])</pre>\n\n<p>Which of the following is/are TRUE about LAZYSORT?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>The Time Complexity of LAZYSORT is $\\theta(n \\log n)$</li>\n\t<li>The Time Complexity of LAZYSORT is $\\theta(n)$</li>\n\t<li>LAZYSORT changes the original array in such a way that it exchanges the first half of the array with the second half.</li>\n\t<li>LAZYSORT does not change array elements at all</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'B;D', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,merge-sort,multiple-selects,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376706', 'text': '<p>$3$-Way-Merge Sort: Suppose that instead of dividing in half at each step of Merge Sort, you divide into thirds, sort each third, and finally combine all of them using a three-way merge subroutine. What is the overall asymptotic running time of this algorithm? (Hint: Note that the merge step can still be implemented in $\\mathrm{O}(n)$ time.)</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$n$</li>\n\t<li>$n \\log (n)$</li>\n\t<li>$n^{2} \\log (n)$</li>\n\t<li>$n(\\log (n))^{2}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,merge-sort,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376703', 'text': '<p>Recall the Partition subroutine that we used in QuickSort. Suppose that the following array has just been partitioned around some pivot element $: 3,1,2,4,5,8,7,6,9.$</p>\n\n<p>Which of these element(s) could have been the pivot element?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$4$</li>\n\t<li>$5$</li>\n\t<li>$2$</li>\n\t<li>$9$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b;d', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,multiple-selects,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376696', 'text': '<p>Consider partition algorithm of randomized quick sort which randomly choose pivot element and split the array into two halves accordingly. Pivot element will not be in any of the subarrays.</p>\n\n<p>Suppose array length is $n$ which is odd then what is the probability that median element lies in second half after partition?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1 / 2$</li>\n\t<li>$1 / 2-1 / 2n$</li>\n\t<li>$1 / 2-2 / n$</li>\n\t<li>$1-1 / 2 n$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'B', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376691', 'text': '<p>Suppose you are given $k$ sorted arrays, each with $n$ elements, and you want to combine them into a single array of kn elements. Consider the following approach. Divide the $k$ arrays into $k&nbsp;/ 2$ pairs of arrays, and use the Merge subroutine of MergeSort to combine each pair. Now you are left with $k / 2$ sorted arrays, each with $2 n$ elements.</p>\n\n<p>Repeat this approach until you have a single sorted array with kn elements. What is the running time of this procedure, as a function of $k$ and $n?$&nbsp;</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta(n k \\log k)$</li>\n\t<li>$\\Theta\\left(n k^ 2\\right)$</li>\n\t<li>$\\Theta(n k \\log n)$</li>\n\t<li>$\\Theta(n \\log k)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,merge-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376699', 'text': '<p>Insertion sort performs best case when input is sorted and worst case when input is sorted backwards.<br>\nCompute the average cost of insertion sort to sort a vector with $n$ different integers when with probability $\\frac{\\log n}{n}$ one chooses a vector which is sorted backwards and with probability $1-\\frac{\\log n}{n}$ one chooses a sorted vector.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta\\left(n^{3}\\right)$</li>\n\t<li>$\\Theta(n \\log n)$</li>\n\t<li>$\\Theta(n)$</li>\n\t<li>$\\Theta\\left(n^{2}\\right)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,insertion-sort,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376680', 'text': '<p>Let $A[1 \\ldots n]$ be an array of $n$ distinct numbers. If $i&lt;j$ and $A[i]&gt;A[j]$, then the pair $(i, j)$ is called an inversion of $A$.</p>\n\n<p>Suppose that each element of $A$ is chosen randomly, independently, and uniformly from the range $1$ through $n$.</p>\n\n<p>What will be the expected number of inversions?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$n(n-1) / 4$</li>\n\t<li>$n$</li>\n\t<li>$n(n-1) / 2$</li>\n\t<li>$n^ 2 / 2$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,array,2-marks', 'category': 'Algorithms'}]
      let data={'name': 'GO Classes Test Series 2024 | Algorithms | Test 1', 'duration': '45', 'total_qs': '15', 'total_qs_one': 5, 'total_qs_two': 10, 'apti_num_qs': 0, 'technical_num_qs': 15, 'apti_marks': 0, 'technical_marks': 25, 'total_marks': 25, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 15, 'marks': 25, 'question': [{'contents': '', 'post_id': '376685', 'text': '<p>An inversion in a vector of integers $T[0 \\ldots n-1]$ is a pair of positions storing values that are not ordered, that is, a pair $(i, j)$ such that $0 \\leq&nbsp;i&lt;j&lt;n$ and $T[i]&gt;T[j]$.</p>\n\n<p>Let $T[0 \\ldots 99]$ be an array of hundred integers. It is also given that $T[0]&gt;T [10]$. Relation between other elements is not given.<br>\nWhich of the following is/are true about a number of inversions.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>There are at most&nbsp;$11$ inversions in the array.</li>\n\t<li>There are at least&nbsp;$10$ inversions in the array.</li>\n\t<li>There are at most&nbsp;$10$ inversions in the array.</li>\n\t<li>There are at least&nbsp;$11$ inversions in the array.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,array,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376683', 'text': '<p>Assume that the inputs of size $n$ of a certain algorithm are of the following types:</p>\n\n<ul>\n\t<li>Type $1:$ for each input of this type, the algorithm takes time $\\Theta\\left(n^{4}\\right)$. Moreover, the probability that the input is of this type is $\\frac{1}{n^{3}}$.</li>\n\t<li>Type $2:$ for each input of this type, the algorithm takes time $\\Theta\\left(n^{3}\\right)$. Moreover, the probability that the input is of this type is $\\frac{1}{n}$.</li>\n\t<li>Type $3 :$ for each input of this type, the algorithm takes time $\\Theta(n)$. Moreover, the probability that the input is of this type is $1-\\frac{1}{n^{3}}-\\frac{1}{n}$.</li>\n</ul>\n\n<p>Then the cost of the algorithm in the average case is</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta\\left(n^{3}\\right)$</li>\n\t<li>$\\Theta\\left(n^{4}\\right)$</li>\n\t<li>$\\Theta(n)$</li>\n\t<li>$\\Theta\\left(n^{2}\\right)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,asymptotic-notation,time-complexity,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376686', 'text': '<p>Consider two statements about RANDOMIZED QUICKSORT.</p>\n\n<ul>\n\t<li>$S1:$ There is some input for which randomized quicksort always runs in time $\\Theta\\left(n^ 2\\right)$ time.</li>\n\t<li>$S2:$ An adversary can provide randomized quicksort with an input array of length $n$ that forces the algorithm to run in $\\Theta(n \\lg n)$ time on that input.</li>\n</ul>\n\n<p>Choose the correct option (assume distinct elements in input):</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Both statements are correct</li>\n\t<li>$S1$ is correct, but $S 2$ is false</li>\n\t<li>$S 1$ is false, but $S 2$ is correct</li>\n\t<li>Both Statements are incorrect</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'D', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376693', 'text': '<p>How many calls of merge-sort are performed when sorting an array of size $64 ?$ Base case is an array containing a single element.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2^{63}$</li>\n\t<li>$127$</li>\n\t<li>$63$</li>\n\t<li>$64$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,merge-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376690', 'text': '<p>Consider an array of $n$ distinct integers. An array element is a peak if it is greater than its neighbors.<br>\nFor corner elements, we need to consider only one neighbor. The corner element is peak only when it\'s greater than its neighbors.<br>\nIf there are more than one peak item, simply return one of them.</p>\n\n<p>Example:</p>\n\n<ul>\n\t<li>Input $: [1, 5, 3, 2, 4, 0]$ Output $: 4$</li>\n\t<li>Input $: [1, 2, 3, 4, 5, 6]$ Output $: 6$</li>\n\t<li>Input $: [7, 6, 5, 4, 3, 2]$ Output $: 7$</li>\n</ul>\n\n<p>We design a divide-and-conquer algorithm that solves this problem. The incomplete pseudo-code is given below.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nfindPeak(A, i, j){\n    if(i==j) //one element\n        return i \n    if(i==j-1) //two elements\n        if(A[i]&gt; A[j] ) return i\n        else return j\n    mid = (i+j)/2\n    if (A[mid]&gt; A[mid-1] and A[mid]&gt; A[mid+1]) return mid\n    if (A[mid-1]&gt; A[mid])\n    //line X\n    if (A[mid+1]&gt; A[mid])\n    //line Y\n}\n</pre>\n\n<p>Fill in the blanks for lines $X$ and $Y$.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Line $X$ is return findPeak $(A, i,$ mid$-1)$</li>\n\t<li>Line $Y$ is return findPeak( $A$, mid $+1, j)$</li>\n\t<li>Line $X$ is return findPeak $(A$, mid $+1, j)$</li>\n\t<li>Line $Y$ is return findPeak $(A, i,$ mid$-1)$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,divide-and-conquer,multiple-selects,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376701', 'text': '<p>Let $T(n)=4 T(n / 3)+n^{\\log _{3} 4}.$ What will be asymptotic bound on $T(n)?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$T(n)=\\Theta\\left(n^{\\log _{3} 4} \\log n\\right)$</li>\n\t<li>$T(n)=\\Theta(n \\log n)$</li>\n\t<li>$T(n)=\\Theta\\left(4^{\\log _{3} n} \\log \\log n\\right)$</li>\n\t<li>None of these</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,asymptotic-notation,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376697', 'text': '<p>Consider a quicksort where splits at every level are in the proportion of $\\alpha$, which means one of the partitions is&nbsp;$\\alpha n$ and the other partition is $(1-\\alpha) n$. The recursive equation of time complexity can be written as</p>\n\n<p>$$T(n)=T(\\alpha&nbsp;n)+T(1-\\alpha) n)+n.$$ Consider a recursion tree of function calls and let $x$ be the height of the tree when we hit the base case the first time and let $y$ be the maximum height of the tree then, which of the following is/are true?<br>\nBase case is an array containing single element.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\alpha^ x n=1$ and $(1-\\alpha)^ y n=1$ if $\\alpha&lt;0.5$</li>\n\t<li>$\\alpha^ y n=1$ and $(1-\\alpha)^ x n=1$ if $\\alpha&lt;0.5$</li>\n\t<li>$\\alpha^ x n=1$ and $(1-\\alpha)^ y n=1$ if $\\alpha&gt;0.5$</li>\n\t<li>$\\alpha^ y n=1$ and $(1-\\alpha)^ x n=1$ if $\\alpha&gt;0.5$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;d', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,multiple-selects,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376698', 'text': 'Consider a constant $\\alpha = 0.3$. If we use randomized quick sort (pivot chosen is uniform random) then what is the probability that the partition method will result in an array such that the size of the smaller subarray is $\\geq \\alpha n$ where $n$ is the total size of the array?', 'type': 'Numerical', 'answer': '0.4', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,numerical-answers,goclasses,algorithms,sorting,quick-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '407824', 'text': '<p>A lazy programmer thinks that implementing the procedure Merge (of the merge sort) is too complicated. To simplify merge sort he eliminates the merge all together, and only recursively "sorts" the two halves of the array. Here is his pseudo-code.</p>\n\n<p>&nbsp;</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nprocedure LAZYSORT(A[1..n])\n    if n&gt;1 then\n        m ←⌊n/2⌋\n        LAZYSORT(A[1..m])\n        LAZYSORT(A[m+1..n])</pre>\n\n<p>Which of the following is/are TRUE about LAZYSORT?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>The Time Complexity of LAZYSORT is $\\theta(n \\log n)$</li>\n\t<li>The Time Complexity of LAZYSORT is $\\theta(n)$</li>\n\t<li>LAZYSORT changes the original array in such a way that it exchanges the first half of the array with the second half.</li>\n\t<li>LAZYSORT does not change array elements at all</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'B;D', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,merge-sort,multiple-selects,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376706', 'text': '<p>$3$-Way-Merge Sort: Suppose that instead of dividing in half at each step of Merge Sort, you divide into thirds, sort each third, and finally combine all of them using a three-way merge subroutine. What is the overall asymptotic running time of this algorithm? (Hint: Note that the merge step can still be implemented in $\\mathrm{O}(n)$ time.)</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$n$</li>\n\t<li>$n \\log (n)$</li>\n\t<li>$n^{2} \\log (n)$</li>\n\t<li>$n(\\log (n))^{2}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,merge-sort,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376703', 'text': '<p>Recall the Partition subroutine that we used in QuickSort. Suppose that the following array has just been partitioned around some pivot element $: 3,1,2,4,5,8,7,6,9.$</p>\n\n<p>Which of these element(s) could have been the pivot element?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$4$</li>\n\t<li>$5$</li>\n\t<li>$2$</li>\n\t<li>$9$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b;d', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,multiple-selects,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376696', 'text': '<p>Consider partition algorithm of randomized quick sort which randomly choose pivot element and split the array into two halves accordingly. Pivot element will not be in any of the subarrays.</p>\n\n<p>Suppose array length is $n$ which is odd then what is the probability that median element lies in second half after partition?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1 / 2$</li>\n\t<li>$1 / 2-1 / 2n$</li>\n\t<li>$1 / 2-2 / n$</li>\n\t<li>$1-1 / 2 n$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'B', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,quick-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376691', 'text': '<p>Suppose you are given $k$ sorted arrays, each with $n$ elements, and you want to combine them into a single array of kn elements. Consider the following approach. Divide the $k$ arrays into $k&nbsp;/ 2$ pairs of arrays, and use the Merge subroutine of MergeSort to combine each pair. Now you are left with $k / 2$ sorted arrays, each with $2 n$ elements.</p>\n\n<p>Repeat this approach until you have a single sorted array with kn elements. What is the running time of this procedure, as a function of $k$ and $n?$&nbsp;</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta(n k \\log k)$</li>\n\t<li>$\\Theta\\left(n k^ 2\\right)$</li>\n\t<li>$\\Theta(n k \\log n)$</li>\n\t<li>$\\Theta(n \\log k)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,merge-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376699', 'text': '<p>Insertion sort performs best case when input is sorted and worst case when input is sorted backwards.<br>\nCompute the average cost of insertion sort to sort a vector with $n$ different integers when with probability $\\frac{\\log n}{n}$ one chooses a vector which is sorted backwards and with probability $1-\\frac{\\log n}{n}$ one chooses a sorted vector.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\Theta\\left(n^{3}\\right)$</li>\n\t<li>$\\Theta(n \\log n)$</li>\n\t<li>$\\Theta(n)$</li>\n\t<li>$\\Theta\\left(n^{2}\\right)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,sorting,insertion-sort,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '376680', 'text': '<p>Let $A[1 \\ldots n]$ be an array of $n$ distinct numbers. If $i&lt;j$ and $A[i]&gt;A[j]$, then the pair $(i, j)$ is called an inversion of $A$.</p>\n\n<p>Suppose that each element of $A$ is chosen randomly, independently, and uniformly from the range $1$ through $n$.</p>\n\n<p>What will be the expected number of inversions?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$n(n-1) / 4$</li>\n\t<li>$n$</li>\n\t<li>$n(n-1) / 2$</li>\n\t<li>$n^ 2 / 2$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-1,goclasses,algorithms,array,2-marks', 'category': 'Algorithms'}]}]}
      </script>
      