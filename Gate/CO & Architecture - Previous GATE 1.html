<div><span>Q1</span> - <p>Register renaming is done in pipelined processors:</p>

<ol style="list-style-type:upper-alpha">
	<li>as an alternative to register allocation at compile time</li>
	<li>for efficient access to function parameters and local variables</li>
	<li>to handle certain kinds of hazards</li>
	<li>as part of address translation</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>Comparing the time T1 taken for a single instruction on a pipelined CPU with time T2 taken on a non-pipelined but identical CPU, we can say that</p>

<ol style="list-style-type: upper-alpha;">
	<li>T1   nbsp;≤ T2</li>
	<li>T1   nbsp;≥ T2</li>
	<li>T1   nbsp;   lt; T2</li>
	<li>T1 and T2 plus the time taken for one instruction fetch cycle</li>
</ol>

<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <p>More than one word are put in one cache block to:</p>

<ol style="list-style-type:upper-alpha">
	<li>exploit the temporal locality of reference in a program</li>
	<li>exploit the spatial locality of reference in a program</li>
	<li>reduce the miss penalty</li>
	<li>none of the above</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - <p>Which of the following is not a form of memory</p>

<ol style="list-style-type:upper-alpha">
	<li>instruction cache</li>
	<li>instruction register</li>
	<li>instruction opcode</li>
	<li>translation look-a-side buffer</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - <p>In the absolute addressing mode:</p>

<ol style="list-style-type:upper-alpha">
	<li>the operand is inside the instruction</li>
	<li>the address of the operand in inside the instruction</li>
	<li>the register containing the address of the operand is specified inside the instruction</li>
	<li>the location of the operand is implicit</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - <p>The performance of a pipelined processor suffers if:</p>

<ol style="list-style-type:upper-alpha">
	<li>the pipeline stages have different delays</li>
	<li>consecutive instructions are dependent on each other</li>
	<li>the pipeline stages share hardware resources</li>
	<li>All of the above</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - <p>A CPU has 24-bit instructions. A program starts at address 300 (in decimal). Which one of the following is a legal program counter (all values in decimal)?</p>

<ol style="list-style-type:upper-alpha">
	<li>400</li>
	<li>500</li>
	<li>600</li>
	<li>700</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - <p>For a pipelined CPU with a single ALU, consider the following situations</p>

<ol style="list-style-type:upper-roman">
	<li>
	<p>The j+1^st instruction uses the result of the j^th instruction as an operand</p>
	</li>
	<li>
	<p>The execution of a conditional jump instruction</p>
	</li>
	<li>
	<p>The j^th and j+1^st instructions require the ALU at the same time.</p>
	</li>
</ol>

<p>Which of the above can cause a hazard</p>

<ol style="list-style-type:upper-alpha">
	<li>I and II only</li>
	<li>II and III only</li>
	<li>III only</li>
	<li>All the three</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - <p>Which of the following addressing modes are suitable for program relocation at run time?</p>

<ol style="list-style-type:upper-roman">
	<li>
	<p>Absolute addressing</p>
	</li>
	<li>
	<p>Based addressing</p>
	</li>
	<li>
	<p>Relative addressing</p>
	</li>
	<li>
	<p>Indirect addressing</p>
	</li>
</ol>

<ol style="list-style-type:upper-alpha">
	<li>I   nbsp;and IV</li>
	<li>I   nbsp;and II</li>
	<li>II   nbsp;and III</li>
	<li>I, II   nbsp;and IV</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>Consider a pipelined processor with the following four stages:</p>

<ul>
<li>IF: Instruction Fetch</li>
<li>ID: Instruction Decode and Operand Fetch</li>
<li>EX: Execute</li>
<li>WB: Write Back</li>
</ul>

<p>The IF, ID and WB stages take one clock cycle each to complete the operation. The number of clock cycles for the EX stage depends on the instruction. The ADD and SUB instructions need 1 clock cycle and the MUL instruction needs 3 clock cycles in the EX stage. Operand forwarding is used in the pipelined processor. What is the number of clock cycles taken to complete the following sequence of instructions?<br>

    [        nbsp;ADD amp; R2, R1, R0            amp;            amp; amp; R2 ← R1+R0;       nbsp; MUL amp; R4, R3, R2            amp;            amp; amp; R4 ← R3*R2;           nbsp;        nbsp;SUB amp; R6, R5, R4            amp;            amp; amp; R6 ← R5-R4;           nbsp;           nbsp; ]
</p>

<ol style="list-style-type:upper-alpha">
<li>7</li>
<li>8</li>
<li>10</li>
<li>14</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - <p>A CPU generally handles an interrupt by executing an interrupt service routine:</p>

<ol style="list-style-type:upper-alpha">
	<li>
	<p>As soon as an interrupt is raised.</p>
	</li>
	<li>
	<p>By checking the interrupt register at the end of fetch cycle.</p>
	</li>
	<li>
	<p>By checking the interrupt register after finishing the execution of the current instruction.</p>
	</li>
	<li>
	<p>By checking the interrupt register at fixed time intervals.</p>
	</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>Match each of the high level language statements given on the left hand side with the most natural addressing mode from those listed on the right hand side.
    [                nbsp;(1)         amp;A[I] = B[J]            amp;     (a) amp;Indirect addressing;           nbsp;<br>
    (2)      amp;while (^*A++);            amp;     (b) amp; Indexed addressing;                   nbsp;           nbsp;<br>
    (3)     amp; int temp = ^*x            amp;     (c)      amp;Auto increment                   nbsp;;                   nbsp; ]
</p>

<ol style="list-style-type:upper-alpha">
	<li>(1, c), (2, b), (3, a)</li>
	<li>(1, c), (2, c), (3, b)</li>
	<li>(1, b), (2, c), (3, a)</li>
	<li>(1, a), (2, b), (3, c)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Consider a direct mapped cache of size 32 KB with block size 32 bytes. The CPU generates 32 bit addresses. The number of bits needed for cache indexing and the number of tag bits are respectively,</p>

<ol style="list-style-type:upper-alpha">
	<li>10, 17</li>
	<li>10, 22</li>
	<li>15, 17</li>
	<li>5, 17</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q14</span> - 
<p>Which of the following addressing modes permits relocation without any change whatsoever in the code?</p>

<ol style="list-style-type:upper-alpha"><li>
	<p>Indirect addressing</p>
	</li>
	<li>
	<p>Indexed addressing</p>
	</li>
	<li>
	<p>Base register addressing</p>
	</li>
	<li>
	<p>PC relative addressing</p>
	</li>
</ol>
<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q15</span> - A machine has a 32-bit architecture, with 1-word long instructions. It has 64 registers, each of which is 32 bits long. It needs to support 45 instructions, which have an immediate operand in addition to two register operands. Assuming that the immediate operand is an unsigned integer, the maximum value of the immediate operand is ____________<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q16</span> - A 4-way set-associative cache memory unit with a capacity of 16 KB is built using a block size of 8 words. The word length is 32 bits. The size of the physical address space is 4 GB. The number of bits for the TAG field is ____<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q17</span> - <p>Consider the following processors (ns stands for nanoseconds). Assume that the pipeline registers have zero latency.   nbsp;</p>

<ul>
	<li>P1: Four-stage pipeline with stage latencies 1   nbsp;ns, 2   nbsp;ns, 2   nbsp;ns, 1   nbsp;ns.   nbsp;</li>
	<li>P2: Four-stage pipeline with stage latencies 1   nbsp;ns, 1.5   nbsp;ns, 1.5   nbsp;ns, 1.5   nbsp;ns.   nbsp;</li>
	<li>P3: Five-stage pipeline with stage latencies 0.5   nbsp;ns, 1   nbsp;ns, 1   nbsp;ns, 0.6   nbsp;ns, 1 ns.   nbsp;</li>
	<li>P4: Five-stage pipeline with stage latencies 0.5   nbsp;ns, 0.5   nbsp;ns, 1   nbsp;ns, 1 ns, 1.1   nbsp;ns.   nbsp;</li>
</ul>

<p>Which processor has the highest peak clock frequency?</p>

<ol style="list-style-type:upper-alpha">
	<li>P1</li>
	<li>P2</li>
	<li>P3</li>
	<li>P4</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q18</span> - <p>Consider a hypothetical processor with an instruction of type LW    nbsp;R1, 20(R2), which during execution reads a 32-bit word from memory and stores it in a 32-bit register R1. The effective address of the memory location is obtained by the addition of a constant 20 and the contents of register R2. Which of the following best reflects the addressing mode implemented by this instruction for the operand in memory?</p>

<ol style="list-style-type:upper-alpha">
	<li>Immediate addressing</li>
	<li>Register addressing</li>
	<li>Register Indirect Scaled Addressing</li>
	<li>Base Indexed Addressing</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q19</span> - <p>Relative mode of addressing is most relevant to writing:</p>

<ol style="list-style-type:upper-alpha">
	<li>
	<p>Co – routines</p>
	</li>
	<li>
	<p>Position – independent code</p>
	</li>
	<li>
	<p>Shareable code</p>
	</li>
	<li>
	<p>Interrupt Handlers</p>
	</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q20</span> - <p>The principle of locality justifies the use of:</p>

<ol style="list-style-type:upper-alpha">
	<li>Interrupts</li>
	<li>DMA</li>
	<li>Polling</li>
	<li>Cache Memory</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q21</span> - <p>Consider a system with a two-level paging scheme in which a regular memory access takes 150 nanoseconds, and servicing a page fault takes 8 milliseconds. An average instruction takes 100 nanoseconds of CPU time, and two memory accesses. The TLB hit ratio is 90

<ol style="list-style-type:upper-alpha">
<li>645 nanoseconds</li>
<li>1050 nanoseconds</li>
<li>1215 nanoseconds</li>
<li>1230 nanoseconds</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q22</span> - <p>Consider an instruction pipeline with five stages without any branch prediction:</p>

<p>Fetch Instruction   nbsp;(FI), Decode Instruction (DI), Fetch Operand (FO), Execute Instruction (EI) and Write Operand   nbsp;(WO). The stage delays for FI, DI, FO, EI and WO are   nbsp;5 ns, 7 ns, 10 ns, 8 ns and 6 ns, respectively. There are intermediate storage buffers after each stage and the delay of each buffer is 1 ns. A program consisting of 12 instructions I1, I2, I3,…, I12 is executed in this pipelined processor. Instruction I4 is the only branch instruction and its branch target is I9. If the branch is taken during the execution of this program, the time (in ns) needed to complete the program is</p>

<ol style="list-style-type:upper-alpha">
	<li>   nbsp;132   nbsp;    nbsp;</li>
	<li>   nbsp;165   nbsp;</li>
	<li>   nbsp;176</li>
	<li>   nbsp;328</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q23</span> - <p>Which of the following is/are true of the auto-increment addressing mode?</p>

<ol style="list-style-type:upper-roman">
	<li>
	<p>It is useful in creating self-relocating code</p>
	</li>
	<li>
	<p>If it is included in an Instruction Set Architecture, then an additional ALU is required for effective address calculation</p>
	</li>
	<li>
	<p>The amount of increment depends on the size of the data item accessed</p>
	</li>
</ol>

<ol style="list-style-type:upper-alpha">
	<li>I only</li>
	<li>II only</li>
	<li>III only</li>
	<li>II and III only</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q24</span> - <p>Which of the following must be true for the RFE (Return From Exception) instruction on a general purpose processor?</p>

<ol style="list-style-type:upper-roman">
	<li>
	<p>It must be a trap instruction</p>
	</li>
	<li>
	<p>It must be a privileged instruction</p>
	</li>
	<li>
	<p>An exception cannot be allowed to occur during execution of an RFE instruction</p>
	</li>
</ol>

<ol style="list-style-type:upper-alpha">
	<li>I only</li>
	<li>II only</li>
	<li>I and II only</li>
	<li>I, II and III only</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q25</span> - <p>For inclusion to hold between two cache levels L_1 and L_2 in a multi-level cache hierarchy, which of the following are necessary?</p>

<ol style="list-style-type:upper-roman">
	<li>
	<p>L_1 must be write-through cache</p>
	</li>
	<li>
	<p>L_2 must be a write-through cache</p>
	</li>
	<li>
	<p>The associativity of L_2 must be greater than that of L_1</p>
	</li>
	<li>
	<p>The L_2 cache must be at least as large as the L_1 cache</p>
	</li>
</ol>

<ol style="list-style-type:upper-alpha">
	<li>IV only</li>
	<li>I and IV only</li>
	<li>I, II and IV only</li>
	<li>I, II, III and IV</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q26</span> - <p>Which of the following are NOT true in a pipelined processor?</p>

<ol style="list-style-type:upper-roman">
	<li>Bypassing can handle all RAW hazards</li>
	<li>Register renaming can eliminate all register carried WAR hazards</li>
	<li>Control hazard penalties can be eliminated by dynamic branch prediction</li>
</ol>

<ol style="list-style-type:upper-alpha">
	<li>I and II only</li>
	<li>I and III only</li>
	<li>II and III only   nbsp;</li>
	<li>I, II and III</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q27</span> - <p>The use of multiple register windows with overlap causes a reduction in the number of memory accesses for:</p>

<ol style="list-style-type:upper-roman">
	<li>
	<p>Function locals and parameters</p>
	</li>
	<li>
	<p>Register saves and restores</p>
	</li>
	<li>
	<p>Instruction fetches</p>
	</li>
</ol>

<ol style="list-style-type:upper-alpha">
	<li>I only</li>
	<li>II only</li>
	<li>III only</li>
	<li>I, II and III</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q28</span> - <p>In an instruction execution pipeline, the earliest that the data TLB (Translation Lookaside Buffer) can be accessed is:</p>

<ol style="list-style-type:upper-alpha">
	<li>
	<p>before effective address calculation has started</p>
	</li>
	<li>
	<p>during effective address calculation</p>
	</li>
	<li>
	<p>after effective address calculation has completed</p>
	</li>
	<li>
	<p>after data cache lookup has completed</p>
	</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q29</span> - <p>Consider a machine with a 2-way set associative data cache of size 64Kbytes and block size 16bytes. The cache is managed using 32 bit virtual addresses and the page size is 4Kbytes. A program to be run on this machine begins as follows:</p>

<pre class="prettyprint lang-c_cpp">
double ARR[1024][1024];
int i, j;
/*Initialize array ARR to 0.0 */
for(i = 0; i    lt; 1024; i++)
    for(j = 0; j    lt; 1024; j++)
        ARR[i][j] = 0.0;</pre>

<p>The size of double is 8Bytes. Array ARR is located in memory starting at the beginning of virtual page  and stored in row major order. The cache is initially empty and no pre-fetching is done. The only data memory references made by the program are those to array ARR.</p>

<p>The total size of the tags in the cache directory is:</p>

<ol style="list-style-type:upper-alpha">
	<li>32Kbits</li>
	<li>34Kbits</li>
	<li>64Kbits</li>
	<li>68Kbits</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q30</span> - 
<p>Delayed branching can help in the handling of control hazards</p>

<p>For all delayed conditional branch instructions, irrespective of whether the condition evaluates to true or false,</p>

<ol style="list-style-type:upper-alpha"><li>
	<p>The instruction following the conditional branch instruction in memory is executed</p>
	</li>
	<li>
	<p>The first instruction in the fall through path is executed</p>
	</li>
	<li>
	<p>The first instruction in the taken path is executed</p>
	</li>
	<li>
	<p>The branch takes longer to execute than any other instruction</p>
	</li>
</ol>
<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q31</span> - In an 11-bit computer instruction format, the size of address field is 4-bits. The computer uses expanding OP code technique and has 5 two-address instructions and 32 one-address instructions. The number of zero-address instructions it can support is ________<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q32</span> - The access times of the main memory and the Cache memory, in a computer system, are 500 n sec and 50 nsec, respectively. It is estimated that 80% of the main memory request are for read the rest for write. The hit ratio for the read access only is 0.9 and a write-through policy (where both main and cache memories are updated simultaneously) is used. Determine the average time of the main memory (in ns).<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q33</span> - <p>The most appropriate matching for the following pairs
    [       nbsp;X: Indirect addressing                     amp; 1: Loops;     nbsp; Y: Immediate addressing                  amp; 2: Pointers;                             nbsp; nbsp;Z: Auto decrement addressing                 amp; 3: Constants;                             nbsp; ]
 is</p>

<ol style="list-style-type:upper-alpha">
	<li>X - 3,   nbsp; Y - 2,   nbsp; Z - 1</li>
	<li>X - 1,   nbsp; Y - 3,   nbsp; Z - 2</li>
	<li>X - 2,   nbsp; Y - 3,   nbsp; Z - 1</li>
	<li>X - 3,   nbsp; Y - 1,   nbsp; Z - 2</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q34</span> - <p>Which is the most appropriate match for the items in the first column with the items in the second column:
    [                             X.        amp;Indirect Addressing                           amp;                        nbsp;I.       amp;Array implementation                          nbsp;;                        <br>
    Y.         amp;Indexed Addressing                           amp;                       nbsp;II.   amp;Writing relocatable code                          nbsp;                          nbsp;;                                                  nbsp;<br>
    Z.   amp;Base Register Addressing                          nbsp;                          nbsp;                      amp; III. amp;Passing array as parameter;                                                         nbsp; ]
</p>

<ol style="list-style-type:upper-alpha">
	<li>(X, III), (Y, I), (Z, II)</li>
	<li>(X, II), (Y, III), (Z, I)</li>
	<li>(X, III), (Y, II), (Z, I)</li>
	<li>(X, I), (Y, III), (Z, II)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q35</span> - <p>Consider the following data path of a simple non-pipelined CPU. The registers A, B, A_1,A_2, , the  and the  are 8-bit wide.  and  are 16-bit registers. The  is of size 8 × (2:1) and the  is of size 8 × (1:2). Each memory operation takes 2  clock cycles and uses  (Memory Address Register) and  (Memory Date Register).  can be decremented locally.</p>

<p><img src="https://gateoverflow.in/?qa=blob&qa_blobid=6301981403617845683"></p>

<p>The  instruction "<code>push r</code>" where, r = A or B has the specification</p>

<ul>
	<li>M[SP] ← r</li>
	<li>SP ← SP - 1</li>
</ul>

<p>How many  clock cycles are required to execute the "<code>push r</code>" instruction?</p>

<ol style="list-style-type:upper-alpha">
	<li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q36</span> - <p>Consider the following data path of a simple non-pipelined CPU. The registers A, B, A_1,A_2, , the  and the  are 8-bit wide.  and  are 16-bit registers. The  is of size 8 × (2:1) and the  is of size 8 × (1:2). Each memory operation takes 2  clock cycles and uses  (Memory Address Register) and  (Memory Date Register).  can be decremented locally.</p>

<p><img src="https://gateoverflow.in/?qa=blob&qa_blobid=6301981403617845683"></p>

<p>The  instruction "<code>push r</code>" where, r = A or B has the specification</p>

<ul>
	<li>M[SP] ← r</li>
	<li>SP ← SP - 1</li>
</ul>

<p>How many  clock cycles are required to execute the "<code>push r</code>" instruction?</p>

<ol style="list-style-type:upper-alpha">
	<li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q37</span> - <p>In an enhancement of a design of a CPU, the speed of a floating point unit   nbsp;has been increased by 20

<ol style="list-style-type:upper-alpha">
	<li>1.155</li>
	<li>1.185</li>
	<li>1.255</li>
	<li>1.285</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q38</span> - <p>A device employing INTR line for device interrupt puts the CALL instruction on the data bus while:</p>

<ol style="list-style-type:upper-alpha">
	<li>INTA is active</li>
	<li>HOLD is active</li>
	<li>READY is inactive</li>
	<li>None of the above</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q39</span> - <p>Horizontal microprogramming:</p>

<ol style="list-style-type:upper-alpha">
	<li>does not require use of signal decoders</li>
	<li>results in larger sized microinstructions than vertical    nbsp;microprogramming</li>
	<li>uses one bit for each control signal</li>
	<li>all of the above</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q40</span> - <p>Consider the following assembly language program for a hypothetical processor A, B, and C are 8-bit registers. The meanings of various instructions are shown as comments.<br>

    [                                                               nbsp;                                                      amp; MOV B, #0                                                                amp;                                                              amp; ;                                                          amp; B ← 0;                                                      amp; MOV C, #8                                                                amp;                                                              amp; ;                                                          amp; C ← 8;                                                             <br>
    Z:                                                      amp; CMP C, #0                                                                amp;                                                               amp;;                                               amp; compare C with 0;                                                           nbsp;<br>                                                           amp; JZ X                                                                amp;                                                              amp; ;                                  amp; jump to X if zero flag is set                                                               nbsp;;                                                                <br>                                                      amp; SUB C, #1                                                                amp;                                                              amp; ;                                                         amp; C  C-1                                                               nbsp;;                                                           nbsp;<br>                                                      amp; RRC A, #1                                                                amp;                                                              amp; ;                 amp; right rotate A through carry by one bit. Thus:                                                               nbsp;;                                                               nbsp;                                                                amp;                                                                amp;                                                              amp; ; amp; If the initial values of A and the carry flag are a_7… a_0 and                                                               nbsp;;                                                           nbsp;<br>                                                                amp;                                                                amp;                                                              amp; ;     amp; c_0 respectively, their values after the execution of this                                                               nbsp;;                                                           nbsp;<br>                                                                amp;                                                                amp;                                                              amp; ;          amp; instruction will be c_0a_7… a_1 and a_0 respectively.                                                               nbsp;;                                                           nbsp;<br>                                                           amp; JC Y                                                                amp;                                                              amp; ;                                 amp; jump to Y if carry flag is set                                                               nbsp;;                                                                <br>                                                          amp; JMP Z                                                                amp;                                                              amp; ;                                                      amp; jump to Z                                                               nbsp;;                                                             <br>
    Y:                                                      amp; ADD B, #1                                                                amp;                                                              amp; ;                                                         amp; B  B+1                                                               nbsp;;                                                           nbsp;<br>                                                          amp; JMP Z                                                                amp;                                                              amp; ;                                                      amp; jump to Z                                                               nbsp;;                                                        nbsp;<br>
    X:                                                                amp;                                                                amp;                                                              amp; ;                                                                amp;                                                               nbsp;;                                                                     ]
<br>
If the initial value of register A is A0 the value of register B after the program execution will be</p>

<ol style="list-style-type:upper-alpha">
	<li>the number of 0 bits in A_0</li>
	<li>the number of 1 bits in A_0</li>
	<li>A_0</li>
	<li>8</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q41</span> - <p>Consider the following program segment for a hypothetical CPU having three user registers R_1, R_2 and R_3. 
    [            Instruction                  nbsp;                   amp; nbsp;Operation   nbsp;  amp; Instruction size;                   amp;        amp; (in words);           MOV R_1,5000               amp; R_1                 nbsp;←     nbsp; Memory[5000]                 amp; 2;            MOV R2,(R1)                amp; R2                 nbsp;←    nbsp; Memory[(R_1)]                 amp; 1;     ADD   nbsp;R_2,R_3                amp; R2                 nbsp;←        nbsp; R_2 + R_3                 amp; 1;    MOV   nbsp;6000,R_2      amp; Memory[6000]                 nbsp;←              nbsp; R_2                 amp; 2;                   HALT     amp; Machine Halts                 amp; 1;                        ]
Consider that the memory is byte addressable with size 32 bits, and the program has been loaded starting from memory location 1000 (decimal). If an interrupt occurs while the CPU has been halted after executing the HALT instruction, the return address (in decimal) saved in the stack will be</p>

<ol style="list-style-type:upper-alpha">
	<li>1007</li>
	<li>1020</li>
	<li>1024</li>
	<li>1028</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q42</span> - <p>Consider a small two-way set-associative cache memory, consisting of four blocks. For choosing the block to be replaced, use the least recently used (LRU) scheme. The number of cache misses for the following sequence of block addresses is:</p>

<p>8, 12, 0, 12, 8.</p>

<ol style="list-style-type:upper-alpha">
	<li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q43</span> - <p>The microinstructions stored in the control memory of a processor have a width of 26 bits. Each microinstruction is divided into three fields: a micro-operation field of 13 bits, a next address field (X), and a MUX select field (Y). There are 8 status bits in the input of the MUX.</p>

<p><img src="https://gateoverflow.in/?qa=blob&qa_blobid=17933537052434479943"></p>

<p>How many bits are there in the X and Y fields, and what is the size of the control memory in number of words?</p>

<ol style="list-style-type:upper-alpha">
	<li>10, 3, 1024</li>
	<li>8, 5, 256</li>
	<li>5, 8, 2048</li>
	<li>10, 3, 512</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q44</span> - <p>A hard disk with a transfer rate of 10   nbsp;Mbytes/second is constantly transferring data to memory using DMA. The processor runs at 600 MHz, and takes 300 and 900 clock cycles to initiate and complete DMA transfer respectively. If the size of the transfer is 20 Kbytes, what is the percentage of processor time consumed for the transfer operation?</p>

<ol style="list-style-type:upper-alpha">
	<li>5.0 %</li>
	<li>1.0%</li>
	<li>0.5%</li>
	<li>0.1%</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q45</span> - <p>A 4-stage pipeline has the stage delays as 150, 120, 160 and 140 nanoseconds, respectively. Registers that are used between the stages have a delay of 5 nanoseconds each. Assuming constant clocking rate, the total time taken to process 1000 data items on this pipeline will be:</p>

<ol style="list-style-type:upper-alpha">
<li>
<p>120.4 microseconds</p>
</li>
<li>
<p>160.5 microseconds</p>
</li>
<li>
<p>165.5 microseconds</p>
</li>
<li>
<p>590.0 microseconds</p>
</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q46</span> - <p>Consider a 4-way set associative cache consisting of 128 lines with a line size of 64 words. The <strong>CPU </strong>generates a 20-bit address of a word in main memory. The number of bits in the TAG, LINE and WORD fields are respectively:</p>

<ol style="list-style-type:upper-alpha">
	<li>9, 6, 5</li>
	<li>7, 7, 6</li>
	<li>7, 5, 8</li>
	<li>9, 5, 6</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q47</span> - <p>In a simplified computer the instructions are:</p>

<p>
    [                                                     OP R _j , R _i amp; Perform R _j  OP  R _i  and store the result in register R _j;                                                     <br>
    OP m,R _i   amp; Perform  val OP R _i  and store the result in register R _i                                                              nbsp;;                                                               <br>             amp; val  denotes the content of the memory location m;                                                    <br>
    MOV m,R _i      amp; Moves the content of memory location m  to register R _i;                                                    <br>
    MOV R _i,m       amp; Moves the content of register R _i to memory location m;                                                                    ]
</p>

<p>The computer has only two registers, and OP is either ADD or SUB. Consider the following basic block:</p>

<ul>
	<li>t_1  =   a+b</li>
	<li>t_2  =   c+d</li>
	<li>t_3  =   e-t_2</li>
	<li>t_4  =   t_1 – t_3</li>
</ul>

<p>Assume that all operands are initially in memory. The final value of the computation should be in memory. What is the minimum number of MOV instructions in the code generated for this basic block?</p>

<ol style="list-style-type:upper-alpha">
	<li>2</li>
	<li>3</li>
	<li>5</li>
	<li>6</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q48</span> - <p>Consider the following program segment. Here R1, R2 and R3 are the general purpose registers.<br>

    [                                amp; Instruction          amp; Operation   amp; Instruction Size;                                            amp;                    amp;     amp; (no. of words);                              amp; MOV R1,(3000)         amp; R1←M[3000]                  amp; 2;                   LOOP:        amp; MOV R2,(R3)           amp; R2←M[R3]                  amp; 1;                                  amp; ADD R2,R1         amp; R2←R1 + R2                  amp; 1;                                amp; MOV (R3),R2           amp; M[R3]←R2                  amp; 1;                                     amp; INC R3          amp; R3←R3 + 1                  amp; 1;                                     amp; DEC R1          amp; R1←R1 – 1                  amp; 1;                                   amp; BNZ LOOP amp; Branch on not zero                  amp; 2;                                       amp; HALT               amp; Stop                  amp; 1;                         ]
</p>

<p>Assume that the content of memory location 3000 is 10 and the content of the register R3 is 2000. The content of each of the memory locations from 2000 to 2010 is 100. The program is loaded from the memory location 1000. All the numbers are in decimal.</p>

<p>Assume that the memory is word addressable. The number of memory references for accessing the data in executing the program completely is</p>

<ol style="list-style-type:upper-alpha">
<li>10</li>
<li>11</li>
<li>20</li>
<li>21</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q49</span> - <p>Consider a machine with a byte addressable main memory of 2^16   nbsp;bytes. Assume that a direct mapped data cache consisting of 32 lines of 64 bytes   nbsp;each is used in the system. A 50   nbsp;× 50 two-dimensional array of bytes is stored in the main memory starting from memory location 1100H. Assume that the data cache is initially empty. The complete array is accessed twice. Assume that the contents of the data cache do not change in between the two accesses.   nbsp;</p>

<p>How many data misses will occur in total?</p>

<ol style="list-style-type:upper-alpha">
	<li>48</li>
	<li>50</li>
	<li>56</li>
	<li>59</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q50</span> - <p>Consider a 4 stage pipeline processor. The number of cycles needed by the four instructions I1, I2, I3, I4 in stages S1, S2, S3, S4 is shown below:</p>

<p>
    [         amp; S1  amp;S2 amp; S3    amp; nbsp;S4;      I1  amp; 2    amp;  nbsp;1   nbsp;   nbsp;  amp; 1  amp; 1;      I2  amp; 1   nbsp;  amp; 3  amp; 2   nbsp;   nbsp;  amp; 2;           nbsp; nbsp;I3  amp; 2    amp;  nbsp;1   nbsp;   nbsp;  amp; 1  amp; 3;      I4  amp; 1   nbsp;  amp; 2  amp; 2   nbsp;   nbsp;  amp; 2;           nbsp; ]
</p>

<p>   nbsp;</p>

<p>What is the number of cycles needed to execute the following loop?</p>

<p>For (i=1 to 2) I1; I2; I3; I4;</p>

<ol style="list-style-type:upper-alpha">
	<li>16</li>
	<li>23</li>
	<li>28</li>
	<li>30</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q51</span> - <p>Consider a 4-way set associative cache (initially empty) with total 16 cache blocks. The main memory consists of 256 blocks and the request for memory blocks are in the following order:</p>

<p>0, 255, 1, 4, 3, 8, 133, 159, 216, 129, 63, 8, 48, 32, 73, 92, 155.</p>

<p>Which one of the following memory block will NOT be in cache if LRU replacement policy is used?</p>

<ol style="list-style-type:upper-alpha">
	<li>3</li>
	<li>8</li>
	<li>129</li>
	<li>216</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q52</span> - <p>Consider a three word machine instruction</p>

<p>ADD A[R_0], @B</p>

<p>The first operand (destination) “A[R_0]”   nbsp;uses indexed addressing mode with R_0 as the index register. The second operand (source) “@B”   nbsp;uses indirect addressing mode. A and B are memory addresses residing at the second and third words, respectively. The first word of the instruction specifies the opcode, the index register designation and the source and destination addressing modes. During execution of ADD instruction, the two operands are added and stored in the destination (first operand).</p>

<p>The number of memory cycles needed during the execution cycle of the instruction is:</p>

<ol style="list-style-type:upper-alpha">
	<li>3</li>
	<li>4</li>
	<li>5</li>
	<li>6</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q53</span> - <p>A 5 stage pipelined CPU has the following sequence of stages:</p>

<ul>
	<li>IF – instruction fetch from instruction memory</li>
	<li>RD – Instruction decode and register read</li>
	<li>EX – Execute: ALU operation for data and address computation</li>
	<li>MA – Data memory access – for write access, the register read at RD state is used.</li>
	<li>WB – Register write back</li>
</ul>

<p>Consider the following sequence of instructions:</p>

<ul>
	<li>I_1: L R0, loc 1; R0 ⇐ M[loc1]</li>
	<li>I_2: A R0, R0; R0 ⇐ R0 +R0</li>
	<li>I_3: S R2, R0; R2 ⇐ R2-R0</li>
</ul>

<p>Let each stage take one clock cycle.</p>

<p>What is the number of clock cycles taken to complete the above sequence of instructions starting from the fetch of I_1?</p>

<ol style="list-style-type:upper-alpha">
	<li>8</li>
	<li>10</li>
	<li>12</li>
	<li>15</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q54</span> - <p>A device with data transfer rate 10 KB/sec is connected to a CPU. Data is transferred byte-wise. Let the interrupt overhead be 4μsec. The byte transfer time between the device interface   nbsp;register and CPU or memory is negligible. What is the minimum performance gain of operating the device under interrupt mode over operating it under program-controlled mode?</p>

<ol style="list-style-type:upper-alpha">
	<li>15</li>
	<li>25</li>
	<li>35</li>
	<li>45</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q55</span> - <p>Consider a disk drive with the following specifications:</p>

<p>16 surfaces, 512 tracks/surface, 512 sectors/track, 1 KB/sector, rotation speed 3000 rpm. The disk is operated in cycle stealing mode whereby whenever one 4 byte word is ready it is sent to memory; similarly, for writing, the disk interface reads a 4 byte word from the memory in each DMA cycle. Memory cycle time is 40   nbsp;nsec. The maximum percentage of time that the CPU gets blocked during DMA operation is:</p>

<ol style="list-style-type:upper-alpha">
	<li>10</li>
	<li>25</li>
	<li>40</li>
	<li>50</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q56</span> - <p>Consider the following data path of a CPU.</p>

<p><img src="https://gateoverflow.in/?qa=blob&qa_blobid=8051408258367583932"></p>

<p>The ALU, the bus and all the registers in the data path are of identical size. All operations including incrementation of the PC and the GPRs are to be carried out in the ALU. Two clock cycles are needed for memory read operation – the first one for loading address in the MAR and the next one for loading data from the memory bus into the MDR.</p>

<p>The instruction “add R0, R1” has the register transfer interpretation R0⇐   nbsp;R0 + R1. The minimum number of clock cycles needed for execution cycle of this instruction is:</p>

<ol style="list-style-type:upper-alpha">
	<li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q57</span> - <p>In a k-way set associative cache, the cache is divided into v sets, each of which consists of k lines. The lines of a set are placed in sequence one after another. The lines in set s are sequenced before the lines in set (s+1). The main memory blocks are numbered 0 onwards. The main memory block numbered j must be mapped to any one of the cache lines from</p>

<ol style="list-style-type: upper-alpha;">
	<li>(j mod v) * k  to  (j  mod  v) * k + (k-1)</li>
	<li>(j  mod  v)  to  (j  mod  v) + (k-1)</li>
	<li>(j  mod  k)  to  (j  mod  k) + (v-1)</li>
	<li>(j  mod  k) * v  to  (j  mod  k) * v + (v-1)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q58</span> - <p>The main memory of a computer has 2 cm blocks while the cache has 2 c blocks. If the cache uses the set associative mapping scheme with 2 blocks per set, then block k of the main memory maps to the set:</p>

<ol style="list-style-type:upper-alpha">
	<li>(k   nbsp;   nbsp;m) of the cache</li>
	<li>(k   nbsp; c) of the cache</li>
	<li>(k   nbsp;   nbsp;2c) of the cache</li>
	<li>(k   nbsp;   nbsp;2  cm) of the cache</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q59</span> - 
<p>Arrange the following configuration for CPU in decreasing order of operating speeds:</p>

<p>Hard wired control, Vertical microprogramming, Horizontal microprogramming.</p>



<ol style="list-style-type:upper-alpha"><li>
	<p>Hard wired control, Vertical microprogramming, Horizontal microprogramming.</p>
	</li>
	<li>
	<p>Hard wired control, Horizontal microprogramming, Vertical microprogramming.</p>
	</li>
	<li>
	<p>Horizontal microprogramming, Vertical microprogramming, Hard wired control.</p>
	</li>
	<li>
	<p>Vertical microprogramming, Horizontal microprogramming, Hard wired control.</p>
	</li>
</ol>
<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q60</span> - <p>Consider the following sequence of micro-operations.</p>

<pre class="prettyprint lang-c_cpp">
MBR ← PC  
MAR ← X  PC ← Y  
Memory ← MBR</pre>

<p>Which one of the following is a possible operation performed by this sequence?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>Instruction fetch</li>
	<li>Operand fetch</li>
	<li>Conditional branch</li>
	<li>Initiation of interrupt service</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q61</span> - <p>Which of the following is true?</p>

<ol style="list-style-type:upper-alpha">
	<li>
	<p>Unless enabled, a CPU will not be able to process interrupts.</p>
	</li>
	<li>
	<p>Loop instructions cannot be interrupted till they complete.</p>
	</li>
	<li>
	<p>A processor checks for interrupts before executing a new instruction.</p>
	</li>
	<li>
	<p>Only level triggered interrupts are possible on microprocessors.</p>
	</li>
</ol>

<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let data={'name': 'CO & Architecture - Previous GATE 1', 'duration': '180', 'total_qs': '61', 'total_qs_one': 20, 'total_qs_two': 41, 'apti_num_qs': 0, 'technical_num_qs': 61, 'apti_marks': 0, 'technical_marks': 102, 'total_marks': 102, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 61, 'marks': 102, 'question': [{'contents': '', 'post_id': '52', 'text': '<p>Register renaming is done in pipelined processors:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>as an alternative to register allocation at compile time</li>\n\t<li>for efficient access to function parameters and local variables</li>\n\t<li>to handle certain kinds of hazards</li>\n\t<li>as part of address translation</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2012,co-and-architecture,pipelining,easy,isro2016', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '631', 'text': '<p>Comparing the time T1 taken for a single instruction on a pipelined CPU with time T2 taken on a non-pipelined but identical CPU, we can say that</p>\n\n<ol style="list-style-type: upper-alpha;">\n\t<li>T1&nbsp;≤ T2</li>\n\t<li>T1&nbsp;≥ T2</li>\n\t<li>T1&nbsp;&lt; T2</li>\n\t<li>T1 and T2 plus the time taken for one instruction fetch cycle</li>\n</ol>\n\n', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2000,pipelining,co-and-architecture,easy', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '700', 'text': '<p>More than one word are put in one cache block to:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>exploit the temporal locality of reference in a program</li>\n\t<li>exploit the spatial locality of reference in a program</li>\n\t<li>reduce the miss penalty</li>\n\t<li>none of the above</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2001,co-and-architecture,easy,cache-memory,isro2008', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '817', 'text': '<p>Which of the following is not a form of memory</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>instruction cache</li>\n\t<li>instruction register</li>\n\t<li>instruction opcode</li>\n\t<li>translation look-a-side buffer</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2002,co-and-architecture,easy,instruction-execution', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '829', 'text': '<p>In the absolute addressing mode:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>the operand is inside the instruction</li>\n\t<li>the address of the operand in inside the instruction</li>\n\t<li>the register containing the address of the operand is specified inside the instruction</li>\n\t<li>the location of the operand is implicit</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2002,co-and-architecture,addressing-modes,easy', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '836', 'text': '<p>The performance of a pipelined processor suffers if:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>the pipeline stages have different delays</li>\n\t<li>consecutive instructions are dependent on each other</li>\n\t<li>the pipeline stages share hardware resources</li>\n\t<li>All of the above</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2002,co-and-architecture,pipelining,easy,isro2008', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '888', 'text': '<p>A CPU has $24$-$bit$ instructions. A program starts at address $300$ (in decimal). Which one of the following is a legal program counter (all values in decimal)?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$400$</li>\n\t<li>$500$</li>\n\t<li>$600$</li>\n\t<li>$700$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2006,co-and-architecture,machine-instruction,easy,isro2009', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '901', 'text': '<p>For a pipelined CPU with a single ALU, consider the following situations</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>\n\t<p>The ${j+1}^{st}$ instruction uses the result of the $j^{th}$ instruction as an operand</p>\n\t</li>\n\t<li>\n\t<p>The execution of a conditional jump instruction</p>\n\t</li>\n\t<li>\n\t<p>The $j^{th}$ and ${j+1}^{st}$ instructions require the ALU at the same time.</p>\n\t</li>\n</ol>\n\n<p>Which of the above can cause a hazard</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>I and II only</li>\n\t<li>II and III only</li>\n\t<li>III only</li>\n\t<li>All the three</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2003,co-and-architecture,pipelining,normal,isrodec2017', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1017', 'text': '<p>Which of the following addressing modes are suitable for program relocation at run time?</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>\n\t<p>Absolute addressing</p>\n\t</li>\n\t<li>\n\t<p>Based addressing</p>\n\t</li>\n\t<li>\n\t<p>Relative addressing</p>\n\t</li>\n\t<li>\n\t<p>Indirect addressing</p>\n\t</li>\n</ol>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>I&nbsp;and IV</li>\n\t<li>I&nbsp;and II</li>\n\t<li>II&nbsp;and III</li>\n\t<li>I, II&nbsp;and IV</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2004,co-and-architecture,addressing-modes,easy', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1235', 'text': '<p>Consider a pipelined processor with the following four stages:</p>\n\n<ul>\n<li>IF: Instruction Fetch</li>\n<li>ID: Instruction Decode and Operand Fetch</li>\n<li>EX: Execute</li>\n<li>WB: Write Back</li>\n</ul>\n\n<p>The IF, ID and WB stages take one clock cycle each to complete the operation. The number of clock cycles for the EX stage depends on the instruction. The ADD and SUB instructions need $1$ clock cycle and the MUL instruction needs $3$ clock cycles in the EX stage. Operand forwarding is used in the pipelined processor. What is the number of clock cycles taken to complete the following sequence of instructions?<br>\n$$\\begin{array}{ll}&nbsp;\\textbf{ADD} &amp; \\text{R2, R1, R0} &amp;&amp;&amp; \\text{R2 $\\leftarrow$ R1$+$R0} \\\\&nbsp; \\textbf{MUL} &amp; \\text{R4, R3, R2} &amp;&amp;&amp; \\text{R4 $\\leftarrow$ R3$*$R2} \\\\&nbsp; &nbsp;\\textbf{SUB} &amp; \\text{R6, R5, R4} &amp;&amp;&amp; \\text{R6 $\\leftarrow$ R5$-$R4} \\\\&nbsp; &nbsp;\\end{array}$$</p>\n\n<ol style="list-style-type:upper-alpha">\n<li>$7$</li>\n<li>$8$</li>\n<li>$10$</li>\n<li>$14$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2007,co-and-architecture,pipelining,normal,isro2009', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1300', 'text': '<p>A CPU generally handles an interrupt by executing an interrupt service routine:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>\n\t<p>As soon as an interrupt is raised.</p>\n\t</li>\n\t<li>\n\t<p>By checking the interrupt register at the end of fetch cycle.</p>\n\t</li>\n\t<li>\n\t<p>By checking the interrupt register after finishing the execution of the current instruction.</p>\n\t</li>\n\t<li>\n\t<p>By checking the interrupt register at fixed time intervals.</p>\n\t</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2009,co-and-architecture,interrupts,normal,ugcnetcse-june2012-paper3', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1389', 'text': '<p>Match each of the high level language statements given on the left hand side with the most natural addressing mode from those listed on the right hand side.$$\\begin{array}{clcl}&nbsp;\\text{(1)} &amp;\\text{$A[I] = B[J]$} &amp; \\qquad\\text{(a)} &amp;\\text{Indirect addressing} \\\\&nbsp;<br>\n\\text{(2)} &amp;\\text{while $(^*A\\text{++});$} &amp; \\qquad\\text{(b)} &amp; \\text{Indexed addressing} \\\\&nbsp; &nbsp;<br>\n\\text{(3)} &amp; \\text{int temp $= ^*x$} &amp; \\qquad\\text{(c)} &amp;\\text{Auto increment}&nbsp; \\\\&nbsp;\\end{array}$$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$(1, c), (2, b), (3, a)$</li>\n\t<li>$(1, c), (2, c), (3, b)$</li>\n\t<li>$(1, b), (2, c), (3, a)$</li>\n\t<li>$(1, a), (2, b), (3, c)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2005,co-and-architecture,addressing-modes,match-the-following,easy', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1390', 'text': '<p>Consider a direct mapped cache of size $32$ $KB$ with block size $32$ $bytes$. The $CPU$ generates $32$ $bit$ addresses. The number of bits needed for cache indexing and the number of tag bits are respectively,</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$10, 17$</li>\n\t<li>$10, 22$</li>\n\t<li>$15, 17$</li>\n\t<li>$5, 17$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2005,co-and-architecture,cache-memory,easy', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1656', 'text': '\n<p>Which of the following addressing modes permits relocation without any change whatsoever in the code?</p>\n\n<ol style="list-style-type:upper-alpha"><li>\n\t<p>Indirect addressing</p>\n\t</li>\n\t<li>\n\t<p>Indexed addressing</p>\n\t</li>\n\t<li>\n\t<p>Base register addressing</p>\n\t</li>\n\t<li>\n\t<p>PC relative addressing</p>\n\t</li>\n</ol>\n', 'type': 'Multiple Choice', 'answer': 'd', 'award': 1, 'penalty': '0.3333', 'tags': 'gate1998,co-and-architecture,addressing-modes,easy', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1767', 'text': 'A machine has a $32\\text{-bit}$ architecture, with $1\\text{-word}$ long instructions. It has $64$ registers, each of which is $32$ bits long. It needs to support $45$ instructions, which have an immediate operand in addition to two register operands. Assuming that the immediate operand is an unsigned integer, the maximum value of the immediate operand is ____________', 'type': 'Numerical', 'answer': '16383', 'award': 1, 'penalty': '0.0000', 'tags': 'gatecse-2014-set1,co-and-architecture,machine-instruction,instruction-format,numerical-answers,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1963', 'text': 'A $4$-way set-associative cache memory unit with a capacity of $16$ KB is built using a block size of $8$ words. The word length is $32$ bits. The size of the physical address space is $4$ GB. The number of bits for the TAG field is ____', 'type': 'Numerical', 'answer': '20', 'award': 1, 'penalty': '0.0000', 'tags': 'gatecse-2014-set2,co-and-architecture,cache-memory,numerical-answers,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '2043', 'text': '<p>Consider the following processors (ns stands for nanoseconds). Assume that the pipeline registers have zero latency.&nbsp;</p>\n\n<ul>\n\t<li>$\\text{P1:}$ Four-stage pipeline with stage latencies $\\text{1&nbsp;ns, 2&nbsp;ns, 2&nbsp;ns, 1&nbsp;ns}$.&nbsp;</li>\n\t<li>$\\text{P2:}$ Four-stage pipeline with stage latencies $\\text{1&nbsp;ns, 1.5&nbsp;ns, 1.5&nbsp;ns, 1.5&nbsp;ns}$.&nbsp;</li>\n\t<li>$\\text{P3:}$ Five-stage pipeline with stage latencies $\\text{0.5&nbsp;ns, 1&nbsp;ns, 1&nbsp;ns, 0.6&nbsp;ns, 1 ns}$.&nbsp;</li>\n\t<li>$\\text{P4:}$ Five-stage pipeline with stage latencies $\\text{0.5&nbsp;ns, 0.5&nbsp;ns, 1&nbsp;ns, 1 ns, 1.1&nbsp;ns}$.&nbsp;</li>\n</ul>\n\n<p>Which processor has the highest peak clock frequency?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{P1}$</li>\n\t<li>$\\text{P2}$</li>\n\t<li>$\\text{P3}$</li>\n\t<li>$\\text{P4}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2014-set3,co-and-architecture,pipelining,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '2123', 'text': '<p>Consider a hypothetical processor with an instruction of type $\\text{LW &nbsp;R1, 20(R2)}$, which during execution reads a $32\\text{-bit}$ word from memory and stores it in a $32\\text{-bit}$ register $\\text{R1}$. The effective address of the memory location is obtained by the addition of a constant $20$ and the contents of register $\\text{R2}$. Which of the following best reflects the addressing mode implemented by this instruction for the operand in memory?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Immediate addressing</li>\n\t<li>Register addressing</li>\n\t<li>Register Indirect Scaled Addressing</li>\n\t<li>Base Indexed Addressing</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 1, 'penalty': '0.3333', 'tags': 'gatecse-2011,co-and-architecture,addressing-modes,easy', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '2720', 'text': '<p>Relative mode of addressing is most relevant to writing:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>\n\t<p>Co – routines</p>\n\t</li>\n\t<li>\n\t<p>Position – independent code</p>\n\t</li>\n\t<li>\n\t<p>Shareable code</p>\n\t</li>\n\t<li>\n\t<p>Interrupt Handlers</p>\n\t</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'gate1996,co-and-architecture,addressing-modes,easy,isro2016', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '2593', 'text': '<p>The principle of locality justifies the use of:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Interrupts</li>\n\t<li>DMA</li>\n\t<li>Polling</li>\n\t<li>Cache Memory</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'D', 'award': 1, 'penalty': '0.3333', 'tags': 'gate1995,co-and-architecture,cache-memory,easy', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '318', 'text': '<p>Consider a system with a two-level paging scheme in which a regular memory access takes $150$ $nanoseconds$, and servicing a page fault takes $8$ $milliseconds$. An average instruction takes $100$ nanoseconds of CPU time, and two memory accesses. The TLB hit ratio is $90$%, and the page fault rate is one in every $10,000$ instructions. What is the effective average instruction execution time?</p>\n\n<ol style="list-style-type:upper-alpha">\n<li>$\\text{645 nanoseconds}$</li>\n<li>$\\text{1050 nanoseconds}$</li>\n<li>$\\text{1215 nanoseconds}$</li>\n<li>$\\text{1230 nanoseconds}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2004,co-and-architecture,virtual-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '330', 'text': '<p>Consider an instruction pipeline with five stages without any branch prediction:</p>\n\n<p>Fetch Instruction&nbsp;(FI), Decode Instruction (DI), Fetch Operand (FO), Execute Instruction (EI) and Write Operand&nbsp;(WO). The stage delays for FI, DI, FO, EI and WO are&nbsp;$\\text{5 ns, 7 ns, 10 ns, 8 ns and 6 ns},$ respectively. There are intermediate storage buffers after each stage and the delay of each buffer is $1\\ \\text{ns}.$ A program consisting of $12$ instructions $\\text{I1, I2, I3,}\\ldots,\\text{ I12}$ is executed in this pipelined processor. Instruction $\\text{I4}$ is the only branch instruction and its branch target is $\\text{I9}.$ If the branch is taken during the execution of this program, the time (in ns) needed to complete the program is</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>&nbsp;$132$&nbsp; &nbsp;</li>\n\t<li>&nbsp;$165$&nbsp;</li>\n\t<li>&nbsp;$176$</li>\n\t<li>&nbsp;$328$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2013,normal,co-and-architecture,pipelining', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '444', 'text': '<p>Which of the following is/are true of the auto-increment addressing mode?</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>\n\t<p>It is useful in creating self-relocating code</p>\n\t</li>\n\t<li>\n\t<p>If it is included in an Instruction Set Architecture, then an additional ALU is required for effective address calculation</p>\n\t</li>\n\t<li>\n\t<p>The amount of increment depends on the size of the data item accessed</p>\n\t</li>\n</ol>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>I only</li>\n\t<li>II only</li>\n\t<li>III only</li>\n\t<li>II and III only</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2008,addressing-modes,co-and-architecture,normal,isro2009', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '445', 'text': '<p>Which of the following must be true for the RFE (Return From Exception) instruction on a general purpose processor?</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>\n\t<p>It must be a trap instruction</p>\n\t</li>\n\t<li>\n\t<p>It must be a privileged instruction</p>\n\t</li>\n\t<li>\n\t<p>An exception cannot be allowed to occur during execution of an RFE instruction</p>\n\t</li>\n</ol>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>I only</li>\n\t<li>II only</li>\n\t<li>I and II only</li>\n\t<li>I, II and III only</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2008,co-and-architecture,machine-instruction,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '446', 'text': '<p>For inclusion to hold between two cache levels $L_1$ and $L_2$ in a multi-level cache hierarchy, which of the following are necessary?</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>\n\t<p>$L_1$ must be write-through cache</p>\n\t</li>\n\t<li>\n\t<p>$L_2$ must be a write-through cache</p>\n\t</li>\n\t<li>\n\t<p>The associativity of $L_2$ must be greater than that of $L_1$</p>\n\t</li>\n\t<li>\n\t<p>The $L_2$ cache must be at least as large as the $L_1$ cache</p>\n\t</li>\n</ol>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>IV only</li>\n\t<li>I and IV only</li>\n\t<li>I, II and IV only</li>\n\t<li>I, II, III and IV</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2008,co-and-architecture,cache-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '447', 'text': '<p>Which of the following are NOT true in a pipelined processor?</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>Bypassing can handle all RAW hazards</li>\n\t<li>Register renaming can eliminate all register carried WAR hazards</li>\n\t<li>Control hazard penalties can be eliminated by dynamic branch prediction</li>\n</ol>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>I and II only</li>\n\t<li>I and III only</li>\n\t<li>II and III only&nbsp;</li>\n\t<li>I, II and III</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2008,pipelining,co-and-architecture,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '448', 'text': '<p>The use of multiple register windows with overlap causes a reduction in the number of memory accesses for:</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>\n\t<p>Function locals and parameters</p>\n\t</li>\n\t<li>\n\t<p>Register saves and restores</p>\n\t</li>\n\t<li>\n\t<p>Instruction fetches</p>\n\t</li>\n</ol>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{I}$ only</li>\n\t<li>$\\text{II}$ only</li>\n\t<li>$\\text{III}$ only</li>\n\t<li>$\\text{I}, \\text{II}$ and $\\text{III}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2008,co-and-architecture,normal,isro2009,runtime-environment', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '449', 'text': '<p>In an instruction execution pipeline, the earliest that the data TLB (Translation Lookaside Buffer) can be accessed is:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>\n\t<p>before effective address calculation has started</p>\n\t</li>\n\t<li>\n\t<p>during effective address calculation</p>\n\t</li>\n\t<li>\n\t<p>after effective address calculation has completed</p>\n\t</li>\n\t<li>\n\t<p>after data cache lookup has completed</p>\n\t</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2008,co-and-architecture,virtual-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '494', 'text': '<p>Consider a machine with a $2$-way set associative data cache of size $64\\text{Kbytes}$ and block size $16\\text{bytes}$. The cache is managed using $32\\;\\text{bit}$ virtual addresses and the page size is $4\\text{Kbytes}$. A program to be run on this machine begins as follows:</p>\n\n<pre class="prettyprint lang-c_cpp">\ndouble ARR[1024][1024];\nint i, j;\n/*Initialize array ARR to 0.0 */\nfor(i = 0; i &lt; 1024; i++)\n    for(j = 0; j &lt; 1024; j++)\n        ARR[i][j] = 0.0;</pre>\n\n<p>The size of double is $8\\text{Bytes}$. Array $\\text{ARR}$ is located in memory starting at the beginning of virtual page $\\textsf{0xFF000}$ and stored in row major order. The cache is initially empty and no pre-fetching is done. The only data memory references made by the program are those to array $\\text{ARR}$.</p>\n\n<p>The total size of the tags in the cache directory is:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$32\\text{Kbits}$</li>\n\t<li>$34\\text{Kbits}$</li>\n\t<li>$64\\text{Kbits}$</li>\n\t<li>$68\\text{Kbits}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2008,co-and-architecture,cache-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '496', 'text': '\n<p>Delayed branching can help in the handling of control hazards</p>\n\n<p>For all delayed conditional branch instructions, irrespective of whether the condition evaluates to true or false,</p>\n\n<ol style="list-style-type:upper-alpha"><li>\n\t<p>The instruction following the conditional branch instruction in memory is executed</p>\n\t</li>\n\t<li>\n\t<p>The first instruction in the fall through path is executed</p>\n\t</li>\n\t<li>\n\t<p>The first instruction in the taken path is executed</p>\n\t</li>\n\t<li>\n\t<p>The branch takes longer to execute than any other instruction</p>\n\t</li>\n</ol>\n', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2008,co-and-architecture,pipelining,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '551', 'text': 'In an $11$-bit computer instruction format, the size of address field is $4$-bits. The computer uses expanding OP code technique and has $5$ two-address instructions and $32$ one-address instructions. The number of zero-address instructions it can support is ________', 'type': 'Numerical', 'answer': '256', 'award': 2, 'penalty': '0.0000', 'tags': 'gate1992,co-and-architecture,machine-instruction,instruction-format,normal,numerical-answers', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '584', 'text': 'The access times of the main memory and the Cache memory, in a computer system, are $500$ n sec and $50$ nsec, respectively. It is estimated that $80\\%$ of the main memory request are for read the rest for write. The hit ratio for the read access only is $0.9$ and a write-through policy (where both main and cache memories are updated simultaneously) is used. Determine the average time of the main memory (in ns).', 'type': 'Numerical', 'answer': '180', 'award': 2, 'penalty': '0.0000', 'tags': 'gate1992,co-and-architecture,cache-memory,normal,numerical-answers', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '633', 'text': '<p>The most appropriate matching for the following pairs$$\\begin{array}{ll}&nbsp;\\text{X: Indirect addressing} &amp; \\text{1: Loops } \\\\&nbsp; \\text{Y: Immediate addressing } &amp; \\text{2: Pointers} \\\\&nbsp; &nbsp;\\text{Z: Auto decrement addressing } &amp; \\text{3: Constants } \\\\&nbsp; \\end{array}$$ is</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$X - 3,&nbsp; Y - 2,&nbsp; Z - 1$</li>\n\t<li>$X - 1,&nbsp; Y - 3,&nbsp; Z - 2$</li>\n\t<li>$X - 2,&nbsp; Y - 3,&nbsp; Z - 1$</li>\n\t<li>$X - 3,&nbsp; Y - 1,&nbsp; Z - 2$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2000,co-and-architecture,easy,addressing-modes,match-the-following', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '727', 'text': '<p>Which is the most appropriate match for the items in the first column with the items in the second column:$$\\begin{array}{|cl|cl|} \\hline \\text{X.} &amp;\\text{Indirect Addressing} &amp; &nbsp;\\text{I.} &amp;\\text{Array implementation}&nbsp;\\\\\\hline<br>\n\\text{Y.} &amp;\\text{Indexed Addressing} &amp;&nbsp;\\text{II.} &amp;\\text{Writing relocatable code}&nbsp;&nbsp;\\\\\\hline&nbsp;<br>\n\\text {Z.} &amp;\\text{Base Register Addressing}&nbsp;&nbsp;&amp; \\text{III.} &amp;\\text{Passing array as parameter}\\\\\\hline&nbsp; \\end{array}$$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>(X, III), (Y, I), (Z, II)</li>\n\t<li>(X, II), (Y, III), (Z, I)</li>\n\t<li>(X, III), (Y, II), (Z, I)</li>\n\t<li>(X, I), (Y, III), (Z, II)</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2001,co-and-architecture,addressing-modes,easy,match-the-following', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '731', 'text': '<p>Consider the following data path of a simple non-pipelined CPU. The registers $A, B$, $A_{1},A_{2}, \\textsf{MDR},$ the $\\textsf{bus}$ and the $\\textsf{ALU}$ are $8$-$bit$ wide. $\\textsf{SP}$ and $\\textsf{MAR}$ are $16$-$bit$ registers. The $\\textsf{MUX}$ is of size $8 \\times (2:1)$ and the $\\textsf{DEMUX}$ is of size $8 \\times (1:2)$. Each memory operation takes $2$ $\\textsf{CPU}$ clock cycles and uses $\\textsf{MAR}$ (Memory Address Register) and $\\textsf{MDR}$ (Memory Date Register). $\\textsf{SP}$ can be decremented locally.</p>\n\n<p><img alt="" height="261" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=6301981403617845683" width="632"></p>\n\n<p>The $\\textsf{CPU}$ instruction "<code>push r</code>" where, $r =$ $A$ or $B$ has the specification</p>\n\n<ul>\n\t<li>$M[SP] ← r $</li>\n\t<li>$SP ← SP - 1$</li>\n</ul>\n\n<p>How many $\\textsf{CPU}$ clock cycles are required to execute the "<code>push r</code>" instruction?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2$</li>\n\t<li>$3$</li>\n\t<li>$4$</li>\n\t<li>$5$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2001,co-and-architecture,data-path,machine-instruction,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '731', 'text': '<p>Consider the following data path of a simple non-pipelined CPU. The registers $A, B$, $A_{1},A_{2}, \\textsf{MDR},$ the $\\textsf{bus}$ and the $\\textsf{ALU}$ are $8$-$bit$ wide. $\\textsf{SP}$ and $\\textsf{MAR}$ are $16$-$bit$ registers. The $\\textsf{MUX}$ is of size $8 \\times (2:1)$ and the $\\textsf{DEMUX}$ is of size $8 \\times (1:2)$. Each memory operation takes $2$ $\\textsf{CPU}$ clock cycles and uses $\\textsf{MAR}$ (Memory Address Register) and $\\textsf{MDR}$ (Memory Date Register). $\\textsf{SP}$ can be decremented locally.</p>\n\n<p><img alt="" height="261" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=6301981403617845683" width="632"></p>\n\n<p>The $\\textsf{CPU}$ instruction "<code>push r</code>" where, $r =$ $A$ or $B$ has the specification</p>\n\n<ul>\n\t<li>$M[SP] ← r $</li>\n\t<li>$SP ← SP - 1$</li>\n</ul>\n\n<p>How many $\\textsf{CPU}$ clock cycles are required to execute the "<code>push r</code>" instruction?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2$</li>\n\t<li>$3$</li>\n\t<li>$4$</li>\n\t<li>$5$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2001,co-and-architecture,data-path,machine-instruction,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '790', 'text': '<p>In an enhancement of a design of a CPU, the speed of a floating point unit&nbsp;has been increased by $\\text{20%}$ and the speed of a fixed point unit has been increased by $\\text{10%}$. What is the overall speedup achieved if the ratio of the number of floating point operations to the number of fixed point operations is $2:3$ and the floating point operation used to take twice the time taken by the fixed point operation in the original design?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1.155$</li>\n\t<li>$1.185$</li>\n\t<li>$1.255$</li>\n\t<li>$1.285$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gateit-2004,normal,co-and-architecture,speedup', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '813', 'text': '<p>A device employing INTR line for device interrupt puts the CALL instruction on the data bus while:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\overline{INTA}$ is active</li>\n\t<li>HOLD is active</li>\n\t<li>READY is inactive</li>\n\t<li>None of the above</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2002,co-and-architecture,interrupts,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '837', 'text': '<p>Horizontal microprogramming:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>does not require use of signal decoders</li>\n\t<li>results in larger sized microinstructions than vertical &nbsp;microprogramming</li>\n\t<li>uses one bit for each control signal</li>\n\t<li>all of the above</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2002,co-and-architecture,microprogramming', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '938', 'text': '<p>Consider the following assembly language program for a hypothetical processor $A, B,$ and $C$ are $8-$bit registers. The meanings of various instructions are shown as comments.<br>\n$$\\small \\begin{array}{lll}&nbsp;&amp; \\text{MOV B, #0}&amp;&amp; \\text{;} &amp; \\text{$B \\leftarrow 0$} \\\\&amp; \\text{MOV C, #8} &amp;&amp; \\text{;}&amp; \\text{$C \\leftarrow 8$} \\\\<br>\n\\text{Z:} &amp; \\text{CMP C, #0} &amp;&amp;\\text{;}&amp; \\text{compare C with 0} \\\\&nbsp;<br>\n&amp; \\text{JZ X} &amp;&amp; \\text{;}&amp; \\text{jump to X if zero flag is set}&nbsp; \\\\<br>\n&amp; \\text{SUB C, #1} &amp;&amp; \\text{;}&amp; \\text{$C \\gets C-1$}&nbsp; \\\\&nbsp;<br>\n&amp; \\text{RRC A, #1} &amp;&amp; \\text{;}&amp; \\text{right rotate A through carry by one bit. Thus:}&nbsp; \\\\&nbsp; &amp; \\text{} &amp;&amp; \\text{;}&amp; \\text{If the initial values of A and the carry flag are $a_7\\ldots a_0$ and}&nbsp; \\\\&nbsp;<br>\n&amp; \\text{} &amp;&amp; \\text{;}&amp; \\text{$c_0$ respectively, their values after the execution of this}&nbsp; \\\\&nbsp;<br>\n&amp; \\text{} &amp;&amp; \\text{;}&amp; \\text{instruction will be $c_0a_7\\ldots a_1$ and $a_0$ respectively.}&nbsp; \\\\&nbsp;<br>\n&amp; \\text{JC Y} &amp;&amp; \\text{;}&amp; \\text{jump to Y if carry flag is set}&nbsp; \\\\<br>\n&amp; \\text{JMP Z} &amp;&amp; \\text{;}&amp; \\text{jump to Z}&nbsp; \\\\<br>\n\\text{Y:} &amp; \\text{ADD B, #1} &amp;&amp; \\text{;}&amp; \\text{$B \\gets B+1$}&nbsp; \\\\&nbsp;<br>\n&amp; \\text{JMP Z} &amp;&amp; \\text{;}&amp; \\text{jump to Z}&nbsp; \\\\&nbsp;<br>\n\\text{X:}&amp; \\text{} &amp;&amp; \\text{;}&amp; \\text{}&nbsp; \\\\ \\end{array}$$<br>\nIf the initial value of register A is A0 the value of register B after the program execution will be</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>the number of $0$ bits in $A_0$</li>\n\t<li>the number of $1$ bits in $A_0$</li>\n\t<li>$A_0$</li>\n\t<li>$8$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2003,co-and-architecture,machine-instruction,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1058', 'text': '<p>Consider the following program segment for a hypothetical CPU having three user registers $R_1, R_2$ and $R_3.$ $$\\begin{array}{|l|l|c|} \\hline \\text {Instruction} &nbsp;&amp; &nbsp;\\text{Operation&nbsp;}&amp; \\text{Instruction size} \\\\&amp;&amp; \\text{(in words)} \\\\\\hline \\text{MOV $R_1,5000$} &amp; \\text{$R_1$}&nbsp;\\leftarrow&nbsp; \\text{Memory$[5000]$}&amp; \\text{$2$} \\\\\\hline\\text{MOV $R2,(R1)$} &amp; \\text{$R2$}&nbsp;\\leftarrow&nbsp; \\text{Memory$[(R_1)]$}&amp; \\text{$1$} \\\\\\hline \\text{ADD&nbsp;$R_2,R_3$} &amp; \\text{$R2$}&nbsp;\\leftarrow&nbsp; \\text{$R_2 + R_3$} &amp; \\text{$1$} \\\\\\hline \\text{MOV&nbsp;$6000,R_2$} &amp; \\text{Memory$[6000]$}&nbsp;\\leftarrow&nbsp; \\text{$R_2$} &amp; \\text{$2$} \\\\\\hline \\text{HALT} &amp; \\text{Machine Halts} &amp; \\text{$1$} \\\\\\hline \\end{array}$$Consider that the memory is byte addressable with size $32$ bits, and the program has been loaded starting from memory location $1000$ (decimal). If an interrupt occurs while the CPU has been halted after executing the HALT instruction, the return address (in decimal) saved in the stack will be</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1007$</li>\n\t<li>$1020$</li>\n\t<li>$1024$</li>\n\t<li>$1028$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2004,co-and-architecture,machine-instruction,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1059', 'text': '<p>Consider a small two-way set-associative cache memory, consisting of four blocks. For choosing the block to be replaced, use the least recently used (LRU) scheme. The number of cache misses for the following sequence of block addresses is:</p>\n\n<p>$8, 12, 0, 12, 8$.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2$</li>\n\t<li>$3$</li>\n\t<li>$4$</li>\n\t<li>$5$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2004,co-and-architecture,cache-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1061', 'text': '<p>The microinstructions stored in the control memory of a processor have a width of $26$ bits. Each microinstruction is divided into three fields: a micro-operation field of $13$ bits, a next address field $(X),$ and a MUX select field $(Y).$ There are $8$ status bits in the input of the MUX.</p>\n\n<p><img alt="" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=17933537052434479943" width="500"></p>\n\n<p>How many bits are there in the $X$ and $Y$ fields, and what is the size of the control memory in number of words?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$10, 3, 1024$</li>\n\t<li>$8, 5, 256$</li>\n\t<li>$5, 8, 2048$</li>\n\t<li>$10, 3, 512$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2004,co-and-architecture,microprogramming,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1062', 'text': '<p>A hard disk with a transfer rate of $10$&nbsp;Mbytes/second is constantly transferring data to memory using DMA. The processor runs at $600$ MHz, and takes $300$ and $900$ clock cycles to initiate and complete DMA transfer respectively. If the size of the transfer is $20$ Kbytes, what is the percentage of processor time consumed for the transfer operation?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$5.0 \\%$</li>\n\t<li>$1.0\\%$</li>\n\t<li>$0.5\\%$</li>\n\t<li>$0.1\\%$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2004,dma,normal,co-and-architecture', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1063', 'text': '<p>A 4-stage pipeline has the stage delays as $150$, $120$, $160$ and $140$ $nanoseconds$, respectively. Registers that are used between the stages have a delay of $5$ $nanoseconds$ each. Assuming constant clocking rate, the total time taken to process $1000$ data items on this pipeline will be:</p>\n\n<ol style="list-style-type:upper-alpha">\n<li>\n<p>$\\text{120.4 microseconds}$</p>\n</li>\n<li>\n<p>$\\text{160.5 microseconds}$</p>\n</li>\n<li>\n<p>$\\text{165.5 microseconds}$</p>\n</li>\n<li>\n<p>$\\text{590.0 microseconds}$</p>\n</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2004,co-and-architecture,pipelining,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1208', 'text': '<p>Consider a $4$-way set associative cache consisting of $128$ lines with a line size of $64$ words. The <strong>CPU </strong>generates a $20-bit$ address of a word in main memory. The number of bits in the TAG, LINE and WORD fields are respectively:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$9, 6, 5$</li>\n\t<li>$7, 7, 6$</li>\n\t<li>$7, 5, 8$</li>\n\t<li>$9, 5, 6$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2007,co-and-architecture,cache-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1252', 'text': '<p>In a simplified computer the instructions are:</p>\n\n<p>$$\\begin{array}{|l|l|} \\hline \\text {OP }R _j , R _i &amp; \\text{Perform }R _j \\text{ OP } R _i \\text{ and store the result in register }R _j \\\\\\hline<br>\n\\text{OP }m,R _i &amp; \\text{Perform } val\\text{ OP }R _i \\text{ and store the result in register }R _i&nbsp; \\\\<br>\n&amp; val \\text{ denotes the content of the memory location }m \\\\\\hline<br>\n\\text{MOV }m,R _i &amp; \\text{Moves the content of memory location }m \\text{ to register }R _i \\\\\\hline<br>\n\\text{MOV }R _i,m &amp; \\text{Moves the content of register }R _i\\text{ to memory location }m\\\\\\hline \\end{array}$$</p>\n\n<p>The computer has only two registers, and OP is either ADD or SUB. Consider the following basic block:</p>\n\n<ul>\n\t<li>$t_1\\: = \\: a+b$</li>\n\t<li>$t_2\\: = \\: c+d$</li>\n\t<li>$t_3\\: = \\: e-t_2$</li>\n\t<li>$t_4\\: = \\: t_1 – t_3$</li>\n</ul>\n\n<p>Assume that all operands are initially in memory. The final value of the computation should be in memory. What is the minimum number of MOV instructions in the code generated for this basic block?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2$</li>\n\t<li>$3$</li>\n\t<li>$5$</li>\n\t<li>$6$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2007,co-and-architecture,machine-instruction,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1269', 'text': '<p>Consider the following program segment. Here $\\text{R1, R2}$ and $\\text{R3}$ are the general purpose registers.<br>\n$$\\begin{array}{|l|l|l|c|} \\hline &amp; \\text {Instruction} &amp; \\text{Operation }&amp; \\text{Instruction Size} \\\\ &amp; &amp; &amp; \\text{(no. of words)} \\\\\\hline &amp; \\text{MOV R1,(3000)} &amp; \\text{R1} \\leftarrow \\text{M[3000]} &amp; \\text{$2$} \\\\\\hline \\text{LOOP:}&amp; \\text{MOV R2,(R3)} &amp; \\text{R2} \\leftarrow \\text{M[R3]} &amp; \\text{$1$} \\\\\\hline &amp; \\text{ADD R2,R1} &amp; \\text{R2} \\leftarrow \\text{R1 + R2} &amp; \\text{$1$} \\\\\\hline &amp; \\text{MOV (R3),R2} &amp; \\text{M[R3]} \\leftarrow \\text{R2} &amp; \\text{$1$} \\\\\\hline&amp; \\text{INC R3} &amp; \\text{R3} \\leftarrow \\text{R3 + 1} &amp; \\text{$1$} \\\\\\hline &amp; \\text{DEC R1} &amp; \\text{R1} \\leftarrow \\text{R1 – 1} &amp; \\text{$1$} \\\\\\hline&amp; \\text{BNZ LOOP} &amp; \\text{Branch on not zero} &amp; \\text{$2$} \\\\\\hline &amp; \\text{HALT} &amp; \\text{Stop} &amp; \\text{$1$} \\\\\\hline\\end{array}$$</p>\n\n<p>Assume that the content of memory location $3000$ is $10$ and the content of the register $\\text{R3}$ is $2000$. The content of each of the memory locations from $2000$ to $2010$ is $100$. The program is loaded from the memory location $1000$. All the numbers are in decimal.</p>\n\n<p>Assume that the memory is word addressable. The number of memory references for accessing the data in executing the program completely is</p>\n\n<ol style="list-style-type:upper-alpha">\n<li>$10$</li>\n<li>$11$</li>\n<li>$20$</li>\n<li>$21$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2007,co-and-architecture,machine-instruction,interrupts,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1273', 'text': '<p>Consider a machine with a byte addressable main memory of $2^{16}$&nbsp;bytes. Assume that a direct mapped data cache consisting of $32$ lines of $64$ bytes&nbsp;each is used in the system. A $50&nbsp;\\times 50$ two-dimensional array of bytes is stored in the main memory starting from memory location $1100H$. Assume that the data cache is initially empty. The complete array is accessed twice. Assume that the contents of the data cache do not change in between the two accesses.&nbsp;</p>\n\n<p>How many data misses will occur in total?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$48$</li>\n\t<li>$50$</li>\n\t<li>$56$</li>\n\t<li>$59$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2007,co-and-architecture,cache-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1314', 'text': '<p>Consider a $4$ stage pipeline processor. The number of cycles needed by the four instructions $I1, I2, I3, I4$ in stages $S1, S2, S3, S4$ is shown below:</p>\n\n<p>$$\\begin{array}{|c|c|c|c|c|} \\hline \\textbf{} &amp; \\textbf {S1} &amp;\\textbf {S2} &amp; \\textbf {S3} &amp; &nbsp;\\textbf{S4 } \\\\\\hline \\textbf{I1}&amp; 2 &amp;&nbsp;1&nbsp;&nbsp;&amp; 1 &amp; 1 \\\\\\hline \\textbf{I2} &amp; 1&nbsp;&amp; 3 &amp; 2&nbsp;&nbsp;&amp; 2\\\\\\hline&nbsp;&nbsp;\\textbf{I3}&amp; 2 &amp;&nbsp;1&nbsp;&nbsp;&amp; 1 &amp; 3 \\\\\\hline \\textbf{I4} &amp; 1&nbsp;&amp; 2 &amp; 2&nbsp;&nbsp;&amp; 2 \\\\\\hline&nbsp; \\end{array}$$</p>\n\n<p>&nbsp;</p>\n\n<p>What is the number of cycles needed to execute the following loop?</p>\n\n<p>For (i=1 to 2) {I1; I2; I3; I4;}</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$16$</li>\n\t<li>$23$</li>\n\t<li>$28$</li>\n\t<li>$30$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2009,co-and-architecture,pipelining,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1315', 'text': '<p>Consider a $4$-way set associative cache (initially empty) with total $16$ cache blocks. The main memory consists of $256$ blocks and the request for memory blocks are in the following order:</p>\n\n<p>$0, 255, 1, 4, 3, 8, 133, 159, 216, 129, 63, 8, 48, 32, 73, 92, 155.$</p>\n\n<p>Which one of the following memory block will NOT be in cache if LRU replacement policy is used?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$3$</li>\n\t<li>$8$</li>\n\t<li>$129$</li>\n\t<li>$216$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2009,co-and-architecture,cache-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1388', 'text': '<p>Consider a three word machine instruction</p>\n\n<p>$\\text{ADD} A[R_0], @B$</p>\n\n<p>The first operand (destination) $“A[R_0]”$&nbsp;uses indexed addressing mode with $R_0$ as the index register. The second operand (source) $“@B”$&nbsp;uses indirect addressing mode. $A$ and $B$ are memory addresses residing at the second and third words, respectively. The first word of the instruction specifies the opcode, the index register designation and the source and destination addressing modes. During execution of $\\text{ADD}$ instruction, the two operands are added and stored in the destination (first operand).</p>\n\n<p>The number of memory cycles needed during the execution cycle of the instruction is:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$3$</li>\n\t<li>$4$</li>\n\t<li>$5$</li>\n\t<li>$6$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2005,co-and-architecture,addressing-modes,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1391', 'text': '<p>A $5$ stage pipelined CPU has the following sequence of stages:</p>\n\n<ul>\n\t<li>IF – instruction fetch from instruction memory</li>\n\t<li>RD – Instruction decode and register read</li>\n\t<li>EX – Execute: ALU operation for data and address computation</li>\n\t<li>MA – Data memory access – for write access, the register read at RD state is used.</li>\n\t<li>WB – Register write back</li>\n</ul>\n\n<p>Consider the following sequence of instructions:</p>\n\n<ul>\n\t<li>$I_1$: $L$ $R0, loc$ $1$; $R0 \\Leftarrow M[loc1]$</li>\n\t<li>$I_2$: $A$ $R0$, $R0$; $R0 \\Leftarrow R0 +R0$</li>\n\t<li>$I_3$: $S$ $R2$, $R0$; $R2 \\Leftarrow R2-R0$</li>\n</ul>\n\n<p>Let each stage take one clock cycle.</p>\n\n<p>What is the number of clock cycles taken to complete the above sequence of instructions starting from the fetch of $I_1$?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$8$</li>\n\t<li>$10$</li>\n\t<li>$12$</li>\n\t<li>$15$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2005,co-and-architecture,pipelining,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1392', 'text': '<p>A device with data transfer rate $10$ KB/sec is connected to a CPU. Data is transferred byte-wise. Let the interrupt overhead be $4\\mu$sec. The byte transfer time between the device interface&nbsp;register and CPU or memory is negligible. What is the minimum performance gain of operating the device under interrupt mode over operating it under program-controlled mode?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$15$</li>\n\t<li>$25$</li>\n\t<li>$35$</li>\n\t<li>$45$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2005,co-and-architecture,interrupts', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1393', 'text': '<p>Consider a disk drive with the following specifications:</p>\n\n<p>$16$ surfaces, $512$ tracks/surface, $512$ sectors/track, $1$ KB/sector, rotation speed $3000$ rpm. The disk is operated in cycle stealing mode whereby whenever one $4$ byte word is ready it is sent to memory; similarly, for writing, the disk interface reads a $4$ byte word from the memory in each DMA cycle. Memory cycle time is $40$&nbsp;nsec. The maximum percentage of time that the CPU gets blocked during DMA operation is:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$10$</li>\n\t<li>$25$</li>\n\t<li>$40$</li>\n\t<li>$50$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2005,co-and-architecture,disk,normal,dma', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1402', 'text': '<p>Consider the following data path of a $\\text{CPU}.$</p>\n\n<p><img alt="" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=8051408258367583932" width="770"></p>\n\n<p>The $\\text{ALU},$ the bus and all the registers in the data path are of identical size. All operations including incrementation of the $\\text{PC}$ and the $\\text{GPRs}$ are to be carried out in the $\\text{ALU}.$ Two clock cycles are needed for memory read operation – the first one for loading address in the $\\text{MAR}$ and the next one for loading data from the memory bus into the $\\text{MDR}.$</p>\n\n<p>The instruction $``\\text{add R0, R1}”$ has the register transfer interpretation $\\text{R0} \\Leftarrow&nbsp;\\text{R0 + R1}.$ The minimum number of clock cycles needed for execution cycle of this instruction is:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2$</li>\n\t<li>$3$</li>\n\t<li>$4$</li>\n\t<li>$5$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2005,co-and-architecture,machine-instruction,data-path,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1442', 'text': '<p>In a $k$-way set associative cache, the cache is divided into $v$ sets, each of which consists of $k$ lines. The lines of a set are placed in sequence one after another. The lines in set $s$ are sequenced before the lines in set $(s+1)$. The main memory blocks are numbered 0 onwards. The main memory block numbered $j$ must be mapped to any one of the cache lines from</p>\n\n<ol style="list-style-type: upper-alpha;">\n\t<li>$(j\\text{ mod }v) * k \\text{ to } (j \\text{ mod } v) * k + (k-1) $</li>\n\t<li>$(j \\text{ mod } v) \\text{ to } (j \\text{ mod } v) + (k-1) $</li>\n\t<li>$(j \\text{ mod } k) \\text{ to } (j \\text{ mod } k) + (v-1) $</li>\n\t<li>$(j \\text{ mod } k) * v \\text{ to } (j \\text{ mod } k) * v + (v-1) $</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2013,co-and-architecture,cache-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1475', 'text': '<p>The main memory of a computer has $2\\;\\text{cm}$ blocks while the cache has $2\\;\\text{c}$ blocks. If the cache uses the set associative mapping scheme with $2$ blocks per set, then block $k$ of the main memory maps to the set:</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$(k&nbsp;\\mod&nbsp;m)$ of the cache</li>\n\t<li>$(k&nbsp;\\mod c)$ of the cache</li>\n\t<li>$(k&nbsp;\\mod&nbsp;2c)$ of the cache</li>\n\t<li>$(k&nbsp;\\mod&nbsp;2\\; cm)$ of the cache</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gate1999,co-and-architecture,cache-memory,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1497', 'text': '\n<p>Arrange the following configuration for CPU in decreasing order of operating speeds:</p>\n\n<p>Hard wired control, Vertical microprogramming, Horizontal microprogramming.</p>\n\n\n\n<ol style="list-style-type:upper-alpha"><li>\n\t<p>Hard wired control, Vertical microprogramming, Horizontal microprogramming.</p>\n\t</li>\n\t<li>\n\t<p>Hard wired control, Horizontal microprogramming, Vertical microprogramming.</p>\n\t</li>\n\t<li>\n\t<p>Horizontal microprogramming, Vertical microprogramming, Hard wired control.</p>\n\t</li>\n\t<li>\n\t<p>Vertical microprogramming, Horizontal microprogramming, Hard wired control.</p>\n\t</li>\n</ol>\n', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'gate1999,co-and-architecture,microprogramming,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1539', 'text': '<p>Consider the following sequence of micro-operations.</p>\n\n<pre class="prettyprint lang-c_cpp">\nMBR ← PC  \nMAR ← X  PC ← Y  \nMemory ← MBR</pre>\n\n<p>Which one of the following is a possible operation performed by this sequence?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>Instruction fetch</li>\n\t<li>Operand fetch</li>\n\t<li>Conditional branch</li>\n\t<li>Initiation of interrupt service</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'gatecse-2013,co-and-architecture,microprogramming,normal', 'category': 'CO and Architecture'}, {'contents': '', 'post_id': '1657', 'text': '<p>Which of the following is true?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>\n\t<p>Unless enabled, a CPU will not be able to process interrupts.</p>\n\t</li>\n\t<li>\n\t<p>Loop instructions cannot be interrupted till they complete.</p>\n\t</li>\n\t<li>\n\t<p>A processor checks for interrupts before executing a new instruction.</p>\n\t</li>\n\t<li>\n\t<p>Only level triggered interrupts are possible on microprocessors.</p>\n\t</li>\n</ol>\n\n', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'gate1998,co-and-architecture,interrupts,normal', 'category': 'CO and Architecture'}]}]}
      </script>
      