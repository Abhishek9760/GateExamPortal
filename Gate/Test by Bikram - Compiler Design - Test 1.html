<div><span>Q1</span> - <p>Match the following:</p>

<p>
    [                                a.             amp; Canonical Parser                           amp; 1.     amp; No adjacent nonterminals;                                b.                amp; SLR(1) Parser                           amp; 2. amp; Follow sets must be disjoint;                                c.                 amp; LL(1) Parser                           amp; 3.         amp; Most powerful parser;                                d.  amp; Operator Precedence Grammar                           amp; 4.              amp; Top-down parser;                                   ]
</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>a-2; b-3; c-1; d-4</li>
	<li>a-3; b-4; c-2; d-1</li>
	<li>a-2; b-1; c-4; d-3</li>
	<li>a-3; b-2; c-4; d-1</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>The default type of conflict resolution rule for the <em>Yacc parser generator</em> is _________________.</p>

<ol style="list-style-type:upper-alpha">
	<li>   nbsp;in favor of shift    nbsp;   nbsp;</li>
	<li>   nbsp;in favor of reduce    nbsp;</li>
	<li>   nbsp;either shift or reduce    nbsp;   nbsp;</li>
	<li>   nbsp;dependent   nbsp;on a   nbsp;situation</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <p>Consider the following two parse trees for the expression: 6 - 4 - 3</p>

<p><br>
   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;list    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;   nbsp;list<br>
   nbsp;   nbsp;   nbsp;   nbsp;/    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;    nbsp; /    nbsp;    nbsp;    nbsp;|    nbsp;    nbsp; br>
   nbsp;   nbsp;/    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;    nbsp;    nbsp;/    nbsp;    nbsp;    nbsp; |    nbsp;    nbsp;    nbsp; br>
   nbsp;   nbsp;list    nbsp;   nbsp;   nbsp;   nbsp;—    nbsp;   nbsp;   nbsp;number    nbsp;    nbsp;    nbsp;    nbsp;number    nbsp;    nbsp; —    nbsp;   nbsp;   nbsp;   nbsp;list<br>
   nbsp;/    nbsp;   nbsp;|     nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;/    nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;br>
/    nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;/    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;br>
list - number    nbsp;   nbsp;3    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;6    nbsp;    nbsp;    nbsp;    nbsp;number    nbsp;—    nbsp;   nbsp;    nbsp;list<br>
|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|<br>
|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;|<br>
number    nbsp;   nbsp;4    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;4    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;number<br>
|    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp; |<br>
|    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp;    nbsp; |<br>
6    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;3<br>
<br>
   nbsp;   nbsp;   nbsp;(a)    nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;   nbsp;(b)</p>

<p>   nbsp;</p>

<p>Next, consider the below statements:</p>

<ol>
	<li>The parse tree (a) represents right associative operator evaluation and the parse tree   nbsp;(b) represents left associative evaluation.</li>
	<li>The grammar generating the sentence is not ambiguous.</li>
</ol>

<p>   nbsp;</p>

<p>Which of the above statements are FALSE?</p>

<ol style="list-style-type:upper-alpha">
	<li>Only 2</li>
	<li>1   nbsp;and 2</li>
	<li>Only 1</li>
	<li>Both statements are correct</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - <p>A top-down parser generates ________________.</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>right-most derivation</li>
	<li>right-most derivation in reverse</li>
	<li>left-most derivation</li>
	<li>left-most derivation in reverse</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - <p>__________   nbsp;is the most powerful parsing method.</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>LL(1)</li>
	<li>LALR</li>
	<li>SLR</li>
	<li>Canonical LR</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - <p>Consider the following grammars:<br>
Z →   nbsp; TZ'<br>
Z' → ^* TZ' |ϵ<br>
T →   nbsp; YT'<br>
T ' → ^*YT '    nbsp;|ϵ<br>
Y → (Z) | id</p>

<p>   nbsp;</p>

<p>Which of the following is First(Z)?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>{T, ) }</li>
	<li>{(, id }</li>
	<li>{ ), $}</li>
	<li>None of the   nbsp;above</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - <p>The number of proper prefixes for a string of length n are ___________.</p>

<ol>
	<li>n+1</li>
	<li>n(n+1)/2</li>
	<li>n-1</li>
	<li>(n-1)/2</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - <p>Read the following grammar:</p>

<p>S →   nbsp; Ka | bKc | dc   nbsp; | bda<br>
K →   nbsp; d</p>

<p>This   nbsp;grammar is NOT:</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>LALR(1)</li>
	<li>SLR(1)</li>
	<li>LR(1)</li>
	<li>None of the above</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - <p>___________ parsers build parse trees starting from the root node and work down to the leaves.</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>LR</li>
	<li>LL</li>
	<li>SLR</li>
	<li>LALR</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>The grammar which has no epsilon transition or two adjacent nonterminals in the right side of any production is ___________.</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>LL(1) grammar</li>
	<li>Unambiguous grammar</li>
	<li>Operator grammar</li>
	<li>Context Sensitive grammar</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - <p>In the construction of LL(1) parsing table for the following grammar M[S,( ] &amp; M [W, $] are respectively</p>

<ul>
	<li>S → XY</li>
	<li>X → (S) |   nbsp; int  W</li>
	<li>Y→ +S |ϵ</li>
	<li>W →   nbsp;^*X |ϵ</li>
</ul>

<ol style="list-style-type:upper-alpha">
	<li>X → (S),  W →ϵ</li>
	<li>S → XY,  W →   nbsp;^*x</li>
	<li>S → XY,   nbsp;  W →   nbsp;ϵ</li>
	<li>S → YX,  W →ϵ</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>Read the below mentioned grammar:</p>

<p>S → X</p>

<p>X →   nbsp;YX |ϵ</p>

<p>Y →   nbsp;aY | b</p>

<p>This   nbsp;grammar is NOT:</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>LALR</li>
	<li>LR (0)</li>
	<li>LR(1)</li>
	<li>None of the above</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Consider following Translation Scheme:<br>
S → ER<br>
R →   nbsp;^* E { print {' *' }; } R |ϵ<br>
E → F + E { print ('+');}| F<br>
F → S | id { print (id,value) ; }</p>

<p>Here, id is a taken that represents an integer and id, value represents the corresponding integer value.   nbsp;</p>

<p>What does this Translation Scheme print for an input   nbsp;" 1* 7 + 9 "?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>1 7*    nbsp;+ 9</li>
	<li>1 * 7 9 +</li>
	<li>1 7 9 * +</li>
	<li>179 + *</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q14</span> - <p>Consider the following grammar:   nbsp;</p>

<p>E' → E</p>

<p>E → E + Y | Y</p>

<p>Y → Y ^* F | F</p>

<p>F → id | (E)</p>

<p>How many LR(0) items are there in closure ({E' →· E})?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>1</li>
	<li>6</li>
	<li>7</li>
	<li>5</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q15</span> - <p>Which of these is NOT   nbsp;true about Abstract Syntax Tree (AST)?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>An   nbsp; AST   nbsp;is usually the result of the syntax analysis phase of a compiler.</li>
	<li>AST has no impact on the final output of the compiler.</li>
	<li>AST is a tree representation of the abstract syntactic structure of source code written in a programming language.</li>
	<li>AST is also used in program analysis and program transformation systems.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q16</span> - <p>Consider the following grammars:</p>

<ol>
	<li>S → aS | Sa |   nbsp; ∈</li>
	<li>E → E +E | E^*E | id</li>
	<li>A → AA | (A) | a</li>
	<li>S → SS | AB,  A → Aa | a,  B → Bb | b</li>
</ol>

<p>   nbsp;</p>

<p>These grammars   nbsp;are:</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>Ambiguous</li>
	<li>Unambiguous</li>
	<li>Regular</li>
	<li>Inherently Ambiguous</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q17</span> - <p>Which one of the following statements is TRUE?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>SLR parser is more powerful than LALR.</li>
	<li>LALR parser is more powerful than Canonical LR.</li>
	<li>Canonical LR is more powerful than LALR parser.</li>
	<li>SLR, Canonical LR and LALR parsers have the same power.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q18</span> - <p>Assume that the SLR(1) parser for a grammar has P1 states, and the CLR(1) parser for the same has P2 states. Which of the following clearly depicts the relationship between P1 and P2?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>P1 ≤ P2</li>
	<li>P1 = P2</li>
	<li>P1 ≥ P2</li>
	<li>It depends on the grammar.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q19</span> - <p>Consider the following grammar:</p>

<ul>
	<li>Z →   nbsp;TZ'</li>
	<li>Z' →   nbsp;+TZ'    nbsp;|ϵ</li>
	<li>T → Y T '</li>
	<li>T ' → ^* YT ' |ϵ</li>
	<li>Y →   nbsp;(Z) |   nbsp;id</li>
</ul>

<p>Which of the following represents   nbsp;Follow(Y)?</p>

<ol style="list-style-type:upper-alpha">
	<li>{ ), id }</li>
	<li>{ ), id, $,    nbsp;*,    nbsp;+ }</li>
	<li>{ ^*, +,    nbsp;),    nbsp;$}</li>
	<li>{ +, ),    nbsp;$}</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q20</span> - The least number of temporary variables required to create a 3 address code sequence for the statement L= P + R is ________.<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q21</span> - <p>Which one of the following can be handled by predictive parsers?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>Left recursion</li>
	<li>Left factors</li>
	<li>Ambiguity</li>
	<li>Non-determinism</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q22</span> - <p>The language which supports _______ needs heap allocation in the runtime environment.</p>

<ol style="list-style-type:upper-alpha">
	<li>Dynamic Data Structure    nbsp;   nbsp;   nbsp;   nbsp;</li>
	<li>Static Scoping    nbsp;</li>
	<li>Global Variable    nbsp;</li>
	<li>Recursion</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q23</span> - <p>Which one of the following statements is TRUE?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>SLR parser has more states than LALR parser.</li>
	<li>LALR parser has more states than Canonical LR.</li>
	<li>Canonical LR has fewer states than SLR parser.</li>
	<li>Both SLR and LALR parsers have the same number of states.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q24</span> - <p>Consider the following grammar:</p>

<p>E → E + T | T<br>
T → T ^* F | F<br>
F → (E) | id</p>

<p>What are   nbsp;the productions for E, T and F after converting the above mentioned   nbsp;grammar to LL(1) grammar?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>E → +TE',   T →   nbsp;^*FT ',  &nbsp;   nbsp;F → (E) | id</li>
	<li>E → +TE' |   nbsp;ϵ,  &nbsp;T →   nbsp;^*FT ' |   nbsp; ϵ</li>
	<li>E →   nbsp;T,  &nbsp;   nbsp;T → F,  &nbsp;   nbsp;F→ (E)    nbsp;|   nbsp; id</li>
	<li>E → TE' ,  &nbsp; T → FT' ,  &nbsp; F → (E)    nbsp;| id</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q25</span> - <p>Consider the following grammar:</p>

<ul>
	<li>S →   nbsp;aMd |   nbsp;   nbsp;bNd |   nbsp;aNe |   nbsp;bMe</li>
	<li>M →   nbsp;c</li>
	<li>N → c</li>
</ul>

<p>The grammar above is:</p>

<ol style="list-style-type:upper-alpha" type="A">
	<li>LR(1) but not LALR(1)</li>
	<li>LALR(1) but not SLR(1)</li>
	<li>SLR(1) but not LR(1)</li>
	<li>LALR(1)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q26</span> - <p>In compilers, the type checking   nbsp;is done in:</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>Lexical Analysis</li>
	<li>Semantic Analysis</li>
	<li>Code Generation Phase</li>
	<li>Parsing Phase</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q27</span> - <p>goto function of LR class of grammar is represented as:</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>Deterministic Finite Automata transitions</li>
	<li>Non-deterministic Finite Automata transitions</li>
	<li>PDA transitions</li>
	<li>Parsing table</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q28</span> - <p>Consider the following syntax directed definition of any desk calculator:</p>

<ol>
	<li>L → En {print(E.val) }</li>
	<li>E → E1 + 1 {   nbsp;E.val = E1.val + Z.val }</li>
	<li>E → Z    nbsp;E · val = Z · val</li>
	<li>Z → Z1 ^* F { Z.val = Z1.val   nbsp; ^* F.val }</li>
	<li>Z → F { Z · val = F · val }</li>
	<li>F → ( E ) { F · val = E · val }</li>
	<li>F→ digit { F · val = digit · lexval }</li>
</ol>

<p>How many internal nodes are there in annotated parse tree for input 7 ^* 4 + 2n?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>9</li>
	<li>6</li>
	<li>10</li>
	<li>11</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q29</span> - <p>Which grammar causes recursive-descent parser to go into infinite loop?</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>LL(1)</li>
	<li>Left recursive grammar</li>
	<li>Right recursive grammar</li>
	<li>Grammar with left factors</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q30</span> - <p>Consider the following grammar:<br>
S →   nbsp; L = P | P<br>
L → ^*P | id<br>
P → L</p>

<p>The above grammar is:</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>Ambiguous</li>
	<li>SLR(1)</li>
	<li>LALR(1)</li>
	<li>None of the above</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let data={'name': 'Test by Bikram | Compiler Design | Test 1', 'duration': '90', 'total_qs': '30', 'total_qs_one': 0, 'total_qs_two': 30, 'apti_num_qs': 0, 'technical_num_qs': 30, 'apti_marks': 0, 'technical_marks': 60, 'total_marks': 60, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 30, 'marks': 60, 'question': [{'contents': '', 'post_id': '86109', 'text': '<p>Match the following:</p>\n\n<p>$$\\begin{array}{|l|l|l|l|} \\hline a. &amp; \\text{Canonical Parser} &amp; 1. &amp; \\text{No adjacent nonterminals} \\\\ \\hline b. &amp; \\text{SLR(1) Parser} &amp; 2. &amp; \\text{Follow sets must be disjoint} \\\\ \\hline c. &amp; \\text{LL(1) Parser} &amp; 3. &amp; \\text{Most powerful parser} \\\\ \\hline d. &amp; \\text{Operator Precedence Grammar} &amp; 4. &amp; \\text{Top-down parser} \\\\ \\hline \\end{array}$$</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$a-2; b-3; c-1; d-4$</li>\n\t<li>$a-3; b-4; c-2; d-1$</li>\n\t<li>$a-2; b-1; c-4; d-3$</li>\n\t<li>$a-3; b-2; c-4; d-1$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86110', 'text': '<p>The default type of conflict resolution rule for the <em>Yacc parser generator</em> is _________________.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>&nbsp;in favor of shift &nbsp;&nbsp;</li>\n\t<li>&nbsp;in favor of reduce &nbsp;</li>\n\t<li>&nbsp;either shift or reduce &nbsp;&nbsp;</li>\n\t<li>&nbsp;dependent&nbsp;on a&nbsp;situation</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86112', 'text': '<p>Consider the following two parse trees for the expression: $6 - 4 - 3$</p>\n\n<p><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;list<br>\n&nbsp;&nbsp;&nbsp;&nbsp;/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; / &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; \\<br>\n&nbsp;&nbsp;/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;/ &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; \\<br>\n&nbsp;&nbsp;list &nbsp;&nbsp;&nbsp;&nbsp;--- &nbsp;&nbsp;&nbsp;number &nbsp; &nbsp; &nbsp; &nbsp;number &nbsp; &nbsp; --- &nbsp;&nbsp;&nbsp;&nbsp;list<br>\n&nbsp;/ &nbsp;&nbsp;| \\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;\\<br>\n/ &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>\nlist - number &nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp;number &nbsp;--- &nbsp;&nbsp; &nbsp;list<br>\n| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>\n| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>\nnumber &nbsp;&nbsp;4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number<br>\n| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br>\n| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br>\n6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>\n<br>\n&nbsp;&nbsp;&nbsp;(a) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b)</p>\n\n<p>&nbsp;</p>\n\n<p>Next, consider the below statements:</p>\n\n<ol>\n\t<li>The parse tree (a) represents right associative operator evaluation and the parse tree&nbsp;(b) represents left associative evaluation.</li>\n\t<li>The grammar generating the sentence is not ambiguous.</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p>Which of the above statements are FALSE?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Only $2$</li>\n\t<li>$1$&nbsp;and $2$</li>\n\t<li>Only $1$</li>\n\t<li>Both statements are correct</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86113', 'text': '<p>A top-down parser generates ________________.</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>right-most derivation</li>\n\t<li>right-most derivation in reverse</li>\n\t<li>left-most derivation</li>\n\t<li>left-most derivation in reverse</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86114', 'text': '<p>__________&nbsp;is the most powerful parsing method.</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>LL(1)</li>\n\t<li>LALR</li>\n\t<li>SLR</li>\n\t<li>Canonical LR</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86115', 'text': '<p>Consider the following grammars:<br>\n$Z \\rightarrow&nbsp; TZ\'$<br>\n$Z\' \\rightarrow ^* TZ\' \\mid \\epsilon$<br>\n$T \\rightarrow&nbsp; YT\'$<br>\n$T \' \\rightarrow ^*YT \' &nbsp;\\mid \\epsilon$<br>\n$Y \\rightarrow (Z) \\mid id$</p>\n\n<p>&nbsp;</p>\n\n<p>Which of the following is First(Z)?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$\\{T, ) \\}$</li>\n\t<li>$\\{(, id \\}$</li>\n\t<li>$\\{ ), \\$ \\}$</li>\n\t<li>None of the&nbsp;above</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing,grammar', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86116', 'text': '<p>The number of proper prefixes for a string of length $n$ are ___________.</p>\n\n<ol>\n\t<li>$n+1$</li>\n\t<li>$n(n+1)/2$</li>\n\t<li>$n-1$</li>\n\t<li>$(n-1)/2$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,combinatory,counting', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86118', 'text': '<p>Read the following grammar:</p>\n\n<p>$S \\rightarrow&nbsp; Ka \\mid bKc \\mid dc&nbsp; \\mid bda$<br>\n$K \\rightarrow&nbsp; d$</p>\n\n<p>This&nbsp;grammar is NOT:</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>LALR(1)</li>\n\t<li>SLR(1)</li>\n\t<li>LR(1)</li>\n\t<li>None of the above</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,grammar', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86119', 'text': '<p>___________ parsers build parse trees starting from the root node and work down to the leaves.</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>LR</li>\n\t<li>LL</li>\n\t<li>SLR</li>\n\t<li>LALR</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86121', 'text': '<p>The grammar which has no epsilon transition or two adjacent nonterminals in the right side of any production is ___________.</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>LL(1) grammar</li>\n\t<li>Unambiguous grammar</li>\n\t<li>Operator grammar</li>\n\t<li>Context Sensitive grammar</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing,grammar', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86122', 'text': '<p>In the construction of $LL(1)$ parsing table for the following grammar $M[S,( ] \\&amp; M [W, \\$]$ are respectively</p>\n\n<ul>\n\t<li>$S \\rightarrow XY$</li>\n\t<li>$X \\rightarrow (S) \\mid&nbsp;\\text{ int } W$</li>\n\t<li>$Y\\rightarrow +S \\mid \\epsilon$</li>\n\t<li>$W \\rightarrow&nbsp;^*X \\mid \\epsilon$</li>\n</ul>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$X \\rightarrow (S), \\ W \\rightarrow \\epsilon$</li>\n\t<li>$S \\rightarrow XY, \\ W \\rightarrow&nbsp;^*x$</li>\n\t<li>$S \\rightarrow XY,&nbsp; \\ W \\rightarrow&nbsp;\\epsilon$</li>\n\t<li>$S \\rightarrow YX, \\ W \\rightarrow \\epsilon$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86123', 'text': '<p>Read the below mentioned grammar:</p>\n\n<p>$S \\rightarrow X$</p>\n\n<p>$X \\rightarrow&nbsp;YX \\mid \\epsilon$</p>\n\n<p>$Y \\rightarrow&nbsp;aY \\mid b$</p>\n\n<p>This&nbsp;grammar is NOT:</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$LALR$</li>\n\t<li>$LR (0)$</li>\n\t<li>$LR(1)$</li>\n\t<li>None of the above</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,grammar', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86124', 'text': '<p>Consider following Translation Scheme:<br>\n$S \\rightarrow ER$<br>\n$R \\rightarrow&nbsp;^* E \\{ print \\{\' *\' \\}; \\} R \\mid \\epsilon$<br>\n$E \\rightarrow F + E \\{ print (\'+\');\\} \\mid F$<br>\n$F \\rightarrow S \\mid id \\{ print (id,value) ; \\}$</p>\n\n<p>Here, $id$ is a taken that represents an integer and id, $value$ represents the corresponding integer value.&nbsp;</p>\n\n<p>What does this Translation Scheme print for an input&nbsp;" $1* 7 + 9$ "?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$1 7* &nbsp;+ 9$</li>\n\t<li>$1 * 7 9 +$</li>\n\t<li>$1 7 9 * +$</li>\n\t<li>$179 + *$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,syntax-directed-translation', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86125', 'text': '<p>Consider the following grammar:&nbsp;</p>\n\n<p>$E\' \\rightarrow E$</p>\n\n<p>$E \\rightarrow E + Y \\mid Y$</p>\n\n<p>$Y \\rightarrow Y ^* F \\mid F$</p>\n\n<p>$F \\rightarrow id \\mid (E)$</p>\n\n<p>How many $LR(0)$ items are there in closure $(\\{E\' \\rightarrow \\cdot E\\})$?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$1$</li>\n\t<li>$6$</li>\n\t<li>$7$</li>\n\t<li>$5$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86126', 'text': '<p>Which of these is NOT&nbsp;true about Abstract Syntax Tree (AST)?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>An&nbsp; AST&nbsp;is usually the result of the syntax analysis phase of a compiler.</li>\n\t<li>AST has no impact on the final output of the compiler.</li>\n\t<li>AST is a tree representation of the abstract syntactic structure of source code written in a programming language.</li>\n\t<li>AST is also used in program analysis and program transformation systems.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,syntax-directed-translation,intermediate-code', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86128', 'text': '<p>Consider the following grammars:</p>\n\n<ol>\n\t<li>$S \\rightarrow aS \\mid Sa \\mid&nbsp; \\in$</li>\n\t<li>$E \\rightarrow E +E \\mid E^*E \\mid id$</li>\n\t<li>$A \\rightarrow AA \\mid (A) \\mid a$</li>\n\t<li>$S \\rightarrow SS \\mid AB, \\ A \\rightarrow Aa \\mid a, \\ B \\rightarrow Bb \\mid b$</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p>These grammars&nbsp;are:</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>Ambiguous</li>\n\t<li>Unambiguous</li>\n\t<li>Regular</li>\n\t<li>Inherently Ambiguous</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,grammar', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86129', 'text': '<p>Which one of the following statements is TRUE?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>SLR parser is more powerful than LALR.</li>\n\t<li>LALR parser is more powerful than Canonical LR.</li>\n\t<li>Canonical LR is more powerful than LALR parser.</li>\n\t<li>SLR, Canonical LR and LALR parsers have the same power.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86130', 'text': '<p>Assume that the SLR(1) parser for a grammar has P1 states, and the CLR(1) parser for the same has P2 states. Which of the following clearly depicts the relationship between P1 and P2?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$P1 \\leq P2$</li>\n\t<li>$P1 = P2$</li>\n\t<li>$P1 \\geq P2$</li>\n\t<li>It depends on the grammar.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86131', 'text': '<p>Consider the following grammar:</p>\n\n<ul>\n\t<li>$Z \\rightarrow &nbsp;TZ\'$</li>\n\t<li>$Z\' \\rightarrow &nbsp;+TZ\' &nbsp;\\mid \\epsilon$</li>\n\t<li>$T \\rightarrow Y T \'$</li>\n\t<li>$T \' \\rightarrow ^* YT \' \\mid \\epsilon$</li>\n\t<li>$Y \\rightarrow&nbsp;(Z) \\mid&nbsp;id$</li>\n</ul>\n\n<p>Which of the following represents&nbsp;Follow(Y)?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\{ ), id \\}$</li>\n\t<li>$\\{ ), id, \\$, &nbsp;*, &nbsp;+ \\}$</li>\n\t<li>$\\{ ^*, +, &nbsp;), &nbsp;\\$ \\}$</li>\n\t<li>$\\{ +, ), &nbsp;\\$ \\}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing,grammar', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86132', 'text': 'The least number of temporary variables required to create a $3$ address code sequence for the statement $L= P + R$ is ________.', 'type': 'Numerical', 'answer': '1', 'award': 2, 'penalty': '0.0000', 'tags': 'tbb-cd-1,numerical-answers,compiler-design,intermediate-code', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86133', 'text': '<p>Which one of the following can be handled by predictive parsers?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>Left recursion</li>\n\t<li>Left factors</li>\n\t<li>Ambiguity</li>\n\t<li>Non-determinism</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86134', 'text': '<p>The language which supports _______ needs heap allocation in the runtime environment.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Dynamic Data Structure &nbsp;&nbsp;&nbsp;&nbsp;</li>\n\t<li>Static Scoping &nbsp;</li>\n\t<li>Global Variable &nbsp;</li>\n\t<li>Recursion</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,runtime-environment', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86135', 'text': '<p>Which one of the following statements is TRUE?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>SLR parser has more states than LALR parser.</li>\n\t<li>LALR parser has more states than Canonical LR.</li>\n\t<li>Canonical LR has fewer states than SLR parser.</li>\n\t<li>Both SLR and LALR parsers have the same number of states.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86136', 'text': '<p>Consider the following grammar:</p>\n\n<p>$E \\rightarrow E + T \\mid T$<br>\n$T \\rightarrow T ^* F \\mid F$<br>\n$F \\rightarrow (E) \\mid id$</p>\n\n<p>What are&nbsp;the productions for E, T and F after converting the above mentioned&nbsp;grammar to LL(1) grammar?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$E \\rightarrow +TE\', \\ \\ T \\rightarrow&nbsp;^*FT \', \\ \\&nbsp;&nbsp;F \\rightarrow (E) \\mid id$</li>\n\t<li>$E \\rightarrow +TE\' \\mid&nbsp;\\epsilon, \\ \\&nbsp;T \\rightarrow&nbsp;^*FT \' \\mid&nbsp; \\epsilon$</li>\n\t<li>$E \\rightarrow &nbsp;T, \\ \\&nbsp;&nbsp;T \\rightarrow F, \\ \\&nbsp;&nbsp;F\\rightarrow (E) &nbsp;\\mid&nbsp; id$</li>\n\t<li>$E \\rightarrow TE\' , \\ \\&nbsp; T \\rightarrow FT\' , \\ \\&nbsp; F \\rightarrow (E) &nbsp;\\mid id$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing,ll-parser,grammar', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86137', 'text': '<p>Consider the following grammar:</p>\n\n<ul>\n\t<li>$S \\rightarrow &nbsp;aMd \\mid&nbsp;&nbsp;bNd \\mid&nbsp;aNe \\mid&nbsp;bMe$</li>\n\t<li>$M \\rightarrow &nbsp;c$</li>\n\t<li>$N \\rightarrow c$</li>\n</ul>\n\n<p>The grammar above is:</p>\n\n<ol style="list-style-type:upper-alpha" type="A">\n\t<li>LR(1) but not LALR(1)</li>\n\t<li>LALR(1) but not SLR(1)</li>\n\t<li>SLR(1) but not LR(1)</li>\n\t<li>LALR(1)</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,grammar', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86138', 'text': '<p>In compilers, the type checking&nbsp;is done in:</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>Lexical Analysis</li>\n\t<li>Semantic Analysis</li>\n\t<li>Code Generation Phase</li>\n\t<li>Parsing Phase</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,compilation-phases', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86139', 'text': '<p>$\\textbf{goto}$ function of LR class of grammar is represented as:</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>Deterministic Finite Automata transitions</li>\n\t<li>Non-deterministic Finite Automata transitions</li>\n\t<li>PDA transitions</li>\n\t<li>Parsing table</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,parsing,lr-parser', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86140', 'text': '<p>Consider the following syntax directed definition of any desk calculator:</p>\n\n<ol>\n\t<li>$L \\rightarrow En \\{ \\text{print}(E.val) \\}$</li>\n\t<li>$E \\rightarrow E1 + 1 \\{&nbsp;E.val = E1.val + Z.val \\}$</li>\n\t<li>$E \\rightarrow Z &nbsp;E \\cdot val = Z \\cdot val$</li>\n\t<li>$Z \\rightarrow Z1 ^* F \\{ Z.val = Z1.val&nbsp; ^* F.val \\}$</li>\n\t<li>$Z \\rightarrow F \\{ Z \\cdot val = F \\cdot val \\}$</li>\n\t<li>$F \\rightarrow ( E ) \\{ F \\cdot val = E \\cdot val \\}$</li>\n\t<li>$F\\rightarrow digit \\{ F \\cdot val = digit \\cdot lexval \\}$</li>\n</ol>\n\n<p>How many internal nodes are there in annotated parse tree for input $7 ^* 4 + 2n$?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$9$</li>\n\t<li>$6$</li>\n\t<li>$10$</li>\n\t<li>$11$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,syntax-directed-translation', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86141', 'text': '<p>Which grammar causes recursive-descent parser to go into infinite loop?</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>LL(1)</li>\n\t<li>Left recursive grammar</li>\n\t<li>Right recursive grammar</li>\n\t<li>Grammar with left factors</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,grammar', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '86142', 'text': '<p>Consider the following grammar:<br>\n$S \\rightarrow&nbsp; L = P \\mid P$<br>\n$L \\rightarrow ^*P \\mid id$<br>\n$P \\rightarrow L$</p>\n\n<p>The above grammar is:</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>Ambiguous</li>\n\t<li>SLR(1)</li>\n\t<li>LALR(1)</li>\n\t<li>None of the above</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'tbb-cd-1,compiler-design,grammar', 'category': 'Compiler Design'}]}]}
      </script>
      