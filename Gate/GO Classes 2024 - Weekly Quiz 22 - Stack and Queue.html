<div><span>Q1</span> - <p>Consider the memory allocation of M blocks.</p>

<p>Stack1 growing from block 0 up toward block M - 1 and Stack2 growing from block M-1 down to block 0.</p>

<p>Let Top1 (initialized to -1) and Top2  ( initialized   nbsp;to M) be the tops of the stacks. For example, after 2 calls to PushStack1 (data) that allocates elements in Stack1 followed by 1 call to PushStack2 (data) that allocates elements in Stack2, the memory that was initially all free blocks now has 3 allocated blocks as per the figure:</p>

<p style="text-align:center"><img src="https://gateoverflow.in/?qa=blob&qa_blobid=4029593521058460610"></p>

<p>If Stack1 was replaced by a circular queue with Front and Rear pointers, then which of the following is true regarding memory utilization?</p>

<ol style="list-style-type:upper-alpha">
	<li>you may not be able to add/push into the stack even when there are some free blocks in the memory.</li>
	<li>you may not be able to add/enqueue into the queue even when there are some free blocks in the memory.</li>
	<li>Stack and queue both can be implemented with efficient memory utilization.</li>
	<li>This implementation is not possible.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>Which of the following statements about stacks, queues, and linked lists are true?</p>

<ol style="list-style-type:upper-alpha">
	<li>Stacks and queues can be implemented using arrays.</li>
	<li>A queue allows a user to retrieve nodes using the LIFO principle, in O(1) time.</li>
	<li>Suppose we have a circular array holding only integers, and having a capacity (maximum size) of n. If the array is a circular array, then we can store more than n entries in it at any given time because we can make use of the modulus operator.</li>
	<li>Using a doubly-linked list, it is not possible to keep the nodes sorted.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <p>Consider 2 problems:</p>

<ol>
	<li>Problem 1: Given a queue Q containing n elements, transfer these items on to a stack S (initially empty) so that the front element of Q appears at the top of the stack and the order of all other items is preserved. Using enqueue and dequeue operations for the queue, and push and pop operations for the stack.</li>
	<li>Problem 2: Generate the permutations possible when using only a single stack and push and pop are the only operations allowed.</li>
</ol>

<ul>
	<li>S1: An efficient algorithm to solve problem 1 will take O(n) time and a constant amount of additional storage.</li>
	<li>S2: The no of stack permutations on a stack with n elements is equal to the number of balanced parentheses with 2n total parentheses.</li>
</ul>

<p>Which of the following is correct?</p>

<ol style="list-style-type:upper-alpha">
	<li>Only S1 is correct</li>
	<li>Only S2 is correct</li>
	<li>Both S1 and S2 are correct</li>
	<li>None of them is correct</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - <p>An SQueue is a queue implemented using two stacks. SQueue supports two operations enqueue() and dequeue().<br>
Consider a below pseudo code that implements enqueue() and dequeue() for SQueue using two stacks inbox and outbox.<br>
   nbsp;</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
Stack inbox, outbox; 
void enqueue(int item) 
    inbox.push(item);

void dequeue() 
    if (outbox.isEmpty())
    while (!inbox.isEmpty())
    outbox.push(in.pop());
    return outbox.pop();

</pre>

<p><br>
Consider the state of SQueue which is initialized with 100 items i.e. 100 enqueue operations have been performed in SQueue.</p>

<p>Which of the following(s) is/are true if we want to dequeue all elements from SQueue?</p>

<ol style="list-style-type:upper-alpha">
	<li>First dequeue() will result in a total of 200 calls to push and pop operations.</li>
	<li>Apart from the first dequeue(), each of the remaining calls to dequeue will take a total of 100 calls to push and pop operations.</li>
	<li>Total calls to push and pop were required to dequeue all 100 elements is 300.</li>
	<li>Total calls to push and pop were required to dequeue all 100 elements is 301.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - <p>Consider an array-based queue implementation. Suppose we store the following variable to implement a queue</p>

<ol>
	<li>front</li>
	<li>back</li>
	<li>SIZE of the queue (number of values <strong>currently</strong> in the queue)</li>
	<li>CAPACITY of array   nbsp; (Maximum number of elements we can put in the queue)</li>
</ol>

<p>Now, instead of storing all the above variables, we want to store fewer variables out of four variables.</p>

<p>Which of the following is/are correct options which tell sufficient variables to store to implement the queue?</p>

<ol style="list-style-type:upper-alpha">
	<li>front, back, and SIZE</li>
	<li>front, back and CAPACITY</li>
	<li>front and back</li>
	<li>front and CAPACITY</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - <p>A stack of int is implemented using an array as the following data type:</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
#define SIZE 20
typedef struct 
    int data[SIZE];
    int top;
 Stack;
</pre>

<p>Fill up the missing codes in the , and  operations of the Stack.</p>

<p>Ignore underflow or overflow of stack in case of pop and push respectively. You can assume that   nbsp;underflow or overflow are handled before calling pop or push.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
void Push(Stack *s, int d) 
    // line X

void Pop(Stack *s) 
    // line Y

int Top(Stack *s) 
    // line Z

</pre>

<ol style="list-style-type:upper-alpha">
	<li>
	<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
line X should be s-   gt;data[++s-   gt;top] = d;
</pre>
	</li>
	<li>
	<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
line Y should be –s-   gt;top;
</pre>
	</li>
	<li>
	<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
line Z should be return s-   gt;data[s-   gt;top]
</pre>
	</li>
	<li>None of these</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - <p>Suppose that we want to design a data structure called Mx-Queue that supports ONLY three   nbsp;operations as follows:</p>

<p>Enqueue(x) –   nbsp;It is a standard queue operation that equeue element x into the queue.</p>

<p>Dequeue() –   nbsp;It is a standard queue operation that dequeue   nbsp;from front of the queue.</p>

<p>FIND-MAX() –   nbsp;It is one extra operation that   nbsp;Mx-Queue   nbsp;supports which   nbsp;finds the maximum element from MX-Queue without removing it in   nbsp;O(1) time.</p>

<p>To fulfill the purpose we use one more   nbsp;auxiliary data structure along with a standard queue.</p>

<p>There are two choices of   nbsp;auxiliary data structures are available to us.   nbsp; (See figure for visual representation)</p>

<ul>
	<li>QueueStack</li>
	<li>Queue</li>
</ul>

<p>QueueStack   nbsp;is a data structure that has the special privilege of removing elements from the rear of the queue.</p>

<p>   nbsp;</p>

<p><img src="https://gateoverflow.in/?qa=blob&qa_blobid=14035886020062273095"></p>

<p>we call the following functions Insert() and Delete() to add or remove elements into or from   nbsp;Mx-Queue.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
Insert(Mx-Queue,x): 
   Enqueue(Mx-Queue, X)
   //Do something with auxiliary data structure
End


Delete(Mx-Queue): 
    x = Dequeue(Mx-Queue)
    //Do something with auxiliary data structure
    Return x 
End
</pre>

<p>One of the   nbsp;Insert or Delete works in linear time and the other one works in constant time.</p>

<p>Choose the correct option.</p>

<ul>
	<li>S1: We can implement Mx-Queue by using one   nbsp;Queue and QueueStack data Structure.</li>
	<li>S2: We can implement Mx-Queue by using two Queue data Structures.</li>
</ul>

<ol style="list-style-type:upper-alpha">
	<li>S1 is correct but S2 is incorrect</li>
	<li>S1 is incorrect but S2 is correct</li>
	<li>Both are correct</li>
	<li>Both are incorrect</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - <p>Consider the implementation of a stack of which is based on dynamic array allocation using malloc in C programming. This implementation allows us to push more elements than the current array capacity. It works as follows.</p>

<p>Suppose the array is full, then to push the next element we first allocate a new array of larger size using malloc, copy all elements to the new array, and free up the old array memory.</p>

<p>When a dynamic array-based stack becomes full, you increase the array size by the following sequence k, 2 k, 3 k, 4 k, … for some positive constant k. Which means the first time we increase the size by k, next time by 2 k, and so on.</p>

<p>If you have an empty stack that uses an array whose initial size is k, and you perform n pushes (assume that n   gt;k). What is the total cost complexity of executing n push operations?<br>
Let   nbsp;cost of expanding from k to 2 k has 2 k cost, similarly cost of expanding from 2 k to 3   nbsp;k has 3   nbsp;k cost.</p>

<ol style="list-style-type:upper-alpha">
	<li>O(n^ 2 / k)</li>
	<li>O(n / k)</li>
	<li>O(n^ 2 k)</li>
	<li>O(n k)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - <p>Given a circular array-based queue capable of holding 100 objects. Suppose the queue is initially empty, and then objects are put into the queue at the rate of 10 per minute while meantime they are processed and removed from the queue at the rate of 5 per minute. After 120 elements have been added to the queue, which of the following is true?</p>

<ol style="list-style-type:upper-alpha">
	<li>You can't add 120 elements to an array holding 100 entries.</li>
	<li>There will be 60 elements in the queue, 20 of them at the front of the array where the queue started, and 40 at the other end.</li>
	<li>There will be 60 elements in the queue, 30 of them at the front of the array where the queue started, and 30 at the other end.</li>
	<li>There will be 60 elements in the queue, 40 of them at the front of the array where the queue started, and 20 at the other end.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>Here is an <strong>INCORRECT</strong> pseudocode for the algorithm which is supposed to determine whether a sequence of parentheses is balanced:</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
Declare a character stack
while ( more input is available)

    read a character
    if ( the character is a '(' )
        push it on the stack
    else if ( the character is a ')' and the stack is not empty )
        pop a character off the stack
    else
        print "unbalanced" and exit

print "balanced"
</pre>

<p>Which of these unbalanced sequences does the above code think is balanced?</p>

<ol style="list-style-type:upper-alpha">
	<li>((())</li>
	<li>())(()</li>
	<li>(()()))</li>
	<li>(()))()</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - <p>Imagine four railroad cars positioned on the input side of the track in the figure below, numbered 1, 2, 3, and 4, from left to right. Suppose we perform the following sequence of operations (which is compatible with the direction of the arrows in the diagram and does not require cars to ”jump over” other cars):</p>

<ol start="1" style="list-style-type:lower-alpha">
	<li>move car 1 into the stack;</li>
	<li>move car 2 into the stack;</li>
	<li>move car 2 into the output;</li>
	<li>move car 3 into the stack;</li>
	<li>move car 4 into the stack;</li>
	<li>move car 4 into the output;</li>
	<li>move car 3 into the output;</li>
	<li>move car 1 into the output.</li>
</ol>

<p><strong><img src="https://lh4.googleusercontent.com/61OcLgA3dnrOmzX3SyRszs-0a0gZTZODxOFq5VLZHZ8z7iawl_qF3N7CrpJGdi272BYeod9wBgabEh9DpJAxnME7XFvZcyd1GHjCcV8kkWh9eoynvVHsKIvgqh7fgtKxEJwYoRw4sYZn0T1iDQ"></strong><br>
As a result of these operations the original order of the cars, 1234, has been changed into 2431.<br>
If there are six railroad cars numbered 123456, Which of the following statements is/are correct?</p>

<ol style="list-style-type:upper-alpha">
	<li>They can’t be permuted into the order 154623</li>
	<li>They can be permuted into the order 254613</li>
	<li>They can’t be permuted into the order 654123</li>
	<li>They can be permuted into the order 325641</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>Consider the following queue of characters, where QUEUE is a circular array which is allocated 6 memory cells with indexing starting from 1.<br>
Consider the below status of Queue where Front and Rear stores 2 and 4 respectively.<br>
<strong><img src="https://lh3.googleusercontent.com/vDjvmV30g5G-H9YRkjzaiWN58NjQVYsy9SvFfRBxQOGn_L89cc2AM7Z3NE8KWNr2fzZrB2THRA3A3Te42sCXntyR9Sf7wRDN9Ef6cvHNN4eOl972jSh3rAb205koz01Gbo5y7Lm2dV_vY98geA"></strong><br>
Five sequences of operations have been performed on the current status of queue as described below.</p>

<ol style="list-style-type:upper-roman">
	<li>‘F’ is added to the queue</li>
	<li>Two items are removed</li>
	<li>‘K’, ‘L’ and ‘M’ are added</li>
	<li>Two items are deleted</li>
	<li>‘R’ is added to the queue</li>
</ol>

<p>What will be the final value of Front and Rear respectively?</p>

<ol style="list-style-type:upper-alpha">
	<li>Front = 2, Rear = 5</li>
	<li>Front = 4, Rear = 5</li>
	<li>Front = 6, Rear = 2</li>
	<li>Front = 6, Rear = 3</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Suppose that a client performs an intermixed sequence of (queue) enqueue and dequeue operations. The enqueue operations put the integers 0 through 9 in order onto the queue; the dequeue operations print out the return value.</p>

<p>Which of the following sequence(s) could not occur?</p>

<ol style="list-style-type:upper-alpha">
	<li>0  1  2  3  4  5  6  7  8  9</li>
	<li>4  6  8  7  5  3  2  9  0  1</li>
	<li>2  5  6  7  4  8  9  3  1  0</li>
	<li>4  3  2  1  0  5  6  7  8  9</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q14</span> - <p>We have an implementation that supports the following operations on a stack (in the instructions below, s is the name of the stack).</p>

<ul>
	<li>isempty(s) : returns True if s is empty, and False otherwise.</li>
	<li>top(s) : returns the top element of the stack, but does not pop the stack; returns null if the stack is empty.</li>
	<li>push(s, x) : places x on top of the stack.</li>
	<li>pop(s) : pops the stack; does nothing if s is empty.</li>
</ul>

<p>Consider the following code:</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
push_pop (x) :
    s=empty
    for i=1 to length ( x ) :
        if ( x [i] == ’(’ ) :
            push ( s , x [ i ] )
        else :
            while ( top (s)== ’ ( ’ ) :
                pop ( s )
            end while
            push ( s , ’ ) ’ )
            push ( s , ’ ( ’ )
        end if
    end for
    while not isempty ( s ) :
        print top(s)
        pop (s)
    end while
</pre>

<p><br>
What is the output of this program when push pop(”(((()((())((((”) is executed?</p>

<ol style="list-style-type:upper-alpha">
	<li>)())((((</li>
	<li>((((())(</li>
	<li>((((()))</li>
	<li>)())(())</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q15</span> - <p>Consider the following piece of code which finds the size of the queue when the queue is implemented using a circular array. Back and front are pointers pointing to the back and front of the queue respectively, and cap is the capacity of the array.</p>

<p>Fill the return statement in the else part so that code works correctly to find the size of the queue.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
if (back    gt;= front)
    return back - front;
else
    return _______</pre>

<ol style="list-style-type:upper-alpha">
	<li>(back+cap)-front</li>
	<li>cap - (back+front)</li>
	<li>front-back</li>
	<li>cap - (back-front)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let data={'name': 'GO Classes 2024 | Weekly Quiz 22 | Stack and Queue', 'duration': '60', 'total_qs': '15', 'total_qs_one': 5, 'total_qs_two': 10, 'apti_num_qs': 0, 'technical_num_qs': 15, 'apti_marks': 0, 'technical_marks': 25, 'total_marks': 25, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 15, 'marks': 25, 'question': [{'contents': '', 'post_id': '377437', 'text': '<p>Consider the memory allocation of $\\mathrm{M}$ blocks.</p>\n\n<p>Stack$1$ growing from block $0$ up toward block $\\mathrm{M} - 1$ and Stack$2$ growing from block $\\mathrm{M}-1$ down to block $0.$</p>\n\n<p>Let Top$1$ (initialized to $-1)$ and Top$2\\; ($ initialized&nbsp;to $\\mathrm{M})$ be the tops of the stacks. For example, after $2$ calls to PushStack$1$ (data) that allocates elements in Stack$1$ followed by $1$ call to PushStack$2$ (data) that allocates elements in Stack$2,$ the memory that was initially all free blocks now has $3$ allocated blocks as per the figure:</p>\n\n<p style="text-align:center"><img alt="" height="349" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=4029593521058460610" width="644"></p>\n\n<p>If Stack$1$ was replaced by a circular queue with Front and Rear pointers, then which of the following is true regarding memory utilization?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>you may not be able to add/push into the stack even when there are some free blocks in the memory.</li>\n\t<li>you may not be able to add/enqueue into the queue even when there are some free blocks in the memory.</li>\n\t<li>Stack and queue both can be implemented with efficient memory utilization.</li>\n\t<li>This implementation is not possible.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,circular-queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377452', 'text': '<p>Which of the following statements about stacks, queues, and linked lists are true?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Stacks and queues can be implemented using arrays.</li>\n\t<li>A queue allows a user to retrieve nodes using the LIFO principle, in $\\mathrm{O}(1)$ time.</li>\n\t<li>Suppose we have a circular array holding only integers, and having a capacity (maximum size) of $n$. If the array is a circular array, then we can store more than $n$ entries in it at any given time because we can make use of the modulus operator.</li>\n\t<li>Using a doubly-linked list, it is not possible to keep the nodes sorted.</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,multiple-selects,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '375819', 'text': '<p>Consider $2$ problems:</p>\n\n<ol>\n\t<li>Problem $1:$ Given a queue $\\text{Q}$ containing $n$ elements, transfer these items on to a stack $\\text{S}$ (initially empty) so that the front element of $\\text{Q}$ appears at the top of the stack and the order of all other items is preserved. Using enqueue and dequeue operations for the queue, and push and pop operations for the stack.</li>\n\t<li>Problem $2:$ Generate the permutations possible when using only a single stack and push and pop are the only operations allowed.</li>\n</ol>\n\n<ul>\n\t<li>$\\text{S1}:$ An efficient algorithm to solve problem $1$ will take $O(n)$ time and a constant amount of additional storage.</li>\n\t<li>$\\text{S2}:$ The no of stack permutations on a stack with $n$ elements is equal to the number of balanced parentheses with $2n$ total parentheses.</li>\n</ul>\n\n<p>Which of the following is correct?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Only $\\text{S1}$ is correct</li>\n\t<li>Only $\\text{S2}$ is correct</li>\n\t<li>Both $\\text{S1}$ and $\\text{S2}$ are correct</li>\n\t<li>None of them is correct</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '375809', 'text': '<p>An $\\text{SQueue}$ is a queue implemented using two stacks. $\\text{SQueue}$ supports two operations enqueue() and dequeue().<br>\nConsider a below pseudo code that implements enqueue() and dequeue() for $\\text{SQueue}$ using two stacks inbox and outbox.<br>\n&nbsp;</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nStack inbox, outbox; \nvoid enqueue(int item) {\n    inbox.push(item);\n}\nvoid dequeue() {\n    if (outbox.isEmpty())\n    while (!inbox.isEmpty())\n    outbox.push(in.pop());\n    return outbox.pop();\n}\n</pre>\n\n<p><br>\nConsider the state of $\\text{SQueue}$ which is initialized with $100$ items i.e. $100$ enqueue operations have been performed in $\\text{SQueue}$.</p>\n\n<p>Which of the following(s) is/are true if we want to dequeue all elements from $\\text{SQueue}?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>First dequeue() will result in a total of $200$ calls to push and pop operations.</li>\n\t<li>Apart from the first dequeue(), each of the remaining calls to dequeue will take a total of $100$ calls to push and pop operations.</li>\n\t<li>Total calls to push and pop were required to dequeue all $100$ elements is $300.$</li>\n\t<li>Total calls to push and pop were required to dequeue all $100$ elements is $301.$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'c', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,multiple-selects,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377447', 'text': '<p>Consider an array-based queue implementation. Suppose we store the following variable to implement a queue</p>\n\n<ol>\n\t<li>front</li>\n\t<li>back</li>\n\t<li>SIZE of the queue (number of values <strong>currently</strong> in the queue)</li>\n\t<li>CAPACITY of array&nbsp; (Maximum number of elements we can put in the queue)</li>\n</ol>\n\n<p>Now, instead of storing all the above variables, we want to store fewer variables out of four variables.</p>\n\n<p>Which of the following is/are correct options which tell sufficient variables to store to implement the queue?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>front, back, and SIZE</li>\n\t<li>front, back and CAPACITY</li>\n\t<li>front and back</li>\n\t<li>front and CAPACITY</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,multiple-selects,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '375813', 'text': '<p>A stack of int is implemented using an array as the following data type:</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\n#define SIZE 20\ntypedef struct {\n    int data[SIZE];\n    int top;\n} Stack;\n</pre>\n\n<p>Fill up the missing codes in the $\\textsf{PUSH, POP},$ and $\\textsf{TOP}$ operations of the Stack.</p>\n\n<p>Ignore underflow or overflow of stack in case of pop and push respectively. You can assume that&nbsp;underflow or overflow are handled before calling pop or push.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nvoid Push(Stack *s, int d) {\n    // line X\n}\nvoid Pop(Stack *s) {\n    // line Y\n}\nint Top(Stack *s) {\n    // line Z\n}\n</pre>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>\n\t<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nline X should be s-&gt;data[++s-&gt;top] = d;\n</pre>\n\t</li>\n\t<li>\n\t<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nline Y should be --s-&gt;top;\n</pre>\n\t</li>\n\t<li>\n\t<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nline Z should be return s-&gt;data[s-&gt;top]\n</pre>\n\t</li>\n\t<li>None of these</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b;c', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,multiple-selects,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377434', 'text': '<p>Suppose that we want to design a data structure called Mx-Queue that supports ONLY three&nbsp;operations as follows:</p>\n\n<p>Enqueue(x) –&nbsp;It is a standard queue operation that equeue element x into the queue.</p>\n\n<p>Dequeue() –&nbsp;It is a standard queue operation that dequeue&nbsp;from front of the queue.</p>\n\n<p>FIND-MAX() –&nbsp;It is one extra operation that&nbsp;Mx-Queue&nbsp;supports which&nbsp;finds the maximum element from MX-Queue without removing it in&nbsp;$\\mathrm{O}(1)$ time.</p>\n\n<p>To fulfill the purpose we use one more&nbsp;auxiliary data structure along with a standard queue.</p>\n\n<p>There are two choices of&nbsp;auxiliary data structures are available to us.&nbsp; (See figure for visual representation)</p>\n\n<ul>\n\t<li>QueueStack</li>\n\t<li>Queue</li>\n</ul>\n\n<p>QueueStack&nbsp;is a data structure that has the special privilege of removing elements from the rear of the queue.</p>\n\n<p>&nbsp;</p>\n\n<p><img alt="" height="513" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=14035886020062273095" width="486"></p>\n\n<p>we call the following functions Insert() and Delete() to add or remove elements into or from&nbsp;Mx-Queue.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nInsert(Mx-Queue,x): \n   Enqueue(Mx-Queue, X)\n   //Do something with auxiliary data structure\nEnd\n\n\nDelete(Mx-Queue): \n    x = Dequeue(Mx-Queue)\n    //Do something with auxiliary data structure\n    Return x \nEnd\n</pre>\n\n<p>One of the&nbsp;Insert or Delete works in linear time and the other one works in constant time.</p>\n\n<p>Choose the correct option.</p>\n\n<ul>\n\t<li>$\\text{S1}:$ We can implement Mx-Queue by using one&nbsp;Queue and QueueStack data Structure.</li>\n\t<li>$\\text{S2}:$ We can implement Mx-Queue by using two Queue data Structures.</li>\n</ul>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{S1}$ is correct but $\\text{S2}$ is incorrect</li>\n\t<li>$\\text{S1}$ is incorrect but $\\text{S2}$ is correct</li>\n\t<li>Both are correct</li>\n\t<li>Both are incorrect</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'A', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377441', 'text': '<p>Consider the implementation of a stack of which is based on dynamic array allocation using malloc in C programming. This implementation allows us to push more elements than the current array capacity. It works as follows.</p>\n\n<p>Suppose the array is full, then to push the next element we first allocate a new array of larger size using malloc, copy all elements to the new array, and free up the old array memory.</p>\n\n<p>When a dynamic array-based stack becomes full, you increase the array size by the following sequence $k, 2 k, 3 k, 4 k, \\dots$ for some positive constant $k$. Which means the first time we increase the size by $k$, next time by $2 k$, and so on.</p>\n\n<p>If you have an empty stack that uses an array whose initial size is $k$, and you perform $n$ pushes (assume that $n&gt;k)$. What is the total cost complexity of executing n push operations?<br>\nLet&nbsp;cost of expanding from $k$ to $2 k$ has $2 k$ cost, similarly cost of expanding from $2 k$ to $3&nbsp;k$ has $3&nbsp;k$ cost.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$O\\left(n^ 2 / k\\right)$</li>\n\t<li>$O(n / k)$</li>\n\t<li>$O\\left(n^ 2 k\\right)$</li>\n\t<li>$O(n k)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,time-complexity,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377438', 'text': '<p>Given a circular array-based queue capable of holding $100$ objects. Suppose the queue is initially empty, and then objects are put into the queue at the rate of $10$ per minute while meantime they are processed and removed from the queue at the rate of $5$ per minute. After $120$ elements have been added to the queue, which of the following is true?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>You can\'t add $120$ elements to an array holding $100$ entries.</li>\n\t<li>There will be $60$ elements in the queue, $20$ of them at the front of the array where the queue started, and $40$ at the other end.</li>\n\t<li>There will be $60$ elements in the queue, $30$ of them at the front of the array where the queue started, and $30$ at the other end.</li>\n\t<li>There will be $60$ elements in the queue, $40$ of them at the front of the array where the queue started, and $20$ at the other end.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,circular-queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '375837', 'text': '<p>Here is an <strong>INCORRECT</strong> pseudocode for the algorithm which is supposed to determine whether a sequence of parentheses is balanced:</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nDeclare a character stack\nwhile ( more input is available)\n{\n    read a character\n    if ( the character is a \'(\' )\n        push it on the stack\n    else if ( the character is a \')\' and the stack is not empty )\n        pop a character off the stack\n    else\n        print "unbalanced" and exit\n}\nprint "balanced"\n</pre>\n\n<p>Which of these unbalanced sequences does the above code think is balanced?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$((())$</li>\n\t<li>$())(()$</li>\n\t<li>$(()()))$</li>\n\t<li>$(()))()$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '375827', 'text': '<p>Imagine four railroad cars positioned on the input side of the track in the figure below, numbered $1, 2, 3,$ and $4,$ from left to right. Suppose we perform the following sequence of operations (which is compatible with the direction of the arrows in the diagram and does not require cars to ”jump over” other cars):</p>\n\n<ol start="1" style="list-style-type:lower-alpha">\n\t<li>move car $1$ into the stack;</li>\n\t<li>move car $2$ into the stack;</li>\n\t<li>move car $2$ into the output;</li>\n\t<li>move car $3$ into the stack;</li>\n\t<li>move car $4$ into the stack;</li>\n\t<li>move car $4$ into the output;</li>\n\t<li>move car $3$ into the output;</li>\n\t<li>move car $1$ into the output.</li>\n</ol>\n\n<p><strong><img alt="" height="387" src="https://lh4.googleusercontent.com/61OcLgA3dnrOmzX3SyRszs-0a0gZTZODxOFq5VLZHZ8z7iawl_qF3N7CrpJGdi272BYeod9wBgabEh9DpJAxnME7XFvZcyd1GHjCcV8kkWh9eoynvVHsKIvgqh7fgtKxEJwYoRw4sYZn0T1iDQ" width="624"></strong><br>\nAs a result of these operations the original order of the cars, $1234,$ has been changed into $2431.$<br>\nIf there are six railroad cars numbered $123456,$ Which of the following statements is/are correct?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>They can’t be permuted into the order $154623$</li>\n\t<li>They can be permuted into the order $254613$</li>\n\t<li>They can’t be permuted into the order $654123$</li>\n\t<li>They can be permuted into the order $325641$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;c;d', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,moderate,multiple-selects,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '375814', 'text': '<p>Consider the following queue of characters, where QUEUE is a circular array which is allocated $6$ memory cells with indexing starting from $1.$<br>\nConsider the below status of Queue where Front and Rear stores $2$ and $4$ respectively.<br>\n<strong><img alt="" height="124" src="https://lh3.googleusercontent.com/vDjvmV30g5G-H9YRkjzaiWN58NjQVYsy9SvFfRBxQOGn_L89cc2AM7Z3NE8KWNr2fzZrB2THRA3A3Te42sCXntyR9Sf7wRDN9Ef6cvHNN4eOl972jSh3rAb205koz01Gbo5y7Lm2dV_vY98geA" width="534"></strong><br>\nFive sequences of operations have been performed on the current status of queue as described below.</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>$\\text{‘F’}$ is added to the queue</li>\n\t<li>Two items are removed</li>\n\t<li>$\\text{‘K’, ‘L’}$ and $\\text{‘M’}$ are added</li>\n\t<li>Two items are deleted</li>\n\t<li>$\\text{‘R’}$ is added to the queue</li>\n</ol>\n\n<p>What will be the final value of Front and Rear respectively?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Front $= 2,$ Rear $= 5$</li>\n\t<li>Front $= 4,$ Rear $= 5$</li>\n\t<li>Front $= 6,$ Rear $= 2$</li>\n\t<li>Front $= 6,$ Rear $= 3$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377449', 'text': '<p>Suppose that a client performs an intermixed sequence of (queue) enqueue and dequeue operations. The enqueue operations put the integers $0$ through $9$ in order onto the queue; the dequeue operations print out the return value.</p>\n\n<p>Which of the following sequence(s) could not occur?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$0\\; 1\\; 2\\; 3\\; 4\\; 5\\; 6\\; 7\\; 8\\; 9$</li>\n\t<li>$4\\; 6\\; 8\\; 7\\; 5\\; 3\\; 2\\; 9\\; 0\\; 1$</li>\n\t<li>$2\\; 5\\; 6\\; 7\\; 4\\; 8\\; 9\\; 3\\; 1\\; 0$</li>\n\t<li>$4\\; 3\\; 2\\; 1\\; 0\\; 5\\; 6\\; 7\\; 8\\; 9$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b;c;d', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,multiple-selects,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '375815', 'text': '<p>We have an implementation that supports the following operations on a stack (in the instructions below, $s$ is the name of the stack).</p>\n\n<ul>\n\t<li>$\\text{isempty(s) :}$ returns True if $s$ is empty, and False otherwise.</li>\n\t<li>$\\text{top(s) :}$ returns the top element of the stack, but does not pop the stack; returns null if the stack is empty.</li>\n\t<li>$\\text{push(s, x) :}$ places $x$ on top of the stack.</li>\n\t<li>$\\text{pop(s) :}$ pops the stack; does nothing if $s$ is empty.</li>\n</ul>\n\n<p>Consider the following code:</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\npush_pop (x) :\n    s=empty\n    for i=1 to length ( x ) :\n        if ( x [i] == ’(’ ) :\n            push ( s , x [ i ] )\n        else :\n            while ( top (s)== ’ ( ’ ) :\n                pop ( s )\n            end while\n            push ( s , ’ ) ’ )\n            push ( s , ’ ( ’ )\n        end if\n    end for\n    while not isempty ( s ) :\n        print top(s)\n        pop (s)\n    end while\n</pre>\n\n<p><br>\nWhat is the output of this program when $\\text{push pop(”(((()((())((((”)}$ is executed?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$)())(((($</li>\n\t<li>$((((())($</li>\n\t<li>$((((()))$</li>\n\t<li>$)())(())$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377446', 'text': '<p>Consider the following piece of code which finds the size of the queue when the queue is implemented using a circular array. Back and front are pointers pointing to the back and front of the queue respectively, and cap is the capacity of the array.</p>\n\n<p>Fill the return statement in the else part so that code works correctly to find the size of the queue.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nif (back &gt;= front)\n    return back - front;\nelse\n    return _______</pre>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>(back$+$cap)$-$front</li>\n\t<li>cap $-$ (back$+$front)</li>\n\t<li>front$-$back</li>\n\t<li>cap $-$ (back$-$front)</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,1-mark', 'category': 'DS'}]}]}
      </script>
      