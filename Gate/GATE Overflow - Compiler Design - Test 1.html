<div><span>Q1</span> - <p>If we merge states in LR(1) parser to form a LALR(1) parser, we may introduce</p>

<ol style="list-style-type:upper-alpha">
	<li>shift-reduce conflict</li>
	<li>reduce-reduce conflict</li>
	<li>no extra conflict</li>
	<li>both shift-reduce as well as reduce-reduce</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>Suppose we have a rightmost derivation which proceeds as follows:<br>
[         S     amp;→ amp; Aabw;              amp; →   amp;ABw ]<br>
Which of the following is a possible handle for it?</p>

<ol style="list-style-type:upper-alpha">
	<li>[       A   amp;→ amp; ab ]</li>
	<li>[      A  amp;→ amp; a  nbsp; ]</li>
	<li>[      S  amp;→ amp; A  nbsp; ]</li>
	<li>[       B   amp;→ amp; ab ]</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <p>Which of the following statements is FALSE?</p>

<ol style="list-style-type:upper-alpha">
	<li>Any DCFL has an equivalent grammar that can be parsed by a SLR(1) parser with end string delimiter</li>
	<li>Languages of grammars parsed by LR(2) parsers is a strict super set of the languages of grammars parsed by LR(1) parsers</li>
	<li>Languages of grammars parsed by LL(2) parsers is a strict super set of the languages of grammars parsed by LL(1) parsers</li>
	<li>There is no DCFL which is not having a grammar that can be parsed by a LR(1) parser</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - Which of the following statements is FALSE?<br />
<ol style="list-style-type:upper-alpha"><li>  In a SLR(1) parser, it is allowable for both shift and reduce items to be in the same state<br /> </li><li>  In a SLR(1) parser, it is allowable for multiple reduce items to be in the same state<br /> </li> <li> All SLR(1) grammars are LR(0)<br /> </li>  <li> All LR(0) grammars are SLR(1)  </li></ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - <p>Which of the following statements regarding LR(0) parser is FALSE?</p>

<ol style="list-style-type:upper-alpha">
	<li>A LR(0)   nbsp;configurating set cannot have multiple reduce items</li>
	<li>A LR(0)   nbsp;configurating set cannot have   nbsp; both shift as   nbsp;well as reduce items</li>
	<li>If a reduce item is present in a LR(0)   nbsp;configurating set it cannot have any other item</li>
	<li>A LR(0) parser can parse any regular grammar</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - Which of the following sentences is CORRECT?<br />
<ol style="list-style-type:upper-alpha"><li>  A top-down parse produces a leftmost derivation of a sentence<br /> </li><li>  A bottom-up parse produces a rightmost derivation of a sentence<br /> </li> <li> A top-down parse produces a rightmost derivation of a sentence<br /> </li>  <li> A bottom-up parse produces a leftmost derivation of a sentence  </li></ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - <p>Which of the following is a requirement for an LL(1) grammar?</p>

<ol style="list-style-type:upper-roman">
	<li>Unambiguity</li>
	<li>No left recursion</li>
	<li>If A →α|β are two productions, then FIRST(α) and FIRST(β) are disjoint<br>
	   nbsp;
	<ol style="list-style-type:upper-alpha">
		<li>(i) and (ii)</li>
		<li>(iii)</li>
		<li>(i), (ii) and (iii)</li>
		<li>(ii) and (iii)</li>
	</ol>
	</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - <p>Which of the following sentences regarding Viable prefixes is/are CORRECT?</p>

<ol style="list-style-type:upper-roman">
	<li>Viable prefixes is the set of prefixes of right-sentential forms that can appear on the stack of a shift-reduce parser</li>
	<li>Viable prefixes is the set of prefixes of right-sentential forms that do not extend past the end of the right-most handle</li>
	<li>Viable prefixes can be recognized using a DFA<br>
	   nbsp;
	<ol style="list-style-type:upper-alpha">
		<li>Only (i)</li>
		<li>Only (ii)</li>
		<li>Only (i) and (ii)</li>
		<li>(i), (ii) and (iii)</li>
	</ol>
	</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - For which of the following languages a LL(1) grammar does not exist?<br />
<ol style="list-style-type:upper-alpha"><li>  {a^n o b^n | n ≥ 1}∪{ a^n    nbsp;b^n| n ≥ 1 }<br /> </li><li>  { a^n b^m | m,n ≥ 0 }<br /> </li> <li> {a^ib^j| i≥ j}<br /> </li>  <li> {a^ib^j| i= j}  </li></ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>Which of the following is TRUE regarding LL(0) grammar?</p>

<ol style="list-style-type:upper-alpha">
	<li>We can have a LL(0) grammar for any regular language</li>
	<li>We can have a LL(0) grammar for a regular language only if it does not contain empty string</li>
	<li>We can have a LL(0) grammar for any regular language if and   nbsp;only if it has prefix property</li>
	<li>We can have a LL(0) grammar for only single string languages</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - Which of the following is TRUE regarding the running time of a LR(1) parser?<br />
<ol style="list-style-type:upper-alpha"><li>  It runs in linear time for all inputs<br /> </li><li>  It runs in polynomial time but not necessarily O(n^3) for all inputs<br /> </li> <li> For some inputs it may take exponential time<br /> </li>  <li> It runs in O(n^3) but not always O(n^2)  </li></ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>Which of the following statements regarding LR parsers is WRONG?</p>

<ol style="list-style-type:upper-roman">
	<li>LR(1) does no guess work</li>
	<li>LR parsers can handle a large range of grammars than predictive   nbsp;parsers</li>
	<li>LR parsers can handle a large range of languages than predictive   nbsp;parsers</li>
	<li>LR parser is better at error reporting compared to LL ones<br>
	   nbsp;
	<ol style="list-style-type:upper-alpha">
		<li>Only (i)</li>
		<li>(i) and (iv)</li>
		<li>Only (iv)</li>
		<li>All are CORRECT</li>
	</ol>
	</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Match the following:<br>

    [                    (i)              amp;LL(1)                amp;(A)         amp; bottom-up;                   (ii) amp; Recursive Descent               amp; (B)         amp;Predictive;                  (iii)   amp;Recursive Ascent               amp; (C)          amp; Top-down;                   (iv)              amp;LR(1)                amp;(D) amp; Deterministic CFL;                        ]
</p>

<ol style="list-style-type:upper-alpha">
	<li>i-b; ii-c; iii-a; iv-d<br>
	   nbsp;</li>
	<li>i-d; ii-a; iii-c; iv-d<br>
	   nbsp;</li>
	<li>i-c; ii-b; iii-d; iv-a<br>
	   nbsp;</li>
	<li>i-a; ii-c; iii-b; iv-d</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q14</span> - Which of the below relations does hold TRUE regarding GRAMMARS?<br />
<ol style="list-style-type:upper-alpha"><li>  LL(1) ⊂ SLR(1) ⊂ LR(1)<br /> </li><li>  SLR(1) ⊂ϵ-free  LL(1) ⊂ LR(1)<br /> </li> <li> ϵ-free LL(1) ⊂ SLR(1) ⊂ LR(1)<br /> </li>  <li> LL(1) ⊂ SLR(1) = LR(1)  </li></ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let data={'name': 'GATE Overflow | Compiler Design | Test 1', 'duration': '45', 'total_qs': '14', 'total_qs_one': 0, 'total_qs_two': 14, 'apti_num_qs': 0, 'technical_num_qs': 14, 'apti_marks': 0, 'technical_marks': 28, 'total_marks': 28, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 14, 'marks': 28, 'question': [{'contents': '', 'post_id': '299825', 'text': '<p>If we merge states in LR(1) parser to form a LALR(1) parser, we may introduce</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>shift-reduce conflict</li>\n\t<li>reduce-reduce conflict</li>\n\t<li>no extra conflict</li>\n\t<li>both shift-reduce as well as reduce-reduce</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1,compiler-design,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299824', 'text': '<p>Suppose we have a rightmost derivation which proceeds as follows:<br>\n$\\begin{array}{ccc}S &amp;\\rightarrow &amp; Aabw \\\\ &amp; \\rightarrow &amp;ABw \\end{array}$<br>\nWhich of the following is a possible handle for it?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\begin{array}{ccc} A &amp;\\rightarrow &amp; ab \\end{array}$</li>\n\t<li>$\\begin{array}{ccc} A &amp;\\rightarrow &amp; a&nbsp;\\end{array}$</li>\n\t<li>$\\begin{array}{ccc} S &amp;\\rightarrow &amp; A&nbsp;\\end{array}$</li>\n\t<li>$\\begin{array}{ccc} B &amp;\\rightarrow &amp; ab \\end{array}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1,lr-parser', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299823', 'text': '<p>Which of the following statements is FALSE?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Any DCFL has an equivalent grammar that can be parsed by a SLR(1) parser with end string delimiter</li>\n\t<li>Languages of grammars parsed by LR(2) parsers is a strict super set of the languages of grammars parsed by LR(1) parsers</li>\n\t<li>Languages of grammars parsed by LL(2) parsers is a strict super set of the languages of grammars parsed by LL(1) parsers</li>\n\t<li>There is no DCFL which is not having a grammar that can be parsed by a LR(1) parser</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299822', 'text': 'Which of the following statements is FALSE?<br />\n<ol style="list-style-type:upper-alpha"><li>  In a SLR(1) parser, it is allowable for both shift and reduce items to be in the same state<br /> </li><li>  In a SLR(1) parser, it is allowable for multiple reduce items to be in the same state<br /> </li> <li> All SLR(1) grammars are LR(0)<br /> </li>  <li> All LR(0) grammars are SLR(1)  </li></ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299820', 'text': '<p>Which of the following statements regarding $LR(0)$ parser is FALSE?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>A $LR(0)$&nbsp;configurating set cannot have multiple reduce items</li>\n\t<li>A $LR(0)$&nbsp;configurating set cannot have&nbsp; both shift as&nbsp;well as reduce items</li>\n\t<li>If a reduce item is present in a $LR(0)$&nbsp;configurating set it cannot have any other item</li>\n\t<li>A $LR(0)$ parser can parse any regular grammar</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1,parsing,lr-parser', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299818', 'text': 'Which of the following sentences is CORRECT?<br />\n<ol style="list-style-type:upper-alpha"><li>  A top-down parse produces a leftmost derivation of a sentence<br /> </li><li>  A bottom-up parse produces a rightmost derivation of a sentence<br /> </li> <li> A top-down parse produces a rightmost derivation of a sentence<br /> </li>  <li> A bottom-up parse produces a leftmost derivation of a sentence  </li></ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299817', 'text': '<p>Which of the following is a requirement for an LL(1) grammar?</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>Unambiguity</li>\n\t<li>No left recursion</li>\n\t<li>If $A \\to \\alpha \\mid \\beta$ are two productions, then $FIRST(\\alpha)$ and $FIRST(\\beta)$ are disjoint<br>\n\t&nbsp;\n\t<ol style="list-style-type:upper-alpha">\n\t\t<li>(i) and (ii)</li>\n\t\t<li>(iii)</li>\n\t\t<li>(i), (ii) and (iii)</li>\n\t\t<li>(ii) and (iii)</li>\n\t</ol>\n\t</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1,ll-parser', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299816', 'text': '<p>Which of the following sentences regarding Viable prefixes is/are CORRECT?</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>Viable prefixes is the set of prefixes of right-sentential forms that can appear on the stack of a shift-reduce parser</li>\n\t<li>Viable prefixes is the set of prefixes of right-sentential forms that do not extend past the end of the right-most handle</li>\n\t<li>Viable prefixes can be recognized using a DFA<br>\n\t&nbsp;\n\t<ol style="list-style-type:upper-alpha">\n\t\t<li>Only (i)</li>\n\t\t<li>Only (ii)</li>\n\t\t<li>Only (i) and (ii)</li>\n\t\t<li>(i), (ii) and (iii)</li>\n\t</ol>\n\t</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1,parsing,lr-parser', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299815', 'text': 'For which of the following languages a LL(1) grammar does not exist?<br />\n<ol style="list-style-type:upper-alpha"><li>  $\\{a^n o b^n \\mid n \\geq 1\\} \\cup \\{ a^n &nbsp;b^{n} \\mid n \\geq 1 \\}$<br /> </li><li>  $\\{ a^n b^m \\mid m,n \\geq 0 \\}$<br /> </li> <li> $\\{a^ib^j\\mid i\\geq j\\}$<br /> </li>  <li> $\\{a^ib^j\\mid i= j\\}$  </li></ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299814', 'text': '<p>Which of the following is TRUE regarding LL(0) grammar?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>We can have a LL(0) grammar for any regular language</li>\n\t<li>We can have a LL(0) grammar for a regular language only if it does not contain empty string</li>\n\t<li>We can have a LL(0) grammar for any regular language if and&nbsp;only if it has prefix property</li>\n\t<li>We can have a LL(0) grammar for only single string languages</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299813', 'text': 'Which of the following is TRUE regarding the running time of a LR(1) parser?<br />\n<ol style="list-style-type:upper-alpha"><li>  It runs in linear time for all inputs<br /> </li><li>  It runs in polynomial time but not necessarily $O(n^3)$ for all inputs<br /> </li> <li> For some inputs it may take exponential time<br /> </li>  <li> It runs in $O(n^3)$ but not always $O(n^2)$  </li></ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299812', 'text': '<p>Which of the following statements regarding LR parsers is WRONG?</p>\n\n<ol style="list-style-type:upper-roman">\n\t<li>LR(1) does no guess work</li>\n\t<li>LR parsers can handle a large range of grammars than predictive&nbsp;parsers</li>\n\t<li>LR parsers can handle a large range of languages than predictive&nbsp;parsers</li>\n\t<li>LR parser is better at error reporting compared to LL ones<br>\n\t&nbsp;\n\t<ol style="list-style-type:upper-alpha">\n\t\t<li>Only (i)</li>\n\t\t<li>(i) and (iv)</li>\n\t\t<li>Only (iv)</li>\n\t\t<li>All are CORRECT</li>\n\t</ol>\n\t</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1,lr-parser', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299811', 'text': '<p>Match the following:<br>\n$$\\begin{array}{|cc|cc|} \\hline (i) &amp;LL(1)&amp;(A)&amp; \\text{bottom-up} \\\\ \\hline (ii)&amp; \\text{Recursive Descent}&amp; (B) &amp;\\text{Predictive} \\\\ \\hline (iii) &amp;\\text{Recursive Ascent}&amp; (C)&amp; \\text{Top-down} \\\\ \\hline (iv) &amp;LR(1) &amp;(D)&amp; \\text{Deterministic CFL} \\\\ \\hline \\end{array}$$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>i-b; ii-c; iii-a; iv-d<br>\n\t&nbsp;</li>\n\t<li>i-d; ii-a; iii-c; iv-d<br>\n\t&nbsp;</li>\n\t<li>i-c; ii-b; iii-d; iv-a<br>\n\t&nbsp;</li>\n\t<li>i-a; ii-c; iii-b; iv-d</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1,parsing', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '299810', 'text': 'Which of the below relations does hold TRUE regarding GRAMMARS?<br />\n<ol style="list-style-type:upper-alpha"><li>  $LL(1) \\subset SLR(1) \\subset LR(1)$<br /> </li><li>  $SLR(1) \\subset \\epsilon-\\text{free}\\; LL(1) \\subset LR(1)$<br /> </li> <li> $\\epsilon-\\text{free}\\;LL(1) \\subset SLR(1) \\subset LR(1)$<br /> </li>  <li> $LL(1) \\subset SLR(1) = LR(1)$  </li></ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'go-cd-1', 'category': 'Compiler Design'}]}]}
      </script>
      