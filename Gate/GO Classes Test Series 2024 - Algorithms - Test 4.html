<div><span>Q1</span> - <p>You're working on a dynamic programming problem that has a recurrence relation A(i, j)=F(A(⌊ i / 2⌋, j), A(i,⌊ j / 2⌋)), where F is a known function that can be evaluated in constant time, and A(i, j)=0 when i=0 or j=0.</p>

<p>To compute A(m, n) for some m and n, you can use either a top-down approach (starting from A(m, n) with recursive calls) or a bottom-up approach (filling a table of size (m+1)× (n+1), beginning with A(0, 0)).</p>

<p>Which one is more efficient in solving this problem?</p>

<ol style="list-style-type:upper-alpha">
	<li>Top Down will take asymptotically lesser time than bottom up</li>
	<li>Bottom-up will take asymptotically lesser time than Top Down</li>
	<li>Both will take the same time</li>
	<li>None of them</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>Consider a DAG G=(V, E) which has topological ordering of vertices v_1, v_2, …   nbsp;,v_n. We want to count number of paths from vertex v_i to vertex v_n. Let Paths(i) represents total number of paths from i to n.</p>

<p>Complete the following recurrence for Paths(i).<br>

    <br>
    Paths(i)= 1    amp;  if  i=n
    <br>
    ?   amp;  otherwise. <br>
<br>
In options,</p>

<p>∑_j:(i, j) ∈EPaths(j) is a quantity which sums Paths(j) for all outgoing edges from i i.e., for edges i → j.</p>

<ol style="list-style-type:upper-alpha">
	<li>∑_j:(i, j) ∈E(1+Paths(j))</li>
	<li>∑_j:(i, j) ∈EPaths(j)</li>
	<li>1+∑_j:(i, j) ∈EPaths(j)</li>
	<li>1+Paths(j) for some edge i → j</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <p>Which of the following is/are Longest Common Subsequence for given two sequecnces ⟨ 1,0,0,1,0,1,0,1⟩ and ⟨ 0,1,0,1,1,0,1,1,0⟩.<br>
   nbsp;</p>

<ol style="list-style-type:upper-alpha">
	<li>{1,0,0,1,1,0}.</li>
	<li>{1,0,1,0,1,1}</li>
	<li>{1,0,1,1,0,1}</li>
	<li>{0,0,1,1,1,0}</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - <p>In bottom-up dynamic programming, we need an order to fill in the solution cells in a table, such that all needed subproblems are solved before solving a subproblem. For the following relation, give a valid traversal order.<br>

    <br>
    <br>
       amp;A(i, j)=F(A(i, j-1), A(i-1, j-1), A(i-1, j+1))
    <br>
       amp;A(0, j)=0
    <br>
       amp;A(i, 0)=0
    <br>
    <br>
<br>
Where F(.) is a function.</p>

<ol style="list-style-type:upper-alpha">
	<li>Fill values of A(i, j) column-wise, i.e., fill the first column then the second column, and so on.</li>
	<li>Fill the last column of A(i, j), then the second last column, and so on.</li>
	<li>Fill values of A(i, j) row-wise i.e. fill the first row then the second row, and so on.</li>
	<li>No order is possible as there is cyclic dependency in subproblems.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - Consider the following recurrence relation which is applicable on two arrays x and y.  x_i and y_i are the i^th elements of x and y array respectively.

    c(i, j)= 0     if  i=0  or  j=0 
    
    c(i-1, j-1)+1     if  i, j>0  and  x_i=y_j
    min (c(i-1, j), c(i, j-1))     if  i, j>0  and  x_i≠ y_j

Suppose each array is of n size and time complexity to compute c(n, n) using dynamic programming is O(n^a(log n)^ b) then what will be value of a+b?<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - <p>Consider two teams, A and B, playing a series of games until one of the teams wins n games. Assume that the probability of A winning a game is the same for each game and equal to p and the probability of A losing a game is q=1-p. (Hence, there are no ties.)</p>

<p>Let A needs i more games to win the series and B needs j more games to win the series then P(i, j) represents the probability of A finally winning the series.</p>

<p>Choose the correct recurrence relation for P(i, j).<br>
(Hint: If A wins the game then A will need i-1 more wins to win series)</p>

<ol style="list-style-type:upper-alpha">
	<li>P(i, j)=p P(i-1, j)+q P(i, j-1)</li>
	<li>P(i, j)=p P(i-1, j-1)</li>
	<li>P(i, j)=pP(i, j-1)+qP(i-1, j)</li>
	<li>P(i, j)=q P(i-1, j-1)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - Find total number of scalar multiplications of a matrix-chain product of 6 matrices whose sequence of dimensions is 5, 10, 3, 12, 5, 50 and 6. That is 5× 10 is dimension of first matrix, 10 × 3 is dimension of second matrix and so on.<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - <p>Let X=x_1 x_2⋯ x_m and Y=y_1 y_2⋯ y_n be two strings over the alphabet Σ= {A, C, G, T}<br>
A longest common subsequence (LCS) of X and Y can be found by dynamic programming. 'To compute c [i, j], where 1 ≤ i ≤ m and 1 ≤ j ≤ n, how many table entries are examined in the worst case?<br>
<br>
Where   nbsp;c [i, j] is the length of LCS of   nbsp;x_1 x_2⋯ x_i and y_1 y_2⋯ y_j.</p>

<ol style="list-style-type:upper-alpha">
	<li>2</li>
	<li>3</li>
	<li>n</li>
	<li>n+m</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - <p>An alignment between two strings w_1 and w_2    nbsp;(over the alphabet {a, b, c, …, z}) is obtained by inserting hyphens in the two strings such that the modified strings align. A mismatch in an alignment is a position where one of the modified strings has a hyphen, and the other does not.<br>

    Oc-urr-ance
 
    Occurre-nce
<br>
There are three mismatches in this example.</p>

<p>Let s[1 … m] and t[1 … n] be the two strings to be matched. Let M(i, j) be the number of mismatches in the best alignment of s[1 … i] and t[1… j].</p>

<p>Which of the following is a correct recursive formulation of M(i, j) for i, j   gt;0?</p>

<p>Note: By convention s[1 … 0] and t[1 … 0] are taken to be the empty string, so M(i, 0)=i for i ∈{1,2, …, m} and M(0, j)=j for j ∈{1,2, …, n}</p>

<ol style="list-style-type:upper-alpha">
	<li>M(i, j)=2+M(i-1, j-1), if  s[i] ≠ t[i]   nbsp;
min (M(i-1, j), M(i, j-1)),  otherwise</li>
	<li>M(i, j)=M(i-1, j-1), if  s[i]=t[j] 
min (M(i-1, j), M(i, j-1)),  otherwise   nbsp;</li>
	<li>M(i, j)=1+M(i-1, j-1), if  s[i]=t[j] 
 1+min (M(i-1, j), M(i, j-1)),  otherwise   nbsp;</li>
	<li>M(i, j)=M(i-1, j-1), if  s[i]=t[j] 
 1+min (M(i-1, j), M(i, j-1)),  otherwise   nbsp;</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>For x ≧ 0, y ≧ 0, define A(x, y) by<br>

    <br>
    <br>
       amp;A(0, y)=y+1
    <br>
       amp;A(x+1,0)=A(x, 1),  and 
    <br>
       amp;A(x+1, y+1)=A(x, A(x+1, y))<br>
    <br>
<br>
Then, for all non-negative integers y, A(1, y) is _________</p>

<ol style="list-style-type:upper-alpha">
	<li>2</li>
	<li>y+1</li>
	<li>y+2</li>
	<li>2y+3</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - <p>For the given recurrences calculate the tightest bound on time and space that would be required by a dynamic programming algorithm to compute OPT(n).<br>

    <br>
    OPT(i)=min _1 ≤ j   lt;i{OPT(j) / j+w(j)}. <br>
</p>

<p>where OPT(1)=1</p>

<ol style="list-style-type:upper-alpha">
	<li>Time =O(n^2), space =O(n).</li>
	<li>Time =O(n^3), Space =O(n^2).</li>
	<li>Time =O(n^2), Space =O(n^2).</li>
	<li>Time =O(n), Space =O(1).</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>Consider the following 0-1 knapsack problem with the item's weight and value given in the table.<br>

    [ nbsp;<br>
    item    amp; weight     amp; value;        <br>
     1         amp; 3           amp;      nbsp;₹ 25;         <br>
    2         amp; 2      amp; ₹ 20;         <br>
    3         amp; 1           amp;      nbsp;₹ 15;         <br>
    4         amp; 4           amp;      nbsp;₹ 40;         <br>
    5         amp; 5           amp;  nbsp;₹ 50<br> ]
<br>
Capacity W = 6.</p>

<p>If the capacity of the knapsack (W), is 6 then how many optimal solutions (number of set of items) are possible?</p>

<ol style="list-style-type:upper-alpha">
	<li>1</li>
	<li>2</li>
	<li>3</li>
	<li>4</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Suppose you have a row of coins with values that are positive integers c_1, …, c_n. These values might not be distinct. Your task is to pick up coins that have as much total value as possible, subject to the constraint that you don't ever pick up two coins that lie beside each other. For example - Given c_1 to c_6 as follows: (5,1,2,10,6,2), the maximum value is 17 and using coins {c_1=5, c_1=10, c_6=2} .</p>

<p>Let f(n) be maximum total value with n   nbsp;coins with f(0)=0 and f(1)=c_1 then what will be correct recurrence   nbsp; for f(n)?</p>

<ol style="list-style-type:upper-alpha">
	<li>f(n)=max(c_n+f(n-2) , f(n-1) )</li>
	<li>f(n)=max(c_n-1+f(n-2), f(n-1))</li>
	<li>f(n)=max(c_n-1+f(n-1), f(n-2))</li>
	<li>f(n)=max(c_n+f(n-1), f(n-2))</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q14</span> - <p>For a given sequence of integers a_1, a_2, …, a_n, a decreasing subsequence is one for which every integer is strictly smaller than the previous one.</p>

<p>The longest decreasing subsequence is the longest among all decreasing subsequences of a given sequence.<br>
For example, decreasing subsequences   nbsp; of 5,2,4,8,3,40 are -</p>

<ul>
	<li>5,2</li>
	<li>5,4</li>
	<li>4,3</li>
	<li>5,4,3 etc</li>
</ul>

<p>And longest among all possible decreasing subsequences is 5,4,3.<br>
For a given sequence of integers a 1, a 2, …, a_n, let L(j) be length of the longest decreasing subsequence that starts with a_j.</p>

<p>
    L(n)=1
</p>

<p>
    L(j) =   nbsp;  1    amp;  if  a_j=min(a_j, a_j+1, a_j+2, …, a_n), 
    ?   amp;  otherwise.
</p>

<p>Complete the above recurrence relation with the appropriate value of ?.</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>1+min{L(k): j   lt;k ≤ n. and .a_j   gt;a_k}</li>
	<li>1+max{L(k): j   lt;k ≤ n. and .a_j   gt;a_k}</li>
	<li>1+max{L(k): j   lt;k ≤ n. and .a_j   lt;a_k}</li>
	<li>1+min{L(k): j   lt;k ≤ n. and .a_j   lt;a_k}</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q15</span> - <p>The number of longest common subsequences for "bacb" and "abcabc" are -</p>

<ol style="list-style-type:upper-alpha">
	<li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let data={'name': 'GO Classes Test Series 2024 | Algorithms | Test 4', 'duration': '45', 'total_qs': '15', 'total_qs_one': 5, 'total_qs_two': 10, 'apti_num_qs': 0, 'technical_num_qs': 15, 'apti_marks': 0, 'technical_marks': 25, 'total_marks': 25, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 15, 'marks': 25, 'question': [{'contents': '', 'post_id': '380694', 'text': '<p>You\'re working on a dynamic programming problem that has a recurrence relation $\\text{A}(i, j)=\\text{F}(\\text{A}(\\lfloor i / 2\\rfloor, j), \\text{A}(i,\\lfloor j / 2\\rfloor))$, where $\\text{F}$ is a known function that can be evaluated in constant time, and $\\text{A}(i, j)=0$ when $i=0$ or $j=0$.</p>\n\n<p>To compute $A(m, n)$ for some $m$ and $n$, you can use either a top-down approach (starting from $A(m, n)$ with recursive calls) or a bottom-up approach (filling a table of size $(m+1)\\times (n+1)$, beginning with $A(0, 0)$).</p>\n\n<p>Which one is more efficient in solving this problem?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Top Down will take asymptotically lesser time than bottom up</li>\n\t<li>Bottom-up will take asymptotically lesser time than Top Down</li>\n\t<li>Both will take the same time</li>\n\t<li>None of them</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,recurrence-relation,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380686', 'text': '<p>Consider a DAG $\\mathrm{G}=(\\mathrm{V}, \\mathrm{E})$ which has topological ordering of vertices $v_1, v_2, \\ldots&nbsp;,v_n$. We want to count number of paths from vertex $v_i$ to vertex $v_n.$ Let $\\text{Paths}(i)$ represents total number of paths from $i$ to $n$.</p>\n\n<p>Complete the following recurrence for $\\text{Paths}(i).$<br>\n$$<br>\n\\operatorname{Paths}(i)= \\begin{cases}1 &amp; \\text { if } i=n\\\\<br>\n{\\color{Red}{?}} &amp; \\text { otherwise. }\\end{cases}<br>\n$$<br>\nIn options,</p>\n\n<p>$\\sum_{j:(i, j) \\in \\text{E}} \\operatorname{Paths}(j)$ is a quantity which sums $\\operatorname{Paths}(j)$ for all outgoing edges from $i$ i.e., for edges $i \\rightarrow j$.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\sum_{j:(i, j) \\in \\text{E}}(1+\\operatorname{Paths}(j))$</li>\n\t<li>$\\sum_{j:(i, j) \\in \\text{E}} \\operatorname{Paths}(j)$</li>\n\t<li>$1+\\sum_{j:(i, j) \\in \\text{E}} \\operatorname{Paths}(j)$</li>\n\t<li>$1+\\operatorname{Paths}(j)$ for some edge $i \\rightarrow j$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'B', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,directed-acyclic-graph,topological-sort,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380690', 'text': '<p>Which of the following is/are Longest Common Subsequence for given two sequecnces $\\langle 1,0,0,1,0,1,0,1\\rangle$ and $\\langle 0,1,0,1,1,0,1,1,0\\rangle$.<br>\n&nbsp;</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\{1,0,0,1,1,0\\}$.</li>\n\t<li>$\\{1,0,1,0,1,1\\}$</li>\n\t<li>$\\{1,0,1,1,0,1\\}$</li>\n\t<li>$\\{0,0,1,1,1,0\\}$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b;c', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,longest-common-subsequence,multiple-selects,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380692', 'text': '<p>In bottom-up dynamic programming, we need an order to fill in the solution cells in a table, such that all needed subproblems are solved before solving a subproblem. For the following relation, give a valid traversal order.<br>\n$$<br>\n\\begin{aligned}<br>\n&amp;\\text{A}(i, j)=\\mathrm{F}(\\text{A}(i, j-1), \\text{A}(i-1, j-1), \\text{A}(i-1, j+1))\\\\<br>\n&amp;\\text{A}(0, j)=0\\\\<br>\n&amp;\\text{A}(i, 0)=0\\\\<br>\n\\end{aligned}<br>\n$$<br>\nWhere $\\mathrm{F}(.)$ is a function.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Fill values of $\\text{A}(i, j)$ column-wise, i.e., fill the first column then the second column, and so on.</li>\n\t<li>Fill the last column of $\\text{A}(i, j)$, then the second last column, and so on.</li>\n\t<li>Fill values of $\\text{A}(i, j)$ row-wise i.e. fill the first row then the second row, and so on.</li>\n\t<li>No order is possible as there is cyclic dependency in subproblems.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380695', 'text': 'Consider the following recurrence relation which is applicable on two arrays $x$ and $y.\\; x_i$ and $y_i$ are the $i^{\\text{th}}$ elements of $x$ and $y$ array respectively.\n$$\nc(i, j)= \\begin{cases}0 & \\text { if } i=0 \\text { or } j=0 \\\\\nc(i-1, j-1)+1 & \\text { if } i, j>0 \\text { and } x_{i}=y_{j}\\\\\n\\min (c(i-1, j), c(i, j-1)) & \\text { if } i, j>0 \\text { and } x_{i} \\neq y_{j}\\end{cases}\n$$\nSuppose each array is of $n$ size and time complexity to compute $c(n, n)$ using dynamic programming is $ O\\left(n^{a}(\\log n)^{ b}\\right)$ then what will be value of $a+b?$', 'type': 'Numerical', 'answer': '2', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-4,numerical-answers,goclasses,algorithms,dynamic-programming,longest-common-subsequence,time-complexity,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380689', 'text': '<p>Consider two teams, $\\text{A}$ and $\\text{B}$, playing a series of games until one of the teams wins $n$ games. Assume that the probability of $\\text{A}$ winning a game is the same for each game and equal to $p$ and the probability of $\\text{A}$ losing a game is $q=1-p$. (Hence, there are no ties.)</p>\n\n<p>Let $\\text{A}$ needs $i$ more games to win the series and $\\text{B}$ needs $j$ more games to win the series then $\\mathrm{P}(i, j)$ represents the probability of $\\text{A}$ finally winning the series.</p>\n\n<p>Choose the correct recurrence relation for $\\mathrm{P}(i, j)$.<br>\n(Hint: If $\\text{A}$ wins the game then $\\text{A}$ will need $i-1$ more wins to win series)</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\mathrm{P}(i, j)=p \\mathrm{P}(i-1, j)+q \\mathrm{P}(i, j-1)$</li>\n\t<li>$\\mathrm{P}(i, j)=p \\mathrm{P}(i-1, j-1)$</li>\n\t<li>$\\mathrm{P}(i, j)=p\\mathrm{P}(i, j-1)+q\\mathrm{P}(i-1, j)$</li>\n\t<li>$\\mathrm{P}(i, j)=q \\mathrm{P}(i-1, j-1)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,probability,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380685', 'text': 'Find total number of scalar multiplications of a matrix-chain product of $6$ matrices whose sequence of dimensions is $5, 10, 3, 12, 5, 50$ and $6.$ That is $5\\times 10$ is dimension of first matrix, $10 \\times 3$ is dimension of second matrix and so on.', 'type': 'Numerical', 'answer': '2010', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-algo-4,numerical-answers,goclasses,algorithms,matrix-chain-ordering,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380691', 'text': '<p>Let $X=x_{1} x_{2} \\cdots x_{m}$ and $Y=y_{1} y_{2} \\cdots y_{n}$ be two strings over the alphabet $\\displaystyle{}\\Sigma= \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$<br>\nA longest common subsequence (LCS) of $X$ and $Y$ can be found by dynamic programming. \'To compute $c [i, j]$, where $1 \\leq i \\leq m$ and $1 \\leq j \\leq n$, how many table entries are examined in the worst case?<br>\n<br>\nWhere&nbsp;$c [i, j]$ is the length of LCS of&nbsp;$x_{1} x_{2} \\cdots x_{i}$ and $y_{1} y_{2} \\cdots y_{j}$.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2$</li>\n\t<li>$3$</li>\n\t<li>$n$</li>\n\t<li>$n+m$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'A', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,longest-common-subsequence,1-mark', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380677', 'text': '<p>An alignment between two strings $w_1$ and $w_2\\;&nbsp;($over the alphabet $\\{a, b, c, \\ldots, z\\})$ is obtained by inserting hyphens in the two strings such that the modified strings align. A mismatch in an alignment is a position where one of the modified strings has a hyphen, and the other does not.<br>\n$$\\text{Oc-urr-ance}$$ $$\\text{Occurre-nce}$$<br>\nThere are three mismatches in this example.</p>\n\n<p>Let $s[1 \\ldots m]$ and $t[1 \\ldots n]$ be the two strings to be matched. Let $\\text{M}(i, j)$ be the number of mismatches in the best alignment of $s[1 \\ldots i]$ and $t[1\\ldots j].$</p>\n\n<p>Which of the following is a correct recursive formulation of $\\text{M}(i, j)$ for $i, j&gt;0?$</p>\n\n<p>Note: By convention $s[1 \\ldots 0]$ and $t[1 \\ldots 0]$ are taken to be the empty string, so $\\text{M}(i, 0)=i$ for $i \\in\\{1,2, \\ldots, m\\}$ and $\\text{M}(0, j)=j$ for $j \\in\\{1,2, \\ldots, n\\}$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{M}(i, j)=\\begin{cases}2+\\text{M}(i-1, j-1), \\text{if } s[i] \\neq t[i]&nbsp;\\\\ \\min (\\text{M}(i-1, j), \\text{M}(i, j-1)), \\;\\text{otherwise} \\end{cases}$</li>\n\t<li>$\\text{M}(i, j)=\\begin{cases}\\text{M}(i-1, j-1), \\text{if } s[i]=t[j] \\\\ \\min (\\text{M}(i-1, j), \\text{M}(i, j-1)), \\;\\text{otherwise}&nbsp;\\end{cases}$</li>\n\t<li>$\\text{M}(i, j)=\\begin{cases}1+\\text{M}(i-1, j-1), \\text{if } s[i]=t[j] \\\\ 1+\\min (\\text{M}(i-1, j), \\text{M}(i, j-1)), \\;\\text{otherwise}&nbsp;\\end{cases}$</li>\n\t<li>$\\text{M}(i, j)=\\begin{cases}\\text{M}(i-1, j-1), \\text{if } s[i]=t[j] \\\\ 1+\\min (\\text{M}(i-1, j), \\text{M}(i, j-1)), \\;\\text{otherwise}&nbsp;\\end{cases}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,recurrence-relation,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380679', 'text': '<p>For $x \\geqq 0, y \\geqq 0$, define $A(x, y)$ by<br>\n$$<br>\n\\begin{aligned}<br>\n&amp;A(0, y)=y+1\\\\<br>\n&amp;A(x+1,0)=A(x, 1), \\text { and }\\\\<br>\n&amp;A(x+1, y+1)=A(x, A(x+1, y))<br>\n\\end{aligned}<br>\n$$<br>\nThen, for all non-negative integers $y, A(1, y)$ is _________</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2$</li>\n\t<li>$y+1$</li>\n\t<li>$y+2$</li>\n\t<li>$2y+3$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,recurrence-relation,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380682', 'text': '<p>For the given recurrences calculate the tightest bound on time and space that would be required by a dynamic programming algorithm to compute $\\text{OPT}(n).$<br>\n$$<br>\n\\text{OPT}(i)=\\min _{1 \\leq j&lt;i}\\{\\text{OPT}(j) / j+w(j)\\} \\text {. }<br>\n$$</p>\n\n<p>where $\\text{OPT}(1)=1$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Time $=O\\left(n^{2}\\right)$, space $=O(n)$.</li>\n\t<li>Time $=O\\left(n^{3}\\right)$, Space $=O\\left(n^{2}\\right)$.</li>\n\t<li>Time $=O\\left(n^{2}\\right)$, Space $=O\\left(n^{2}\\right)$.</li>\n\t<li>Time $=O(n)$, Space $=O(1)$.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'D', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,time-complexity,space-complexity,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380688', 'text': '<p>Consider the following $0-1$ knapsack problem with the item\'s weight and value given in the table.<br>\n$$\\begin{array}{c|cc}&nbsp;<br>\n\\text{item} &amp; \\text{weight} &amp; \\text{value} \\\\<br>\n\\hline 1 &amp; 3 &amp;&nbsp;\\text{₹} 25 \\\\<br>\n2 &amp; 2 &amp; \\text{₹} 20 \\\\<br>\n3 &amp; 1 &amp;&nbsp;\\text{₹} 15 \\\\<br>\n4 &amp; 4 &amp;&nbsp;\\text{₹} 40 \\\\<br>\n5 &amp; 5 &amp;&nbsp;\\text{₹} 50<br>\n\\end{array}$$<br>\n$\\text{Capacity W = 6}.$</p>\n\n<p>If the capacity of the knapsack $(W),$ is $6$ then how many optimal solutions (number of set of items) are possible?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1$</li>\n\t<li>$2$</li>\n\t<li>$3$</li>\n\t<li>$4$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,knapsack-problem,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380681', 'text': '<p>Suppose you have a row of coins with values that are positive integers $c_{1}, \\ldots, c_{n}$. These values might not be distinct. Your task is to pick up coins that have as much total value as possible, subject to the constraint that you don\'t ever pick up two coins that lie beside each other. For example - Given $c_{1}$ to $c_{6}$ as follows: $(5,1,2,10,6,2)$, the maximum value is $17$ and using coins $\\left\\{c_{1}=5, c_{1}=10, c_{6}=2\\right\\}$ .</p>\n\n<p>Let $f(n)$ be maximum total value with $n$&nbsp;coins with $f(0)=0$ and $f(1)=c_{1}$ then what will be correct recurrence&nbsp; for $f(n)?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$f(n)=\\max \\left(c_{n}+f(n-2) , f(n-1) \\right)$</li>\n\t<li>$f(n)=\\max \\left(c_{n-1}+f(n-2), f(\\mathrm{n}-1)\\right)$</li>\n\t<li>$f(n)=\\max \\left(c_{n-1}+f(n-1), f(n-2)\\right)$</li>\n\t<li>$f(n)=\\max \\left(c_{n}+f(n-1), f(n-2)\\right)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,recurrence-relation,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380687', 'text': '<p>For a given sequence of integers $a_1, a_2, \\ldots, a_n,$ a decreasing subsequence is one for which every integer is strictly smaller than the previous one.</p>\n\n<p>The longest decreasing subsequence is the longest among all decreasing subsequences of a given sequence.<br>\nFor example, decreasing subsequences&nbsp; of $5,2,4,8,3,40$ are -</p>\n\n<ul>\n\t<li>$5,2$</li>\n\t<li>$5,4$</li>\n\t<li>$4,3$</li>\n\t<li>$5,4,3$ etc</li>\n</ul>\n\n<p>And longest among all possible decreasing subsequences is $5,4,3$.<br>\nFor a given sequence of integers $a 1, a 2, \\ldots, a_{n}$, let $\\mathrm{\\text{L}}(j)$ be length of the longest decreasing subsequence that starts with $a_j.$</p>\n\n<p>$$\\text{L}(n)=1 $$</p>\n\n<p>$$\\text{L}(j) =&nbsp; \\begin{cases} 1 &amp; \\text { if } a_{j}=\\min \\left(a_{j}, a_{j+1}, a_{j+2}, \\ldots, a_{n}\\right), \\\\ {\\color{Red}{?}} &amp; \\text { otherwise. }\\end{cases} $$</p>\n\n<p>Complete the above recurrence relation with the appropriate value of ${\\color{Red}{?}}.$</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$1+\\min \\left\\{\\text{L}(k): j&lt;k \\leq n\\right.$ and $\\left.a_{j}&gt;a_{k}\\right\\}$</li>\n\t<li>$1+\\max \\left\\{\\text{L}(k): j&lt;k \\leq n\\right.$ and $\\left.a_{j}&gt;a_{k}\\right\\}$</li>\n\t<li>$1+\\max \\left\\{\\text{L}(k): j&lt;k \\leq n\\right.$ and $\\left.a_{j}&lt;a_{k}\\right\\}$</li>\n\t<li>$1+\\min \\left\\{\\text{L}(k): j&lt;k \\leq n\\right.$ and $\\left.a_{j}&lt;a_{k}\\right\\}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,longest-common-subsequence,2-marks', 'category': 'Algorithms'}, {'contents': '', 'post_id': '380683', 'text': '<p>The number of longest common subsequences for "$bacb$" and "$abcabc$" are -</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$2$</li>\n\t<li>$3$</li>\n\t<li>$4$</li>\n\t<li>$5$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-algo-4,goclasses,algorithms,dynamic-programming,longest-common-subsequence,2-marks', 'category': 'Algorithms'}]}]}
      </script>
      