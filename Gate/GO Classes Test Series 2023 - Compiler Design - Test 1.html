<div><span>Q1</span> - <p>In LR(1) parsing, what constitutes a shift/reduce conflict?</p>

<ol style="list-style-type:upper-alpha">
	<li>A DFA state contains both LR items allowing shift and reduce for the different lookahead.</li>
	<li>A DFA state contains both LR items allowing shift and reduce for the same lookahead.</li>
	<li>A DFA state contains both LR items allowing shifts for the same lookahead.</li>
	<li>A DFA state contains both LR items allowing shifts for the different lookahead.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>In LR parsing, Given an LR(k) item [A→α∙γ, δ], what lookahead allows a shift to be performed (ignoring any other LR(k) items added to the state by closure)?</p>

<ol style="list-style-type:upper-alpha">
	<li>The terminal at the beginning of γ.</li>
	<li>The terminal at the ending of α.</li>
	<li>The terminal at the beginning of α.</li>
	<li>The terminal at the beginning of δ.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <p>Consider the following sets of LR(1) items in the states of a LR(1) parser for some grammar G.<br>

    <br>
    [     <br>
     State 0:     amp;  State 2:;     <br>
    [A→∙a, b]     amp; [A→∙a, c];     <br>
    [A→a∙, c]     amp; [A→a∙, b];     <br>
    [B→a∙, b] amp; [B→a∙, a]<br> ]<br>
<br>

    <br>
    [  <br>
     State 1: amp;  State  3:;  <br>
    [A→∙a, a]  amp; [A→∙a, b];  <br>
    [A→∙a, b]  amp; [B→∙a, b];  <br>
    [B→a∙, b]        amp;<br> ]<br>
<br>
Which of the following is true for the given set of LR1 items and the given LR1 parser (Assume the parser has only the given set of LR1 items for G)?</p>

<ol style="list-style-type:upper-alpha">
	<li>G is LR1.</li>
	<li>G is not LR1 because reduce/reduce conflict is caused by [A→a∙, c] and [B→a∙, b] in state 1.</li>
	<li>G is not LR1 because Shift/reduce conflict is caused by [A→∙a, c] and [B→a∙, a] on lookahead a in state 2.</li>
	<li>G is not LR1 because Shift/shift conflict is caused by [A→∙a, b] and [B→∙   nbsp;a, b] on lookahead a in state 3.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - <p>Which of the following is true about the relationship between LALR(1) and SLR(1) parsers?</p>

<ol style="list-style-type:upper-alpha">
	<li>There are grammars that can be parsed by SLR(1) parsers that cannot be parsed by LALR(1) parsers.</li>
	<li>There are grammars that can be parsed by LALR(1) parsers that cannot be parsed by SLR(1) parsers.</li>
	<li>LALR(1) parsers are as powerful as SLR(1) parsers, so any grammar that can be parsed by an LALR(1) parser can be parsed by a SLR(1) parser.</li>
	<li>For any grammar G which can be parsed by a SLR(1) parser, number of states in the SLR(1) parser can be less than number of states in the LALR(1) parser for G.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - <p>In SLR parsing to get a shift-reduce conflict for state I on terminal symbol ' a ',</p>

<ol style="list-style-type:upper-alpha">
	<li>A→α . β with First ( β) containing ' a ' should be in I</li>
	<li>A→δ. be in I with Follow(A) having ' a '</li>
	<li>A→α . aβ   nbsp;should be in I and X→δ. be in I with Follow (X) having ' a '</li>
	<li>None of the other options</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - <p>Consider the following sets of LR(1) items in the states of a LR(1) parser.<br>

    <br>
    [     <br>
     State 0:     amp;  State 2:;     <br>
    [A→∙a, b]     amp; [A→∙a, c];     <br>
    [A→a∙, c]     amp; [A→a∙, b];     <br>
    [B→a∙, b] amp; [B→a∙, a]<br> ]<br>
<br>

    [        State 1: amp;  State  3:;       [A→∙a, a]  amp; [A→∙a, b];       [A→∙a, b]  amp; [B→∙a, b];       [B→a∙, b]            amp; ]
<br>
What states would be merged in a LALR(1) parser?</p>

<ol style="list-style-type:upper-alpha">
	<li>States 1 and 2.</li>
	<li>States 0 and 1.</li>
	<li>States 0 and 2.</li>
	<li>States 2 and 3.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - Consider the following grammar:

    S→abS | acS | c

Number of states in the canonical set of LR(0) items for the grammar?
(Do not include final accept state (S’→S $. ) in counting.<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - <p>Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?</p>

<ol style="list-style-type:upper-alpha">
	<li>Abstract Syntax Tree (AST)</li>
	<li>Attribute Grammar</li>
	<li>Symbol Table</li>
	<li>Parse Table</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - Consider the following grammar: 
    S→S ; a | a

Number of states in the canonical set of SLR(1) items for the grammar?
(Do not include final accept state (S’→S $. ) in counting.<hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>In LR parsing, If the parser is in a state containing an LR(k) item [A→α∙γ, δ], what must be at the top of the stack?</p>

<ol style="list-style-type:upper-alpha">
	<li>α</li>
	<li>γ</li>
	<li>δ</li>
	<li>A</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - <p>In lexical analyser, When using regular expressions to scan an input, for resolving conflicts that occur when using regular expressions to scan an input, Our approach was to use maximal­-munch to always choose the longest possible match at any point, then to break ties based on the priorities of the regular expressions. However, this is not the only way that we could have resolved conflicts.<br>
In some cases we may have a set of regular expressions for which it is possible to tokenize a particular input string, but for which the maximal­-munch algorithm will not be able to break the input into tokens.<br>
Consider the following scanner (lexical analyzer) “flex”.<br>
Consider the following tokens and their associated regular expressions, given as a flex scanner specification :<br>

    <br>
    [ <br>
    Regular expression              amp; Token;                <br>
     aa         amp; print(“1");                 <br>
     a         amp;print( “2");                <br>
     ab         amp; print(“3");               <br>
    <br> ]
<br>
If two longest matches are of same length then we give preference in the below order : 1   gt;2   gt;3<br>
For which of the following input strings : The string can be broken apart into substrings, where each substring matches one of the regular expressions, but ∙ The maximal-munch algorithm will fail to break the string apart in a way where each piece matches one of the regular expressions.</p>

<ol style="list-style-type:upper-alpha">
	<li>cabab</li>
	<li>aab</li>
	<li>abb</li>
	<li>aba</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>Which of the following is true about grammar ambiguity?</p>

<ol style="list-style-type:upper-alpha">
	<li>A grammar is said to be ambiguous if it can produce more than one parse tree for some sentence/string.</li>
	<li>A grammar is said to be ambiguous when, for some sentence, two different sequences of leftmost derivations can produce the same sentence from the same start symbol.</li>
	<li>A grammar is ambiguous if there is some string w such that w’s right-most derivation differs from its left-most derivation.</li>
	<li>A grammar is said to be ambiguous if and only if, for some sentence, two different sequences of rightmost derivations can produce the same sentence from the same start symbol.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Consider the following sets of LR(1) items in the states of a LR(1) parser.<br>

    <br>
    [  <br>
     State 0:  amp;  State 2:;  <br>
    [A→∙a, b]  amp; [A→∙a, c];  <br>
    [A→a∙, c]  amp; [A→a∙, b];  <br>
    [B→a∙, b]  amp; [B→a∙, a]; <br>
     State  1: amp;  State  3:;  <br>
    [A→∙a, a]  amp; [A→∙a, b];  <br>
    [A→∙a, b]  amp; [B→∙a, b];  <br>
    [B→a∙, b]        amp;<br> ]<br>
<br>
What happens when we merge states(which can be merged according to LALR(1) parser) in a LALR(1) parser?</p>

<ol style="list-style-type:upper-alpha">
	<li>A new reduce/reduce conflicts introduced in the LALR(1) parser</li>
	<li>A new shift/reduce conflicts introduced in the LALR(1) parser</li>
	<li>New reduce/reduce and shift/reduce conflicts introduced in the LALR(1) parser</li>
	<li>No new conflicts introduced in the LALR(1) parser</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q14</span> - <p>Consider the following grammar:<br>
A→A and A|A or A|(A) | true | false<br>
Which of the following is/are true about First sets for each production and nonterminal?</p>

<ol style="list-style-type:upper-alpha">
	<li>FIRST(true) = { “true" }</li>
	<li>FIRST( false )= { “false" }</li>
	<li>FIRST((A))={“("}</li>
	<li>FIRST( A and A ) = FIRST(A or A ) = FIRST(A ) = {“true", “false" }</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q15</span> - <p>We have a scanner (lexical analyzer) "flex". Consider the following tokens and their associated regular expressions, given as a flex scanner specification :<br>

    [         <br>
     Regular expression                      amp;  Token;                   <br>
    (01 | 10)        amp; printf(“   nbsp;X ");                  <br>
     0(01)^∗ 1 amp; printf(“   nbsp;Y   nbsp;");       <br>
    (1010^∗ 1 | 0101^∗ 0) amp; printf(“   nbsp;Z   nbsp;");                        <br>
    <br> ]
<br>
When using regular expressions to scan an input, we resolve conflicts by taking the largest possible match at any point. If two longest matches are of same length then we give preference in the below order : X   gt;Y   gt;Z</p>

<p>For Which of the following inputs to this scanner, we will get an Lexical error?</p>

<ol style="list-style-type:upper-alpha">
	<li>0101</li>
	<li>010101</li>
	<li>01010101</li>
	<li>0101010101</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let data={'name': 'GO Classes Test Series 2023 | Compiler Design | Test 1', 'duration': '50', 'total_qs': '15', 'total_qs_one': 6, 'total_qs_two': 9, 'apti_num_qs': 0, 'technical_num_qs': 15, 'apti_marks': 0, 'technical_marks': 24, 'total_marks': 24, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 15, 'marks': 24, 'question': [{'contents': '', 'post_id': '386739', 'text': '<p>In $\\text{LR(1)}$ parsing, what constitutes a shift/reduce conflict?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>A DFA state contains both LR items allowing shift and reduce for the different lookahead.</li>\n\t<li>A DFA state contains both LR items allowing shift and reduce for the same lookahead.</li>\n\t<li>A DFA state contains both LR items allowing shifts for the same lookahead.</li>\n\t<li>A DFA state contains both LR items allowing shifts for the different lookahead.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lr-parser,2-marks', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386741', 'text': '<p>In $\\text{LR}$ parsing, Given an $\\text{LR(}k)$ item $[\\mathrm{A} \\rightarrow \\alpha \\bullet \\mathrm{\\gamma}, \\delta]$, what lookahead allows a shift to be performed (ignoring any other $\\text{LR}(k)$ items added to the state by closure)?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>The terminal at the beginning of $\\gamma$.</li>\n\t<li>The terminal at the ending of $\\alpha$.</li>\n\t<li>The terminal at the beginning of $\\alpha$.</li>\n\t<li>The terminal at the beginning of $\\delta$.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lr-parser,2-marks', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386733', 'text': '<p>Consider the following sets of $\\text{LR(1)}$ items in the states of a $\\text{LR(1)}$ parser for some grammar $\\text{G}.$<br>\n$$<br>\n\\begin{array}{ll}<br>\n\\text { State 0: } &amp; \\text { State 2: } \\\\<br>\n{[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} &amp; {[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{c}]} \\\\<br>\n{[\\mathrm{A} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{c}]} &amp; {[\\mathrm{A} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]} \\\\<br>\n{[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]} &amp; {[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{a}]}<br>\n\\end{array}<br>\n$$<br>\n$$<br>\n\\begin{array}{ll}<br>\n\\text { State 1: } &amp; \\text { State } 3: \\\\<br>\n{[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{a}]} &amp; {[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} \\\\<br>\n{[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} &amp; {[\\mathrm{B} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} \\\\<br>\n{[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]} &amp;<br>\n\\end{array}<br>\n$$<br>\nWhich of the following is true for the given set of $\\text{LR1}$ items and the given $\\text{LR1}$ parser (Assume the parser has only the given set of $\\text{LR1}$ items for $\\text{G)}?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{G}$ is $\\text{LR1}$.</li>\n\t<li>$\\text{G}$ is not $\\text{LR1}$ because reduce/reduce conflict is caused by $\\left[\\mathrm{A} \\rightarrow \\mathrm{a}{\\bullet}, \\mathrm{c}\\right]$ and $[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]$ in state $1.$</li>\n\t<li>$\\text{G}$ is not $\\text{LR1}$ because Shift/reduce conflict is caused by $[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{c}]$ and $[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{a}]$ on lookahead $\\mathrm{a}$ in state $2.$</li>\n\t<li>$\\text{G}$ is not $\\text{LR1}$ because Shift/shift conflict is caused by $[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]$ and $[\\mathrm{B} \\rightarrow \\bullet&nbsp;\\mathrm{a}, \\mathrm{b}]$ on lookahead $\\mathrm{a}$ in state $3.$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lr-parser,2-marks', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386753', 'text': '<p>Which of the following is true about the relationship between $\\text{LALR(1)}$ and $\\text{SLR(1)}$ parsers?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>There are grammars that can be parsed by $\\text{SLR(1)}$ parsers that cannot be parsed by $\\text{LALR(1)}$ parsers.</li>\n\t<li>There are grammars that can be parsed by $\\text{LALR(1)}$ parsers that cannot be parsed by $\\text{SLR(1)}$ parsers.</li>\n\t<li>$\\text{LALR(1)}$ parsers are as powerful as $\\text{SLR(1)}$ parsers, so any grammar that can be parsed by an $\\text{LALR(1)}$ parser can be parsed by a $\\text{SLR(1)}$ parser.</li>\n\t<li>For any grammar $\\text{G}$ which can be parsed by a $\\text{SLR(1)}$ parser, number of states in the $\\text{SLR(1)}$ parser can be less than number of states in the $\\text{LALR(1)}$ parser for $\\text{G}$.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lr-parser,1-mark', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386747', 'text': '<p>In $\\text{SLR}$ parsing to get a shift-reduce conflict for state $\\text{I}$ on terminal symbol \' $a$ \',</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{A} \\rightarrow \\alpha . \\beta$ with $\\text{First}\\;( \\beta)$ containing \' $a$ \' should be in $\\text{I}$</li>\n\t<li>$\\text{A} \\rightarrow \\delta$. be in $\\text{I}$ with $\\text{Follow(A)}$ having \' $a$ \'</li>\n\t<li>$\\text{A} \\rightarrow \\alpha . a\\beta$&nbsp;should be in $\\text{I}$ and $\\text{X} \\rightarrow \\delta$. be in $\\text{I}$ with $\\text{Follow (X)}$ having \' $a$ \'</li>\n\t<li>None of the other options</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lr-parser,1-mark', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386737', 'text': '<p>Consider the following sets of $\\text{LR(1})$ items in the states of a $\\text{LR(1)}$ parser.<br>\n$$<br>\n\\begin{array}{ll}<br>\n\\text { State 0: } &amp; \\text { State 2: } \\\\<br>\n{[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} &amp; {[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{c}]} \\\\<br>\n{[\\mathrm{A} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{c}]} &amp; {[\\mathrm{A} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]} \\\\<br>\n{[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]} &amp; {[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{a}]}<br>\n\\end{array}<br>\n$$<br>\n$$\\begin{array}{ll}\\text { State 1: } &amp; \\text { State } 3: \\\\ {[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{a}]} &amp; {[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} \\\\ {[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} &amp; {[\\mathrm{B} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} \\\\ {[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]} &amp; \\end{array}$$<br>\nWhat states would be merged in a $\\text{LALR(1)}$ parser?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>States $1$ and $2.$</li>\n\t<li>States $0$ and $1.$</li>\n\t<li>States $0$ and $2.$</li>\n\t<li>States $2$ and $3.$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lr-parser,2-marks', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386729', 'text': 'Consider the following grammar:\n$$\\text{S} \\rightarrow \\text{abS | acS | c } $$\nNumber of states in the canonical set of $\\text{LR(0)}$ items for the grammar?\n(Do not include final accept state $(\\text{S’} \\rightarrow \\text{S \\$.}$ ) in counting.', 'type': 'Numerical', 'answer': '8', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-cd-1,numerical-answers,goclasses,compiler-design,lr-parser,2-marks', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386751', 'text': '<p>Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Abstract Syntax Tree (AST)</li>\n\t<li>Attribute Grammar</li>\n\t<li>Symbol Table</li>\n\t<li>Parse Table</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,parsing,1-mark', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386731', 'text': 'Consider the following grammar: $$\\text{S} \\rightarrow \\text{S ; a | a}$$\nNumber of states in the canonical set of $\\text{SLR(1)}$ items for the grammar?\n(Do not include final accept state $(\\text{S’} \\rightarrow \\text{S \\$.}$ ) in counting.', 'type': 'Numerical', 'answer': '5', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-cd-1,numerical-answers,goclasses,compiler-design,lr-parser,2-marks', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386743', 'text': '<p>In $\\text{LR}$ parsing, If the parser is in a state containing an $\\text{LR}(k)$ item $[\\mathrm{A} \\rightarrow \\alpha \\bullet \\mathrm{\\gamma}, \\delta]$, what must be at the top of the stack?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\alpha$</li>\n\t<li>$\\gamma$</li>\n\t<li>$\\delta$</li>\n\t<li>$\\text{A}$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lr-parser,2-marks', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386725', 'text': '<p>In lexical analyser, When using regular expressions to scan an input, for resolving conflicts that occur when using regular expressions to scan an input, Our approach was to use maximal\xad-munch to always choose the longest possible match at any point, then to break ties based on the priorities of the regular expressions. However, this is not the only way that we could have resolved conflicts.<br>\nIn some cases we may have a set of regular expressions for which it is possible to tokenize a particular input string, but for which the maximal\xad-munch algorithm will not be able to break the input into tokens.<br>\nConsider the following scanner (lexical analyzer) “flex”.<br>\nConsider the following tokens and their associated regular expressions, given as a flex scanner specification :<br>\n$$<br>\n\\begin{array}{|c|l|}<br>\n\\hline \\text{Regular expression} &amp; \\text{Token}\\\\<br>\n\\hline aa &amp; \\text{print(“1")}\\\\<br>\n\\hline a &amp;\\text{print( “2")}\\\\<br>\n\\hline ab &amp; \\text{print(“3")}\\\\<br>\n\\hline<br>\n\\end{array}$$<br>\nIf two longest matches are of same length then we give preference in the below order : $1&gt;2&gt;3$<br>\nFor which of the following input strings : The string can be broken apart into substrings, where each substring matches one of the regular expressions, but $\\bullet$ The maximal-munch algorithm will fail to break the string apart in a way where each piece matches one of the regular expressions.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$cabab$</li>\n\t<li>$aab$</li>\n\t<li>$abb$</li>\n\t<li>$aba$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lexical-analysis,multiple-selects,2-marks', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386749', 'text': '<p>Which of the following is true about grammar ambiguity?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>A grammar is said to be ambiguous if it can produce more than one parse tree for some sentence/string.</li>\n\t<li>A grammar is said to be ambiguous when, for some sentence, two different sequences of leftmost derivations can produce the same sentence from the same start symbol.</li>\n\t<li>A grammar is ambiguous if there is some string $w$ such that $w\\text{’s}$ right-most derivation differs from its left-most derivation.</li>\n\t<li>A grammar is said to be ambiguous if and only if, for some sentence, two different sequences of rightmost derivations can produce the same sentence from the same start symbol.</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b;d', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,ambiguous-grammar,multiple-selects,1-mark', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386735', 'text': '<p>Consider the following sets of $\\text{LR(1)}$ items in the states of a $\\text{LR(1)}$ parser.<br>\n$$<br>\n\\begin{array}{ll}<br>\n\\text { State 0: } &amp; \\text { State 2: } \\\\<br>\n{[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} &amp; {[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{c}]} \\\\<br>\n{[\\mathrm{A} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{c}]} &amp; {[\\mathrm{A} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]} \\\\<br>\n{[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]} &amp; {[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{a}]} \\\\<br>\n\\text { State } 1: &amp; \\text { State } 3: \\\\<br>\n{[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{a}]} &amp; {[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} \\\\<br>\n{[\\mathrm{A} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} &amp; {[\\mathrm{B} \\rightarrow \\bullet \\mathrm{a}, \\mathrm{b}]} \\\\<br>\n{[\\mathrm{B} \\rightarrow \\mathrm{a} \\bullet, \\mathrm{b}]} &amp;<br>\n\\end{array}<br>\n$$<br>\nWhat happens when we merge states(which can be merged according to $\\text{LALR(1)}$ parser) in a $\\text{LALR(1)}$ parser?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>A new reduce/reduce conflicts introduced in the $\\text{LALR(1)}$ parser</li>\n\t<li>A new shift/reduce conflicts introduced in the $\\text{LALR(1)}$ parser</li>\n\t<li>New reduce/reduce and shift/reduce conflicts introduced in the $\\text{LALR(1)}$ parser</li>\n\t<li>No new conflicts introduced in the $\\text{LALR(1)}$ parser</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lr-parser,2-marks', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386745', 'text': '<p>Consider the following grammar:<br>\n$\\mathrm{A} \\rightarrow \\mathrm{A}$ and $\\mathrm{A} \\mid \\mathrm{A}$ or $\\mathrm{A} \\mid \\mathrm{(A}) \\mid$ true $\\mid$ false<br>\nWhich of the following is/are true about First sets for each production and nonterminal?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{FIRST(true) = \\{ “true" \\}}$</li>\n\t<li>$\\text{FIRST( false )= \\{ “false" \\}}$</li>\n\t<li>$\\text{FIRST((A))=\\{“("}\\}$</li>\n\t<li>$\\text{FIRST( A and A ) = FIRST(A or A ) = FIRST(A ) = \\{“true", “false" \\}}$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b;c', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,first-and-follow,multiple-selects,1-mark', 'category': 'Compiler Design'}, {'contents': '', 'post_id': '386727', 'text': '<p>We have a scanner (lexical analyzer) "flex". Consider the following tokens and their associated regular expressions, given as a flex scanner specification :<br>\n$$\\begin{array}{|l|l|}<br>\n\\hline \\text { Regular expression } &amp; \\text { Token }\\\\<br>\n\\hline(01 \\mid 10) &amp; \\text{printf(“&nbsp;}\\mathrm{X} \\text { ") }\\\\<br>\n\\hline 0(01)^{\\ast} 1 &amp; \\text{printf(“&nbsp;Y&nbsp;")}\\\\<br>\n\\hline\\left(1010^{\\ast} 1 \\mid 0101^{\\ast} 0\\right) &amp; \\text{printf(“&nbsp;Z&nbsp;") }\\\\<br>\n\\hline<br>\n\\end{array}$$<br>\nWhen using regular expressions to scan an input, we resolve conflicts by taking the largest possible match at any point. If two longest matches are of same length then we give preference in the below order $: \\mathrm{X}&gt;\\mathrm{Y}&gt;\\mathrm{Z}$</p>\n\n<p>For Which of the following inputs to this scanner, we will get an Lexical error?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$0101$</li>\n\t<li>$010101$</li>\n\t<li>$01010101$</li>\n\t<li>$0101010101$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b;c', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-cd-1,goclasses,compiler-design,lexical-analysis,multiple-selects,2-marks', 'category': 'Compiler Design'}]}]}
      </script>
      