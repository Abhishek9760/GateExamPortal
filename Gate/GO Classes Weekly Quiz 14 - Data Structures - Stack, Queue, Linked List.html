<div><span>Q1</span> - <p>Consider an array-based queue implementation. Suppose we store the following variable to implement a queue</p>

<ol>
	<li>front</li>
	<li>back</li>
	<li>SIZE of the queue (number of values <strong>currently</strong> in the queue)</li>
	<li>CAPACITY of array   nbsp; (Maximum number of elements we can put in the queue)</li>
</ol>

<p>Now, instead of storing all the above variables, we want to store fewer variables out of four variables.</p>

<p>Which of the following is/are correct options which tell sufficient variables to store to implement the queue?</p>

<ol style="list-style-type:upper-alpha">
	<li>front, back, and SIZE</li>
	<li>front, back and CAPACITY</li>
	<li>front and back</li>
	<li>front and CAPACITY</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>Given a circular array-based queue capable of holding 100 objects. Suppose the queue is initially empty, and then objects are put into the queue at the rate of 10 per minute while meantime they are processed and removed from the queue at the rate of 5 per minute. After 120 elements have been added to the queue, which of the following is true?</p>

<ol style="list-style-type:upper-alpha">
	<li>You can't add 120 elements to an array holding 100 entries.</li>
	<li>There will be 60 elements in the queue, 20 of them at the front of the array where the queue started, and 40 at the other end.</li>
	<li>There will be 60 elements in the queue, 30 of them at the front of the array where the queue started, and 30 at the other end.</li>
	<li>There will be 60 elements in the queue, 40 of them at the front of the array where the queue started, and 20 at the other end.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <p>Consider the implementation of a stack of which is based on dynamic array allocation using malloc in C programming. This implementation allows us to push more elements than the current array capacity. It works as follows.</p>

<p>Suppose the array is full, then to push the next element we first allocate a new array of larger size using malloc, copy all elements to the new array, and free up the old array memory.</p>

<p>When a dynamic array-based stack becomes full, you increase the array size by the following sequence k, 2 k, 3 k, 4 k, … for some positive constant k. Which means the first time we increase the size by k, next time by 2 k, and so on.</p>

<p>If you have an empty stack that uses an array whose initial size is k, and you perform n pushes (assume that n   gt;k). What is the total cost complexity of executing n push operations?<br>
Let   nbsp;cost of expanding from k to 2 k has 2 k cost, similarly cost of expanding from 2 k to 3   nbsp;k has 3   nbsp;k cost.</p>

<ol style="list-style-type:upper-alpha">
	<li>O(n^ 2 / k)</li>
	<li>O(n / k)</li>
	<li>O(n^ 2 k)</li>
	<li>O(n k)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - <p>Suppose that a client performs an intermixed sequence of (queue) enqueue and dequeue operations. The enqueue operations put the integers 0 through 9 in order onto the queue; the dequeue operations print out the return value.</p>

<p>Which of the following sequence(s) could not occur?</p>

<ol style="list-style-type:upper-alpha">
	<li>0  1  2  3  4  5  6  7  8  9</li>
	<li>4  6  8  7  5  3  2  9  0  1</li>
	<li>2  5  6  7  4  8  9  3  1  0</li>
	<li>4  3  2  1  0  5  6  7  8  9</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - <p>Consider a data structure StackWithMax that supports all operations of a stack, and in addition supports getMax.</p>

<ul>
	<li>getMax() is a function that returns the maximum without deleting it.</li>
	<li>StackWithMax is implemented using a singly linked list, and each node of the linked list has 3 fields to store.</li>
</ul>

<p>Two fields are the usual element and next pointer, one extra field is there to facilitate getMax operation in efficient time.<br>
We can efficiently implement getMax of such data structure in -</p>

<ol style="list-style-type:upper-alpha">
	<li>θ(1) time</li>
	<li>θ(n) time</li>
	<li>θ(n log n) time</li>
	<li>θ(log n) time</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - <p>Consider an array A storing m   gt;1 different integer values sorted in increasing order. At least one value in A is negative and at least one of them is positive. We want to change the positions of the positive values stored in A so the positive values appear in decreasing order. So, for example, if the array A is as in the figure on the left, the modified array is as in the figure on the right.</p>

<p style="text-align:center"><img src="https://gateoverflow.in/?qa=blob&qa_blobid=10383186326115297648"></p>

<p>If we use stack or queue but not both to accomplish this task. Which of the following is/are true?<br>
Let n be the number of positive values.</p>

<ol style="list-style-type:upper-alpha">
	<li>For a queue, we need a minimum of n enqueues and n dequeues operations.</li>
	<li>For a stack, we need a minimum of n push and   nbsp;n pop operations.</li>
	<li>For a queue, we need a minimum of n+1 enqueues and n+1 dequeues operations.</li>
	<li>For a stack, we need a minimum of n+1 push and n+1 pop operations.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - <p>Suppose that we want to design a data structure called Mx-Queue that supports ONLY three   nbsp;operations as follows:</p>

<p>Enqueue(x) –   nbsp;It is a standard queue operation that equeue element x into the queue.</p>

<p>Dequeue() –   nbsp;It is a standard queue operation that dequeue   nbsp;from front of the queue.</p>

<p>FIND-MAX() –   nbsp;It is one extra operation that   nbsp;Mx-Queue   nbsp;supports which   nbsp;finds the maximum element from MX-Queue without removing it in   nbsp;O(1) time.</p>

<p>To fulfill the purpose we use one more   nbsp;auxiliary data structure along with a standard queue.</p>

<p>There are two choices of   nbsp;auxiliary data structures are available to us.   nbsp; (See figure for visual representation)</p>

<ul>
	<li>QueueStack</li>
	<li>Queue</li>
</ul>

<p>QueueStack   nbsp;is a data structure that has the special privilege of removing elements from the rear of the queue.</p>

<p>   nbsp;</p>

<p><img src="https://gateoverflow.in/?qa=blob&qa_blobid=14035886020062273095"></p>

<p>we call the following functions Insert() and Delete() to add or remove elements into or from   nbsp;Mx-Queue.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
Insert(Mx-Queue,x): 
   Enqueue(Mx-Queue, X)
   //Do something with auxiliary data structure
End


Delete(Mx-Queue): 
    x = Dequeue(Mx-Queue)
    //Do something with auxiliary data structure
    Return x 
End
</pre>

<p>One of the   nbsp;Insert or Delete works in linear time and the other one works in constant time.</p>

<p>Choose the correct option.</p>

<ul>
	<li>S1: We can implement Mx-Queue by using one   nbsp;Queue and QueueStack data Structure.</li>
	<li>S2: We can implement Mx-Queue by using two Queue data Structures.</li>
</ul>

<ol style="list-style-type:upper-alpha">
	<li>S1 is correct but S2 is incorrect</li>
	<li>S1 is incorrect but S2 is correct</li>
	<li>Both are correct</li>
	<li>Both are incorrect</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - <p>Consider the following pseudo-code that uses a stack. What will be the output of n = 50.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
while (n    gt; 0) 
    stack.push (n 
    n /= 2;

while (!stack.isEmpty())
    print(stack.pop());
</pre><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - <p>Which of the following statements about stacks, queues, and linked lists are true?</p>

<ol style="list-style-type:upper-alpha">
	<li>Stacks and queues can be implemented using arrays.</li>
	<li>A queue allows a user to retrieve nodes using the LIFO principle, in O(1) time.</li>
	<li>Suppose we have a circular array holding only integers, and having a capacity (maximum size) of n. If the array is a circular array, then we can store more than n entries in it at any given time because we can make use of the modulus operator.</li>
	<li>Using a doubly-linked list, it is not possible to keep the nodes sorted.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>Consider the memory allocation of M blocks.</p>

<p>Stack1 growing from block 0 up toward block M - 1 and Stack2 growing from block M-1 down to block 0.</p>

<p>Let Top1 (initialized to -1) and Top2  ( initialized   nbsp;to M) be the tops of the stacks. For example, after 2 calls to PushStack1 (data) that allocates elements in Stack1 followed by 1 call to PushStack2 (data) that allocates elements in Stack2, the memory that was initially all free blocks now has 3 allocated blocks as per the figure:</p>

<p style="text-align:center"><img src="https://gateoverflow.in/?qa=blob&qa_blobid=4029593521058460610"></p>

<p>If Stack1 was replaced by a circular queue with Front and Rear pointers, then which of the following is true regarding memory utilization?</p>

<ol style="list-style-type:upper-alpha">
	<li>you may not be able to add/push into the stack even when there are some free blocks in the memory.</li>
	<li>you may not be able to add/enqueue into the queue even when there are some free blocks in the memory.</li>
	<li>Stack and queue both can be implemented with efficient memory utilization.</li>
	<li>This implementation is not possible.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - <p>The following operations are performed on an initially empty queue of ints. What is the contents of the queue afterwards? The queue is displayed with the front to the left.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
q.enqueue (1)
q.enqueue (2)
i=q.getfront ()
q.enqueue (3)
q.enqueue (4)
q.enqueue (5)
i=q.dequeue ()
q.enqueue (6)</pre>

<p><br>
Notes: getfront operates analogously to the stack method "top()".</p>

<p>enqueue and dequeue operate as one would expect standard queue operations with those names.</p>

<ol style="list-style-type:upper-alpha">
	<li>1 2 3 4 5 6</li>
	<li>6 5 4 3 1</li>
	<li>2 3 4 5 6</li>
	<li>1 2 3 4 6</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>A double stack is a variation of a stack that allows access to the top and to the bottom of the stack. A double stack ADT provides operations (T  x) that adds x to the top of the stack, (T  x) that adds x to the bottom of the stack,  that removes the element at the top of the stack, and  that removes the element at the bottom of the stack.</p>

<p>Consider a double-stack ds implemented using an array as shown in the following figure.</p>

<p style="text-align:center"><img src="https://gateoverflow.in/?qa=blob&qa_blobid=8964072913138431231"></p>

<p>When (T  x) is executed the value of  is increased (decreased); similarly when (T  x ) is executed the value of  is decreased (increased). Consider the following code fragment.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
for (int i=0 ; i   lt;3 ;++i) ds.pushTop(ds.popBottom());
for (int i=0 ; i   lt;2 ;++i) x= ds. popTop();
ds.pushBottom(x)
</pre>

<p><br>
After this code fragment is executed on the double stack  represented by the above figure which are the final values for top and ?</p>

<ol style="list-style-type:upper-alpha">
	<li>top =8, bottom =4</li>
	<li>top =9, bottom =5</li>
	<li>top =7, bottom =3</li>
	<li>top =10, bottom =3</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Consider the following piece of code which finds the size of the queue when the queue is implemented using a circular array. Back and front are pointers pointing to the back and front of the queue respectively, and cap is the capacity of the array.</p>

<p>Fill the return statement in the else part so that code works correctly to find the size of the queue.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
if (back    gt;= front)
    return back - front;
else
    return _______</pre>

<ol style="list-style-type:upper-alpha">
	<li>(back+cap)-front</li>
	<li>cap - (back+front)</li>
	<li>front-back</li>
	<li>cap - (back-front)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let q = [{'contents': '', 'post_id': '377447', 'text': '<p>Consider an array-based queue implementation. Suppose we store the following variable to implement a queue</p>\n\n<ol>\n\t<li>front</li>\n\t<li>back</li>\n\t<li>SIZE of the queue (number of values <strong>currently</strong> in the queue)</li>\n\t<li>CAPACITY of array&nbsp; (Maximum number of elements we can put in the queue)</li>\n</ol>\n\n<p>Now, instead of storing all the above variables, we want to store fewer variables out of four variables.</p>\n\n<p>Which of the following is/are correct options which tell sufficient variables to store to implement the queue?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>front, back, and SIZE</li>\n\t<li>front, back and CAPACITY</li>\n\t<li>front and back</li>\n\t<li>front and CAPACITY</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,multiple-selects,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377438', 'text': '<p>Given a circular array-based queue capable of holding $100$ objects. Suppose the queue is initially empty, and then objects are put into the queue at the rate of $10$ per minute while meantime they are processed and removed from the queue at the rate of $5$ per minute. After $120$ elements have been added to the queue, which of the following is true?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>You can\'t add $120$ elements to an array holding $100$ entries.</li>\n\t<li>There will be $60$ elements in the queue, $20$ of them at the front of the array where the queue started, and $40$ at the other end.</li>\n\t<li>There will be $60$ elements in the queue, $30$ of them at the front of the array where the queue started, and $30$ at the other end.</li>\n\t<li>There will be $60$ elements in the queue, $40$ of them at the front of the array where the queue started, and $20$ at the other end.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,circular-queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377441', 'text': '<p>Consider the implementation of a stack of which is based on dynamic array allocation using malloc in C programming. This implementation allows us to push more elements than the current array capacity. It works as follows.</p>\n\n<p>Suppose the array is full, then to push the next element we first allocate a new array of larger size using malloc, copy all elements to the new array, and free up the old array memory.</p>\n\n<p>When a dynamic array-based stack becomes full, you increase the array size by the following sequence $k, 2 k, 3 k, 4 k, \\dots$ for some positive constant $k$. Which means the first time we increase the size by $k$, next time by $2 k$, and so on.</p>\n\n<p>If you have an empty stack that uses an array whose initial size is $k$, and you perform $n$ pushes (assume that $n&gt;k)$. What is the total cost complexity of executing n push operations?<br>\nLet&nbsp;cost of expanding from $k$ to $2 k$ has $2 k$ cost, similarly cost of expanding from $2 k$ to $3&nbsp;k$ has $3&nbsp;k$ cost.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$O\\left(n^ 2 / k\\right)$</li>\n\t<li>$O(n / k)$</li>\n\t<li>$O\\left(n^ 2 k\\right)$</li>\n\t<li>$O(n k)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,time-complexity,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377449', 'text': '<p>Suppose that a client performs an intermixed sequence of (queue) enqueue and dequeue operations. The enqueue operations put the integers $0$ through $9$ in order onto the queue; the dequeue operations print out the return value.</p>\n\n<p>Which of the following sequence(s) could not occur?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$0\\; 1\\; 2\\; 3\\; 4\\; 5\\; 6\\; 7\\; 8\\; 9$</li>\n\t<li>$4\\; 6\\; 8\\; 7\\; 5\\; 3\\; 2\\; 9\\; 0\\; 1$</li>\n\t<li>$2\\; 5\\; 6\\; 7\\; 4\\; 8\\; 9\\; 3\\; 1\\; 0$</li>\n\t<li>$4\\; 3\\; 2\\; 1\\; 0\\; 5\\; 6\\; 7\\; 8\\; 9$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b;c;d', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,multiple-selects,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377439', 'text': '<p>Consider a data structure StackWithMax that supports all operations of a stack, and in addition supports getMax.</p>\n\n<ul>\n\t<li>getMax() is a function that returns the maximum without deleting it.</li>\n\t<li>StackWithMax is implemented using a singly linked list, and each node of the linked list has $3$ fields to store.</li>\n</ul>\n\n<p>Two fields are the usual element and next pointer, one extra field is there to facilitate getMax operation in efficient time.<br>\nWe can efficiently implement getMax of such data structure in -</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\theta(1)$ time</li>\n\t<li>$\\theta(n)$ time</li>\n\t<li>$\\theta(n \\log n)$ time</li>\n\t<li>$\\theta(\\log n)$ time</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-ds-3,goclasses,data-structures,linked-list,time-complexity,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377443', 'text': '<p>Consider an array $\\mathrm{A}$ storing $m&gt;1$ different integer values sorted in increasing order. At least one value in $\\mathrm{A}$ is negative and at least one of them is positive. We want to change the positions of the positive values stored in $\\mathrm{A}$ so the positive values appear in decreasing order. So, for example, if the array $\\mathrm{A}$ is as in the figure on the left, the modified array is as in the figure on the right.</p>\n\n<p style="text-align:center"><img alt="" height="100" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=10383186326115297648" width="703"></p>\n\n<p>If we use stack or queue but not both to accomplish this task. Which of the following is/are true?<br>\nLet $n$ be the number of positive values.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>For a queue, we need a minimum of $n$ enqueues and $n$ dequeues operations.</li>\n\t<li>For a stack, we need a minimum of $n$ push and&nbsp;$n$ pop operations.</li>\n\t<li>For a queue, we need a minimum of $n+1$ enqueues and $n+1$ dequeues operations.</li>\n\t<li>For a stack, we need a minimum of $n+1$ push and $n+1$ pop operations.</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-ds-3,goclasses,data-structures,stack,multiple-selects,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377434', 'text': '<p>Suppose that we want to design a data structure called Mx-Queue that supports ONLY three&nbsp;operations as follows:</p>\n\n<p>Enqueue(x) –&nbsp;It is a standard queue operation that equeue element x into the queue.</p>\n\n<p>Dequeue() –&nbsp;It is a standard queue operation that dequeue&nbsp;from front of the queue.</p>\n\n<p>FIND-MAX() –&nbsp;It is one extra operation that&nbsp;Mx-Queue&nbsp;supports which&nbsp;finds the maximum element from MX-Queue without removing it in&nbsp;$\\mathrm{O}(1)$ time.</p>\n\n<p>To fulfill the purpose we use one more&nbsp;auxiliary data structure along with a standard queue.</p>\n\n<p>There are two choices of&nbsp;auxiliary data structures are available to us.&nbsp; (See figure for visual representation)</p>\n\n<ul>\n\t<li>QueueStack</li>\n\t<li>Queue</li>\n</ul>\n\n<p>QueueStack&nbsp;is a data structure that has the special privilege of removing elements from the rear of the queue.</p>\n\n<p>&nbsp;</p>\n\n<p><img alt="" height="513" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=14035886020062273095" width="486"></p>\n\n<p>we call the following functions Insert() and Delete() to add or remove elements into or from&nbsp;Mx-Queue.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nInsert(Mx-Queue,x): \n   Enqueue(Mx-Queue, X)\n   //Do something with auxiliary data structure\nEnd\n\n\nDelete(Mx-Queue): \n    x = Dequeue(Mx-Queue)\n    //Do something with auxiliary data structure\n    Return x \nEnd\n</pre>\n\n<p>One of the&nbsp;Insert or Delete works in linear time and the other one works in constant time.</p>\n\n<p>Choose the correct option.</p>\n\n<ul>\n\t<li>$\\text{S1}:$ We can implement Mx-Queue by using one&nbsp;Queue and QueueStack data Structure.</li>\n\t<li>$\\text{S2}:$ We can implement Mx-Queue by using two Queue data Structures.</li>\n</ul>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{S1}$ is correct but $\\text{S2}$ is incorrect</li>\n\t<li>$\\text{S1}$ is incorrect but $\\text{S2}$ is correct</li>\n\t<li>Both are correct</li>\n\t<li>Both are incorrect</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'A', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377435', 'text': '<p>Consider the following pseudo-code that uses a stack. What will be the output of $n = 50.$</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nwhile (n &gt; 0) {\n    stack.push (n % 2);\n    n /= 2;\n}\nwhile (!stack.isEmpty())\n    print(stack.pop());\n</pre>', 'type': 'Numerical', 'answer': '110010', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-ds-3,numerical-answers,goclasses,data-structures,stack,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377452', 'text': '<p>Which of the following statements about stacks, queues, and linked lists are true?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Stacks and queues can be implemented using arrays.</li>\n\t<li>A queue allows a user to retrieve nodes using the LIFO principle, in $\\mathrm{O}(1)$ time.</li>\n\t<li>Suppose we have a circular array holding only integers, and having a capacity (maximum size) of $n$. If the array is a circular array, then we can store more than $n$ entries in it at any given time because we can make use of the modulus operator.</li>\n\t<li>Using a doubly-linked list, it is not possible to keep the nodes sorted.</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,multiple-selects,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377437', 'text': '<p>Consider the memory allocation of $\\mathrm{M}$ blocks.</p>\n\n<p>Stack$1$ growing from block $0$ up toward block $\\mathrm{M} - 1$ and Stack$2$ growing from block $\\mathrm{M}-1$ down to block $0.$</p>\n\n<p>Let Top$1$ (initialized to $-1)$ and Top$2\\; ($ initialized&nbsp;to $\\mathrm{M})$ be the tops of the stacks. For example, after $2$ calls to PushStack$1$ (data) that allocates elements in Stack$1$ followed by $1$ call to PushStack$2$ (data) that allocates elements in Stack$2,$ the memory that was initially all free blocks now has $3$ allocated blocks as per the figure:</p>\n\n<p style="text-align:center"><img alt="" height="349" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=4029593521058460610" width="644"></p>\n\n<p>If Stack$1$ was replaced by a circular queue with Front and Rear pointers, then which of the following is true regarding memory utilization?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>you may not be able to add/push into the stack even when there are some free blocks in the memory.</li>\n\t<li>you may not be able to add/enqueue into the queue even when there are some free blocks in the memory.</li>\n\t<li>Stack and queue both can be implemented with efficient memory utilization.</li>\n\t<li>This implementation is not possible.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,circular-queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377451', 'text': '<p>The following operations are performed on an initially empty queue of ints. What is the contents of the queue afterwards? The queue is displayed with the front to the left.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nq.enqueue (1)\nq.enqueue (2)\ni=q.getfront ()\nq.enqueue (3)\nq.enqueue (4)\nq.enqueue (5)\ni=q.dequeue ()\nq.enqueue (6)</pre>\n\n<p><br>\nNotes: getfront operates analogously to the stack method "top()".</p>\n\n<p>enqueue and dequeue operate as one would expect standard queue operations with those names.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1\\;2\\;3\\;4\\;5\\;6$</li>\n\t<li>$6\\;5\\;4\\;3\\;1$</li>\n\t<li>$2\\;3\\;4\\;5\\;6$</li>\n\t<li>$1\\;2\\;3\\;4\\;6$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-ds-3,goclasses,data-structures,queue,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377445', 'text': '<p>A $\\textit{double}$ stack is a variation of a stack that allows access to the top and to the bottom of the stack. A double stack ADT provides operations $\\textsf{pushTop} (\\text{T}\\; x)$ that adds $x$ to the top of the stack, $\\textsf{pushBottom} (\\mathrm{T}\\; x)$ that adds $x$ to the bottom of the stack, $\\textsf{popTop()}$ that removes the element at the top of the stack, and $\\textsf{popBottom()}$ that removes the element at the bottom of the stack.</p>\n\n<p>Consider a double-stack ds implemented using an array as shown in the following figure.</p>\n\n<p style="text-align:center"><img alt="" height="106" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=8964072913138431231" width="360"></p>\n\n<p>When $\\textsf{pushTop} (\\text{T}\\; x)\\; \\textsf{(popTop ())}$ is executed the value of $\\textsf{top}$ is increased (decreased); similarly when $\\textsf{pushBottom} (\\text{T}\\; x )\\; \\textsf{(popBottom ( ))}$ is executed the value of $\\textsf{bottom}$ is decreased (increased). Consider the following code fragment.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nfor (int i=0 ; i&lt;3 ;++i) ds.pushTop(ds.popBottom());\nfor (int i=0 ; i&lt;2 ;++i) x= ds. popTop();\nds.pushBottom(x)\n</pre>\n\n<p><br>\nAfter this code fragment is executed on the double stack $\\textsf{ds}$ represented by the above figure which are the final values for $\\text{top}$ and $\\textsf{bottom}?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>top $=8,$ bottom $=4$</li>\n\t<li>top $=9,$ bottom $=5$</li>\n\t<li>top $=7,$ bottom $=3$</li>\n\t<li>top $=10,$ bottom $=3$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-ds-3,goclasses,data-structures,stack,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377446', 'text': '<p>Consider the following piece of code which finds the size of the queue when the queue is implemented using a circular array. Back and front are pointers pointing to the back and front of the queue respectively, and cap is the capacity of the array.</p>\n\n<p>Fill the return statement in the else part so that code works correctly to find the size of the queue.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nif (back &gt;= front)\n    return back - front;\nelse\n    return _______</pre>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>(back$+$cap)$-$front</li>\n\t<li>cap $-$ (back$+$front)</li>\n\t<li>front$-$back</li>\n\t<li>cap $-$ (back$-$front)</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,1-mark', 'category': 'DS'}]
      let data={'name': 'GO Classes Weekly Quiz 14 | Data Structures | Stack, Queue, Linked List', 'duration': '40', 'total_qs': '13', 'total_qs_one': 6, 'total_qs_two': 7, 'apti_num_qs': 0, 'technical_num_qs': 13, 'apti_marks': 0, 'technical_marks': 20, 'total_marks': 20, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 13, 'marks': 20, 'question': [{'contents': '', 'post_id': '377447', 'text': '<p>Consider an array-based queue implementation. Suppose we store the following variable to implement a queue</p>\n\n<ol>\n\t<li>front</li>\n\t<li>back</li>\n\t<li>SIZE of the queue (number of values <strong>currently</strong> in the queue)</li>\n\t<li>CAPACITY of array&nbsp; (Maximum number of elements we can put in the queue)</li>\n</ol>\n\n<p>Now, instead of storing all the above variables, we want to store fewer variables out of four variables.</p>\n\n<p>Which of the following is/are correct options which tell sufficient variables to store to implement the queue?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>front, back, and SIZE</li>\n\t<li>front, back and CAPACITY</li>\n\t<li>front and back</li>\n\t<li>front and CAPACITY</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,multiple-selects,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377438', 'text': '<p>Given a circular array-based queue capable of holding $100$ objects. Suppose the queue is initially empty, and then objects are put into the queue at the rate of $10$ per minute while meantime they are processed and removed from the queue at the rate of $5$ per minute. After $120$ elements have been added to the queue, which of the following is true?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>You can\'t add $120$ elements to an array holding $100$ entries.</li>\n\t<li>There will be $60$ elements in the queue, $20$ of them at the front of the array where the queue started, and $40$ at the other end.</li>\n\t<li>There will be $60$ elements in the queue, $30$ of them at the front of the array where the queue started, and $30$ at the other end.</li>\n\t<li>There will be $60$ elements in the queue, $40$ of them at the front of the array where the queue started, and $20$ at the other end.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,circular-queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377441', 'text': '<p>Consider the implementation of a stack of which is based on dynamic array allocation using malloc in C programming. This implementation allows us to push more elements than the current array capacity. It works as follows.</p>\n\n<p>Suppose the array is full, then to push the next element we first allocate a new array of larger size using malloc, copy all elements to the new array, and free up the old array memory.</p>\n\n<p>When a dynamic array-based stack becomes full, you increase the array size by the following sequence $k, 2 k, 3 k, 4 k, \\dots$ for some positive constant $k$. Which means the first time we increase the size by $k$, next time by $2 k$, and so on.</p>\n\n<p>If you have an empty stack that uses an array whose initial size is $k$, and you perform $n$ pushes (assume that $n&gt;k)$. What is the total cost complexity of executing n push operations?<br>\nLet&nbsp;cost of expanding from $k$ to $2 k$ has $2 k$ cost, similarly cost of expanding from $2 k$ to $3&nbsp;k$ has $3&nbsp;k$ cost.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$O\\left(n^ 2 / k\\right)$</li>\n\t<li>$O(n / k)$</li>\n\t<li>$O\\left(n^ 2 k\\right)$</li>\n\t<li>$O(n k)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,time-complexity,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377449', 'text': '<p>Suppose that a client performs an intermixed sequence of (queue) enqueue and dequeue operations. The enqueue operations put the integers $0$ through $9$ in order onto the queue; the dequeue operations print out the return value.</p>\n\n<p>Which of the following sequence(s) could not occur?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$0\\; 1\\; 2\\; 3\\; 4\\; 5\\; 6\\; 7\\; 8\\; 9$</li>\n\t<li>$4\\; 6\\; 8\\; 7\\; 5\\; 3\\; 2\\; 9\\; 0\\; 1$</li>\n\t<li>$2\\; 5\\; 6\\; 7\\; 4\\; 8\\; 9\\; 3\\; 1\\; 0$</li>\n\t<li>$4\\; 3\\; 2\\; 1\\; 0\\; 5\\; 6\\; 7\\; 8\\; 9$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b;c;d', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,multiple-selects,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377439', 'text': '<p>Consider a data structure StackWithMax that supports all operations of a stack, and in addition supports getMax.</p>\n\n<ul>\n\t<li>getMax() is a function that returns the maximum without deleting it.</li>\n\t<li>StackWithMax is implemented using a singly linked list, and each node of the linked list has $3$ fields to store.</li>\n</ul>\n\n<p>Two fields are the usual element and next pointer, one extra field is there to facilitate getMax operation in efficient time.<br>\nWe can efficiently implement getMax of such data structure in -</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\theta(1)$ time</li>\n\t<li>$\\theta(n)$ time</li>\n\t<li>$\\theta(n \\log n)$ time</li>\n\t<li>$\\theta(\\log n)$ time</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-ds-3,goclasses,data-structures,linked-list,time-complexity,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377443', 'text': '<p>Consider an array $\\mathrm{A}$ storing $m&gt;1$ different integer values sorted in increasing order. At least one value in $\\mathrm{A}$ is negative and at least one of them is positive. We want to change the positions of the positive values stored in $\\mathrm{A}$ so the positive values appear in decreasing order. So, for example, if the array $\\mathrm{A}$ is as in the figure on the left, the modified array is as in the figure on the right.</p>\n\n<p style="text-align:center"><img alt="" height="100" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=10383186326115297648" width="703"></p>\n\n<p>If we use stack or queue but not both to accomplish this task. Which of the following is/are true?<br>\nLet $n$ be the number of positive values.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>For a queue, we need a minimum of $n$ enqueues and $n$ dequeues operations.</li>\n\t<li>For a stack, we need a minimum of $n$ push and&nbsp;$n$ pop operations.</li>\n\t<li>For a queue, we need a minimum of $n+1$ enqueues and $n+1$ dequeues operations.</li>\n\t<li>For a stack, we need a minimum of $n+1$ push and $n+1$ pop operations.</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a;b', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-ds-3,goclasses,data-structures,stack,multiple-selects,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377434', 'text': '<p>Suppose that we want to design a data structure called Mx-Queue that supports ONLY three&nbsp;operations as follows:</p>\n\n<p>Enqueue(x) –&nbsp;It is a standard queue operation that equeue element x into the queue.</p>\n\n<p>Dequeue() –&nbsp;It is a standard queue operation that dequeue&nbsp;from front of the queue.</p>\n\n<p>FIND-MAX() –&nbsp;It is one extra operation that&nbsp;Mx-Queue&nbsp;supports which&nbsp;finds the maximum element from MX-Queue without removing it in&nbsp;$\\mathrm{O}(1)$ time.</p>\n\n<p>To fulfill the purpose we use one more&nbsp;auxiliary data structure along with a standard queue.</p>\n\n<p>There are two choices of&nbsp;auxiliary data structures are available to us.&nbsp; (See figure for visual representation)</p>\n\n<ul>\n\t<li>QueueStack</li>\n\t<li>Queue</li>\n</ul>\n\n<p>QueueStack&nbsp;is a data structure that has the special privilege of removing elements from the rear of the queue.</p>\n\n<p>&nbsp;</p>\n\n<p><img alt="" height="513" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=14035886020062273095" width="486"></p>\n\n<p>we call the following functions Insert() and Delete() to add or remove elements into or from&nbsp;Mx-Queue.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nInsert(Mx-Queue,x): \n   Enqueue(Mx-Queue, X)\n   //Do something with auxiliary data structure\nEnd\n\n\nDelete(Mx-Queue): \n    x = Dequeue(Mx-Queue)\n    //Do something with auxiliary data structure\n    Return x \nEnd\n</pre>\n\n<p>One of the&nbsp;Insert or Delete works in linear time and the other one works in constant time.</p>\n\n<p>Choose the correct option.</p>\n\n<ul>\n\t<li>$\\text{S1}:$ We can implement Mx-Queue by using one&nbsp;Queue and QueueStack data Structure.</li>\n\t<li>$\\text{S2}:$ We can implement Mx-Queue by using two Queue data Structures.</li>\n</ul>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{S1}$ is correct but $\\text{S2}$ is incorrect</li>\n\t<li>$\\text{S1}$ is incorrect but $\\text{S2}$ is correct</li>\n\t<li>Both are correct</li>\n\t<li>Both are incorrect</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'A', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377435', 'text': '<p>Consider the following pseudo-code that uses a stack. What will be the output of $n = 50.$</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nwhile (n &gt; 0) {\n    stack.push (n % 2);\n    n /= 2;\n}\nwhile (!stack.isEmpty())\n    print(stack.pop());\n</pre>', 'type': 'Numerical', 'answer': '110010', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-ds-3,numerical-answers,goclasses,data-structures,stack,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377452', 'text': '<p>Which of the following statements about stacks, queues, and linked lists are true?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Stacks and queues can be implemented using arrays.</li>\n\t<li>A queue allows a user to retrieve nodes using the LIFO principle, in $\\mathrm{O}(1)$ time.</li>\n\t<li>Suppose we have a circular array holding only integers, and having a capacity (maximum size) of $n$. If the array is a circular array, then we can store more than $n$ entries in it at any given time because we can make use of the modulus operator.</li>\n\t<li>Using a doubly-linked list, it is not possible to keep the nodes sorted.</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'a', 'award': 1, 'penalty': '0.0000', 'tags': 'goclasses2024_wq22,goclasses,data-structures,stack,multiple-selects,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377437', 'text': '<p>Consider the memory allocation of $\\mathrm{M}$ blocks.</p>\n\n<p>Stack$1$ growing from block $0$ up toward block $\\mathrm{M} - 1$ and Stack$2$ growing from block $\\mathrm{M}-1$ down to block $0.$</p>\n\n<p>Let Top$1$ (initialized to $-1)$ and Top$2\\; ($ initialized&nbsp;to $\\mathrm{M})$ be the tops of the stacks. For example, after $2$ calls to PushStack$1$ (data) that allocates elements in Stack$1$ followed by $1$ call to PushStack$2$ (data) that allocates elements in Stack$2,$ the memory that was initially all free blocks now has $3$ allocated blocks as per the figure:</p>\n\n<p style="text-align:center"><img alt="" height="349" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=4029593521058460610" width="644"></p>\n\n<p>If Stack$1$ was replaced by a circular queue with Front and Rear pointers, then which of the following is true regarding memory utilization?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>you may not be able to add/push into the stack even when there are some free blocks in the memory.</li>\n\t<li>you may not be able to add/enqueue into the queue even when there are some free blocks in the memory.</li>\n\t<li>Stack and queue both can be implemented with efficient memory utilization.</li>\n\t<li>This implementation is not possible.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,circular-queue,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '377451', 'text': '<p>The following operations are performed on an initially empty queue of ints. What is the contents of the queue afterwards? The queue is displayed with the front to the left.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nq.enqueue (1)\nq.enqueue (2)\ni=q.getfront ()\nq.enqueue (3)\nq.enqueue (4)\nq.enqueue (5)\ni=q.dequeue ()\nq.enqueue (6)</pre>\n\n<p><br>\nNotes: getfront operates analogously to the stack method "top()".</p>\n\n<p>enqueue and dequeue operate as one would expect standard queue operations with those names.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1\\;2\\;3\\;4\\;5\\;6$</li>\n\t<li>$6\\;5\\;4\\;3\\;1$</li>\n\t<li>$2\\;3\\;4\\;5\\;6$</li>\n\t<li>$1\\;2\\;3\\;4\\;6$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-ds-3,goclasses,data-structures,queue,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377445', 'text': '<p>A $\\textit{double}$ stack is a variation of a stack that allows access to the top and to the bottom of the stack. A double stack ADT provides operations $\\textsf{pushTop} (\\text{T}\\; x)$ that adds $x$ to the top of the stack, $\\textsf{pushBottom} (\\mathrm{T}\\; x)$ that adds $x$ to the bottom of the stack, $\\textsf{popTop()}$ that removes the element at the top of the stack, and $\\textsf{popBottom()}$ that removes the element at the bottom of the stack.</p>\n\n<p>Consider a double-stack ds implemented using an array as shown in the following figure.</p>\n\n<p style="text-align:center"><img alt="" height="106" src="https://gateoverflow.in/?qa=blob&amp;qa_blobid=8964072913138431231" width="360"></p>\n\n<p>When $\\textsf{pushTop} (\\text{T}\\; x)\\; \\textsf{(popTop ())}$ is executed the value of $\\textsf{top}$ is increased (decreased); similarly when $\\textsf{pushBottom} (\\text{T}\\; x )\\; \\textsf{(popBottom ( ))}$ is executed the value of $\\textsf{bottom}$ is decreased (increased). Consider the following code fragment.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nfor (int i=0 ; i&lt;3 ;++i) ds.pushTop(ds.popBottom());\nfor (int i=0 ; i&lt;2 ;++i) x= ds. popTop();\nds.pushBottom(x)\n</pre>\n\n<p><br>\nAfter this code fragment is executed on the double stack $\\textsf{ds}$ represented by the above figure which are the final values for $\\text{top}$ and $\\textsf{bottom}?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>top $=8,$ bottom $=4$</li>\n\t<li>top $=9,$ bottom $=5$</li>\n\t<li>top $=7,$ bottom $=3$</li>\n\t<li>top $=10,$ bottom $=3$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-ds-3,goclasses,data-structures,stack,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '377446', 'text': '<p>Consider the following piece of code which finds the size of the queue when the queue is implemented using a circular array. Back and front are pointers pointing to the back and front of the queue respectively, and cap is the capacity of the array.</p>\n\n<p>Fill the return statement in the else part so that code works correctly to find the size of the queue.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nif (back &gt;= front)\n    return back - front;\nelse\n    return _______</pre>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>(back$+$cap)$-$front</li>\n\t<li>cap $-$ (back$+$front)</li>\n\t<li>front$-$back</li>\n\t<li>cap $-$ (back$-$front)</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024_wq22,goclasses,data-structures,queue,1-mark', 'category': 'DS'}]}]}
      </script>
      