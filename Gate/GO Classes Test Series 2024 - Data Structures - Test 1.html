<div><span>Q1</span> - <p>Consider the following program. printlist() is a function that takes the head of a linked list and prints all nodes values separated by comma. Node is typedefed singly linked list type struct.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
void insert1(Node *head,int data)

    Node *NewNode= (Node *)malloc(sizeof(Node));
    NewNode-   gt;value=data;
    NewNode-   gt;next=head;
    head=NewNode;

void insert2(Node **head_ref,int data)

    Node *NewNode= (Node *)malloc(sizeof(Node));
    NewNode-   gt;value=data;
    NewNode-   gt;next=*(head_ref);
    *(head_ref)=NewNode;

int main()

    /* create a linked list 1-   gt;2-   gt;3-   gt;4-   gt;5 
and head points to the first node.*/
    insert1(head,9);
    printlist(head); //Line X

    //The list is restored to its initial state

    insert2(   amp;head,9);
    printlist(head); //Line Y

</pre>

<p>Which of the following is/are true about the above program?</p>

<ol style="list-style-type:upper-alpha">
	<li>Line X prints 9,1,2,3,4,5</li>
	<li>Line Y prints 9,1,2,3,4,5</li>
	<li>Line X prints 1,2,3,4,5</li>
	<li>Line Y prints 1,2,3,4,5</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q2</span> - <p>Consider the following function fun() that takes the head of a linked list.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
struct node 
    int value;
    struct node *next;
;
typedef struct node Node;

int fun(Node *head)
    if(head== NULL) return 1;
    Node *p,*q;
    p = head;
    q = p-   gt;next;
    while(q!=NULL    amp;   amp; q!=p)
        q = q-   gt;next;
    if(q==NULL) return 1;
    q = q-   gt;next;
    p = p-   gt;next;
    
return (q==NULL);

</pre>

<p><br>
We say, a linked list has a loop if the last node of linked list points to some node of linked list and does not point to NULL.</p>

<p>What does the above function do?</p>

<ol style="list-style-type:upper-alpha">
	<li>Returns 0 is there is loop in linked list</li>
	<li>Returns 1 is there is loop in linked list</li>
	<li>Returns 0 is length of the linked list is even</li>
	<li>Function may go to infinite loop if there is a loop in linked list</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q3</span> - <pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
struct node
    int data;
    struct node *next;

void print(struct node *ptr)

    if(ptr)
    
        printf("
        do 
            printf("
        
        while(ptr-   gt;next);
    


</pre>

<p>What is the output, if the address of the first node of singly linked list 1 → 2 → 3→   nbsp;4 →   nbsp;5 is passed in the above C code?</p>

<ol style="list-style-type:upper-alpha">
	<li>1  2  3  4  5</li>
	<li>1  1  2  3  4  5</li>
	<li>1  1  2  3  4  5  5</li>
	<li>None of these</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q4</span> - <p>Consider the following function that takes reference to head of a Doubly Linked List as parameter. Assume that a node of doubly linked list has previous pointer as prev and next pointer as next.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
void fun(struct node **head_ref) 
 
    struct node *temp=NULL; 
    struct node *current=*head_ref; 
    while(current!=NULL) 
     
        temp=current-   gt;prev; 
        current-   gt;prev=current-   gt;next; 
        current-   gt;next=temp; 
        current=current-   gt;prev; 
     
    if(temp!=NULL) 
        *head_ref=temp-   gt;prev; 
 </pre>

<p>Assume that reference of head of following doubly linked list is passed to above function</p>

<p>1 ↔   nbsp;2 ↔ 3 ↔ 4 ↔ 5 ↔ 6. What should be the modified linked list after the function call?   nbsp;</p>

<ol start="1" style="list-style-type:upper-alpha">
	<li>2 ↔ 1 ↔ 4 ↔ 3 ↔ 6 ↔ 5</li>
	<li>5 ↔ 4 ↔ 3 ↔ 2 ↔ 1 ↔ 6</li>
	<li>6   nbsp; ↔ 5 ↔ 4 ↔ 3 ↔ 2 ↔ 1</li>
	<li>6 ↔ 5 ↔ 4 ↔ 3 ↔ 1 ↔ 2</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q5</span> - <p>The following code is intended to remove a node p from a doubly linked list. Assume that we know that p is in the list, so the list is not empty.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
struct node 
    char value;
    struct node *next;
    struct node *prev;
;
struct node *prev *succ;
prev = p-   gt;prev;
succ = p-   gt;next;
if (p == front) 
    front = front-   gt;next;
    if (front == NULL) rear = NULL;
    else front-   gt;prev = NULL;

else prev-   gt;next = succ;
if (p == rear) 
    rear = rear-   gt;next;
    rear-   gt;next = NULL;

else succ-   gt;prev = prev;
</pre>

<p>Given three linked lists (a),(b), and (c) as shown below.</p>

<p><br>
<strong><img src="https://lh5.googleusercontent.com/XPGFupKtI_QF0e9Y3NAHHFagNXJ2gn0RGUDpVVmdFYAxh5tcawigOXLK_zDdG_Pcnkygy5kY7R5sVtVhVf0ub-bVT_sO81sQ1i4BldjDjLKPEcJiMhm8mMg2-Q6xycN_x8laaDHxZOvSK4ZfSw"></strong><br>
Mark the correct option(s).</p>

<ol style="list-style-type:upper-alpha">
	<li>Code will crash on linked list (a)</li>
	<li>Code will crash on linked list (b)</li>
	<li>Code will crash on linked list (c)</li>
	<li>Code will not crash on any of the given linked lists</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q6</span> - <p>Consider the following function foo() which takes the head pointer of two singly-linked lists.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
struct node *foo(struct node *head1, struct node *head2)

    struct node *final, *temp;
    if (head1 == NULL) return head2;
    if (head2 == NULL) return head1;
    temp = foo(head1-   gt;next, head2-   gt;next);
    final = head1;
    head1 -   gt; next = head2;
    head2 -   gt; next = temp;
    return final;

</pre>

<p><br>
What will be the final linked list returned by foo() if executed upon following linked lists?</p>

<p><strong><img src="https://lh6.googleusercontent.com/77vc76YU2XsivCfNo_9oLPh3-wy9gMdxzJ3MHG0LvFIBSzCXWkWQVXDQuJnu8f3cATsyEnH1JZVN5SxsnnKsTXKJYBgEJR3v6aWWSNjyoTFw_d4RD48ypwaRk6iGl4ulneXwCf_85pJroNRE7Q"></strong></p>

<p><strong><img src="https://lh3.googleusercontent.com/6bGoQUB2SETmuz8EmIDLC_ys09NX-W8eNYKtbE9kfS5U8OmNB02qqTphTPVti1ZpNaEdfv5hPMmCByWwoBFjxJGj2txD_i4SK07o7BS-C-A2TTSDEBE7_ezYlCJdLgGHO3Bx-UuxGFW4G9W7Kg"></strong></p>

<ol style="list-style-type:upper-alpha">
	<li>1,2,3,4,5,7,8,9,10</li>
	<li>1,2,3,4,5,7,8,10,9,10</li>
	<li>1,2,3,4,5,8,7,10,9,10</li>
	<li>None of these</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q7</span> - <p>Given a circular, doubly-linked list whose contents are sorted in ascending order, what is the run-time complexity for inserting a new element into the list so that it remains correctly sorted? (Including the time required to search for the element’s correct position.)</p>

<ol style="list-style-type:upper-alpha">
	<li>O(1)</li>
	<li>O(logN)</li>
	<li>O(N)</li>
	<li>O(N^2)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q8</span> - <p>Consider the following function Merge() that takes the head of two linked lists.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
struct node 
    int value;
    struct node *next;
;
typedef struct node Node;

Node * Merge(Node * head1, Node * head2) 
    if (head1 == NULL) return head2;
    if (head2 == NULL) return head1;
    Node * head = NULL;
    if (head1 -   gt; value    lt; head2 -   gt; value) 
        head = head1;
        head -   gt; next = Merge(head1 -   gt; next, head2);
    
    else if (head1 -   gt; value    gt; head2 -   gt; value) 
        head = head2;
        head -   gt; next = Merge(head1, head2 -   gt; next);
    
return head;

</pre>

<p>Assume that the input lists are correctly sorted. Which of the following are some of the possible behaviors when Merge() is executed with well-formed and valid inputs? Correctly merged linked list is merged   nbsp;sorted linked list.</p>

<ol style="list-style-type:upper-alpha">
	<li>The function will produce a correctly merged linked list.</li>
	<li>The function may lead to a null pointer dereference.</li>
	<li>The function may result in an incorrectly merged linked list.</li>
	<li>Merge() will work on the following two lists.
	<ul>
		<li>List1: 1 → 3 → 5→ 7→   nbsp;Null</li>
		<li>List2: 2→ 4→ 6→   nbsp;8→ 10 →   nbsp;12→Null</li>
	</ul>
	</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q9</span> - <p>Consider the following Doubly Linked List:</p>

<p><br>
<strong><img src="https://lh6.googleusercontent.com/0Ls5DjJ0cfyFry2hINdIAxmGw8lvj_gjx7pW6dTykz9p_RB5MS4m3zlVrtnec7ahG3MDNurT3B678z4XtZDNnT9ZZlgKvBT_-B7fFHygjqOQpJCaMGkRHEQ17_dcC6lo8AOP5xVVXP4jMk3JCQ"></strong></p>

<p>If head points to the first node of the linked list then what will be the output of the following node?</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
head=head-   gt;next-   gt;next-   gt;next-   gt;prev;
head-   gt;next-   gt;next-   gt;prev=head;
printf("
</pre>

<ol style="list-style-type:upper-alpha">
	<li>1</li>
	<li>3</li>
	<li>5</li>
	<li>7</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q10</span> - <p>A doubly linked list is declared as:</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
struct Node 
    int Value;
    struct Node *prev;
    struct Node *next;
;
</pre>

<p>Which of the following segment of code deletes the node pointed to by X from the doubly linked list, if it is assumed that X points to neither the first nor the last node of the list?</p>

<ol style="list-style-type:upper-alpha">
	<li>X→ prev → next = X→ next ; X→ next → prev = X→ prev; free(X);</li>
	<li>X→ prev.next = X→ next ; X. next → prev = X→ prev; free(X);</li>
	<li>X→. prev → next = X.prev ; X→ next.prev = X.prev; free(X);</li>
	<li>X→ prev → next = X→ prev ; X→ next → prev = X→ next; free(X);</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q11</span> - <p>Consider a mutual pair of recursive functions g() and h().</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
int g(struct node *l) 
    if (l == NULL || l-   gt;next == NULL) return 1;
    if (l-   gt;value    lt; l-   gt;next-   gt;value) return h(l-   gt;next);
    else return 0;


int h(struct node *l) 
    if (l == NULL || l-   gt;next == NULL) return 1;
    if (l-   gt;value    gt; l-   gt;next-   gt;value) return g(l-   gt;next);
    else return 0;

</pre>

<p>Let head be a pointer to a singly linked list having at least 3 nodes.</p>

<p>When will the expression (g(head) || h(head)) return 1 or 0?</p>

<ol style="list-style-type:upper-alpha">
	<li>g(head) || h(head) is 1 if the linked list is in ascending order.</li>
	<li>g(head) || h(head) is 1 if the linked list is in descending order.</li>
	<li>g(head) || h(head) is 1 for every unsorted linked list.</li>
	<li>g(head) || h(head) is 1 for the linked list 1→ 3→ 2→ 4→ 0→ 6</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q12</span> - <p>What is the run-time complexity of inserting a new element at the beginning of a circular, doubly-linked list with a head?</p>

<ol style="list-style-type:upper-alpha">
	<li>O(1)</li>
	<li>O(logN)</li>
	<li>O(N)</li>
	<li>O(N^2)</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q13</span> - <p>Given a doubly linked list where each node has two references (prev and next): one that points to a previous node and another that points to a next node. Assume the linked list below and provide the output for the following two lines.</p>

<p><strong><img src="https://lh3.googleusercontent.com/rA07BmSdkwyMdbIppsBYIyYw3KTVJ8Sx2m4TTDEvO_w9hLCpqjcQeu0tCVU55Of36oq_YCZirtJqVQOXR8Us3cq73XMmjQccBz5oW2F7qcGvn7sJ-lmA-KAdwFgs-cK5urepC6UP8360GkP6Fg"></strong></p>

<p>The list is restored to its initial state before each line executes:</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
Line1:   nbsp;printf(“
Line2:   nbsp;printf(“

<p>Which of the options is correct.</p>

<ol style="list-style-type:upper-alpha">
	<li>Output of line 1 is 7 and Output of line 2 is 9</li>
	<li>Output of line 1 is 9 and Output of line 2 is 7</li>
	<li>Both lines output 7</li>
	<li>Both lines output 9</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q14</span> - <p>Consider the following code fragment.</p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
struct node 
    int data;
    struct node *next;
;
    struct node *curr, *prev, *next;
    //front is pointing to the head of the linked list as shown
       in figure.
    curr = front;
    next = curr-   gt;next;
    prev = NULL;
    while (curr != NULL) 
    (*)

front = prev;
</pre>

<p>Which code must be added in the part marked (*) so the above code correctly inverts a non-empty singly linked list? See the figure to understand what ”invert” means.<br>
   nbsp;</p>

<p><strong><img src="https://lh5.googleusercontent.com/ExMplg9UNY-Df-uR_21bRFcr2ebe_V0MpzLyk6rKzmuPhGTGCZ-Bae9rDxak9bucs4lZO7wDhHfUPY1035kA_lIjo8o8feu7hLWLuTmDxe_JRZESbSddAj-kJXTyavSHvkaDfULmuMtL-XJOSw"></strong></p>

<ol style="list-style-type:upper-alpha">
	<li>
	<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
next-   gt;next = prev; prev = curr; curr = next; 
if (next != NULL) next = next-   gt;next;</pre>

	<p>   nbsp;</p>
	</li>
	<li>
	<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
curr-   gt;next= prev; prev = curr; curr = next; 
if (next != NULL) next = next-   gt;next;</pre>

	<p>   nbsp;</p>
	</li>
	<li>
	<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
next-   gt;next=curr; prev = curr; curr = next; 
if (next != NULL) next = next-   gt;next;</pre>

	<p>   nbsp;</p>
	</li>
	<li>
	<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
prev = curr; curr = next; curr-   gt;next= prev; 
if (next != NULL) next = next-   gt;next;
</pre>
	</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div><div><span>Q15</span> - <p>Consider a function findCLL that takes a doubly circular linked list head and an integer value as input.</p>

<p>One example of doubly circular linked list is given below –</p>

<p><strong><img src="https://lh4.googleusercontent.com/sxY8JwjRr2XdCpqU02eJeocIprDrCTXFdo0gcN-V25kwzWG4cdNARKj1w7plxBe7QZGk6TgCR-gvvAQn_Fi7wOhY5glwTMvKwN5TsB7ND-c4wW8FkScoYKixsj8Y84JeGdMp18hrYmO7P6xFjg"></strong></p>

<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">
int findCLL(struct node * first, int n) 

    while (first -   gt; value != n)
        first = first -   gt; next;

    if (first -   gt; value == n)
        return 1;
    else
        return -1;

</pre>

<p><br>
Consider two statements S1 and S2 given below.</p>

<ul>
	<li>S1: Function returns 1 if there exists a value in linked list</li>
	<li>S2: Function returns -1 if value does not exist in linked list</li>
</ul>

<p>Which of the following is the correct option.</p>

<ol style="list-style-type:upper-alpha">
	<li>S1 is True but S2 is False.</li>
	<li>S2 is True but S1 is False.</li>
	<li>Both are True.</li>
	<li>Both are False.</li>
</ol><hr style="height:2px;border-width:0;color:gray;background-color:gray"></div>
      <script>
      let data={'name': 'GO Classes Test Series 2024 | Data Structures | Test 1', 'duration': '45', 'total_qs': '15', 'total_qs_one': 5, 'total_qs_two': 10, 'apti_num_qs': 0, 'technical_num_qs': 15, 'apti_marks': 0, 'technical_marks': 25, 'total_marks': 25, 'num_options': '4', 'section': [{'name': 'Technical', 'num_qs': 15, 'marks': 25, 'question': [{'contents': '', 'post_id': '374988', 'text': '<p>Consider the following program. printlist() is a function that takes the head of a linked list and prints all nodes values separated by comma. Node is typedefed singly linked list type struct.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nvoid insert1(Node *head,int data)\n{\n    Node *NewNode= (Node *)malloc(sizeof(Node));\n    NewNode-&gt;value=data;\n    NewNode-&gt;next=head;\n    head=NewNode;\n}\nvoid insert2(Node **head_ref,int data)\n{\n    Node *NewNode= (Node *)malloc(sizeof(Node));\n    NewNode-&gt;value=data;\n    NewNode-&gt;next=*(head_ref);\n    *(head_ref)=NewNode;\n}\nint main()\n{\n    /* create a linked list 1-&gt;2-&gt;3-&gt;4-&gt;5 \nand head points to the first node.*/\n    insert1(head,9);\n    printlist(head); //Line X\n\n    //The list is restored to its initial state\n\n    insert2(&amp;head,9);\n    printlist(head); //Line Y\n}\n</pre>\n\n<p>Which of the following is/are true about the above program?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Line $\\text{X}$ prints $9,1,2,3,4,5$</li>\n\t<li>Line $\\text{Y}$ prints $9,1,2,3,4,5$</li>\n\t<li>Line $\\text{X}$ prints $1,2,3,4,5$</li>\n\t<li>Line $\\text{Y}$ prints $1,2,3,4,5$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b;c', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,multiple-selects,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '374986', 'text': '<p>Consider the following function fun() that takes the head of a linked list.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nstruct node {\n    int value;\n    struct node *next;\n};\ntypedef struct node Node;\n\nint fun(Node *head){\n    if(head== NULL) return 1;\n    Node *p,*q;\n    p = head;\n    q = p-&gt;next;\n    while(q!=NULL &amp;&amp; q!=p){\n        q = q-&gt;next;\n    if(q==NULL) return 1;\n    q = q-&gt;next;\n    p = p-&gt;next;\n    }\nreturn (q==NULL);\n}\n</pre>\n\n<p><br>\nWe say, a linked list has a loop if the last node of linked list points to some node of linked list and does not point to NULL.</p>\n\n<p>What does the above function do?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Returns $0$ is there is loop in linked list</li>\n\t<li>Returns $1$ is there is loop in linked list</li>\n\t<li>Returns $0$ is length of the linked list is even</li>\n\t<li>Function may go to infinite loop if there is a loop in linked list</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '375116', 'text': '<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nstruct node{\n    int data;\n    struct node *next;\n}\nvoid print(struct node *ptr)\n{\n    if(ptr)\n    {\n        printf("%d ",ptr-&gt;data);\n        do {\n            printf("%d ",ptr-&gt;data);\n        }\n        while(ptr-&gt;next);\n    }\n}\n\n</pre>\n\n<p>What is the output, if the address of the first node of singly linked list $1 \\rightarrow 2 \\rightarrow 3\\rightarrow&nbsp;4 \\rightarrow&nbsp;5$ is passed in the above C code?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1\\; 2 \\;3\\; 4\\; 5$</li>\n\t<li>$1\\; 1\\; 2\\; 3\\; 4\\; 5$</li>\n\t<li>$1\\; 1\\; 2\\; 3\\; 4\\; 5\\; 5$</li>\n\t<li>None of these</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '374994', 'text': '<p>Consider the following function that takes reference to head of a Doubly Linked List as parameter. Assume that a node of doubly linked list has previous pointer as $\\textit{prev}$ and next pointer as $\\textit{next}$.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nvoid fun(struct node **head_ref) \n{ \n    struct node *temp=NULL; \n    struct node *current=*head_ref; \n    while(current!=NULL) \n    { \n        temp=current-&gt;prev; \n        current-&gt;prev=current-&gt;next; \n        current-&gt;next=temp; \n        current=current-&gt;prev; \n    } \n    if(temp!=NULL) \n        *head_ref=temp-&gt;prev; \n} </pre>\n\n<p>Assume that reference of head of following doubly linked list is passed to above function</p>\n\n<p>$1 \\leftrightarrow&nbsp;2 \\leftrightarrow 3 \\leftrightarrow 4 \\leftrightarrow 5 \\leftrightarrow 6$. What should be the modified linked list after the function call?&nbsp;</p>\n\n<ol start="1" style="list-style-type:upper-alpha">\n\t<li>$2 \\leftrightarrow 1 \\leftrightarrow 4 \\leftrightarrow 3 \\leftrightarrow 6 \\leftrightarrow 5$</li>\n\t<li>$5 \\leftrightarrow 4 \\leftrightarrow 3 \\leftrightarrow 2 \\leftrightarrow 1 \\leftrightarrow 6$</li>\n\t<li>$6&nbsp; \\leftrightarrow 5 \\leftrightarrow 4 \\leftrightarrow 3 \\leftrightarrow 2 \\leftrightarrow 1$</li>\n\t<li>$6 \\leftrightarrow 5 \\leftrightarrow 4 \\leftrightarrow 3 \\leftrightarrow 1 \\leftrightarrow 2$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '375107', 'text': '<p>The following code is intended to remove a node p from a doubly linked list. Assume that we know that p is in the list, so the list is not empty.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nstruct node {\n    char value;\n    struct node *next;\n    struct node *prev;\n};\nstruct node *prev *succ;\nprev = p-&gt;prev;\nsucc = p-&gt;next;\nif (p == front) {\n    front = front-&gt;next;\n    if (front == NULL) rear = NULL;\n    else front-&gt;prev = NULL;\n}\nelse prev-&gt;next = succ;\nif (p == rear) {\n    rear = rear-&gt;next;\n    rear-&gt;next = NULL;\n}\nelse succ-&gt;prev = prev;\n</pre>\n\n<p>Given three linked lists (a),(b), and (c) as shown below.</p>\n\n<p><br>\n<strong><img alt="" height="125" src="https://lh5.googleusercontent.com/XPGFupKtI_QF0e9Y3NAHHFagNXJ2gn0RGUDpVVmdFYAxh5tcawigOXLK_zDdG_Pcnkygy5kY7R5sVtVhVf0ub-bVT_sO81sQ1i4BldjDjLKPEcJiMhm8mMg2-Q6xycN_x8laaDHxZOvSK4ZfSw" width="875"></strong><br>\nMark the correct option(s).</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Code will crash on linked list (a)</li>\n\t<li>Code will crash on linked list (b)</li>\n\t<li>Code will crash on linked list (c)</li>\n\t<li>Code will not crash on any of the given linked lists</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'b;c', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,multiple-selects,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '374985', 'text': '<p>Consider the following function foo() which takes the head pointer of two singly-linked lists.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nstruct node *foo(struct node *head1, struct node *head2)\n{\n    struct node *final, *temp;\n    if (head1 == NULL) return head2;\n    if (head2 == NULL) return head1;\n    temp = foo(head1-&gt;next, head2-&gt;next);\n    final = head1;\n    head1 -&gt; next = head2;\n    head2 -&gt; next = temp;\n    return final;\n}\n</pre>\n\n<p><br>\nWhat will be the final linked list returned by foo() if executed upon following linked lists?</p>\n\n<p><strong><img alt="" height="43" src="https://lh6.googleusercontent.com/77vc76YU2XsivCfNo_9oLPh3-wy9gMdxzJ3MHG0LvFIBSzCXWkWQVXDQuJnu8f3cATsyEnH1JZVN5SxsnnKsTXKJYBgEJR3v6aWWSNjyoTFw_d4RD48ypwaRk6iGl4ulneXwCf_85pJroNRE7Q" width="624"></strong></p>\n\n<p><strong><img alt="" height="43" src="https://lh3.googleusercontent.com/6bGoQUB2SETmuz8EmIDLC_ys09NX-W8eNYKtbE9kfS5U8OmNB02qqTphTPVti1ZpNaEdfv5hPMmCByWwoBFjxJGj2txD_i4SK07o7BS-C-A2TTSDEBE7_ezYlCJdLgGHO3Bx-UuxGFW4G9W7Kg" width="407"></strong></p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1,2,3,4,5,7,8,9,10$</li>\n\t<li>$1,2,3,4,5,7,8,10,9,10$</li>\n\t<li>$1,2,3,4,5,8,7,10,9,10$</li>\n\t<li>None of these</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '374991', 'text': '<p>Given a circular, doubly-linked list whose contents are sorted in ascending order, what is the run-time complexity for inserting a new element into the list so that it remains correctly sorted? (Including the time required to search for the element’s correct position.)</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$O(1)$</li>\n\t<li>$O(\\log \\text{N})$</li>\n\t<li>$O(N)$</li>\n\t<li>$O(\\text{N}^{2})$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'c', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,time-complexity,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '374993', 'text': '<p>Consider the following function Merge() that takes the head of two linked lists.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nstruct node {\n    int value;\n    struct node *next;\n};\ntypedef struct node Node;\n\nNode * Merge(Node * head1, Node * head2) {\n    if (head1 == NULL) return head2;\n    if (head2 == NULL) return head1;\n    Node * head = NULL;\n    if (head1 -&gt; value &lt; head2 -&gt; value) {\n        head = head1;\n        head -&gt; next = Merge(head1 -&gt; next, head2);\n    }\n    else if (head1 -&gt; value &gt; head2 -&gt; value) {\n        head = head2;\n        head -&gt; next = Merge(head1, head2 -&gt; next);\n    }\nreturn head;\n}\n</pre>\n\n<p>Assume that the input lists are correctly sorted. Which of the following are some of the possible behaviors when Merge() is executed with well-formed and valid inputs? Correctly merged linked list is merged&nbsp;sorted linked list.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>The function will produce a correctly merged linked list.</li>\n\t<li>The function may lead to a null pointer dereference.</li>\n\t<li>The function may result in an incorrectly merged linked list.</li>\n\t<li>Merge() will work on the following two lists.\n\t<ul>\n\t\t<li>$\\text{List}1: 1 \\rightarrow 3 \\rightarrow 5\\rightarrow 7\\rightarrow&nbsp;\\text{Null}$</li>\n\t\t<li>$\\text{List}2: 2\\rightarrow 4\\rightarrow 6\\rightarrow&nbsp;8\\rightarrow 10 \\rightarrow&nbsp;12\\rightarrow \\text{Null}$</li>\n\t</ul>\n\t</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'c;d', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,multiple-selects,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '374989', 'text': '<p>Consider the following Doubly Linked List:</p>\n\n<p><br>\n<strong><img alt="" height="37" src="https://lh6.googleusercontent.com/0Ls5DjJ0cfyFry2hINdIAxmGw8lvj_gjx7pW6dTykz9p_RB5MS4m3zlVrtnec7ahG3MDNurT3B678z4XtZDNnT9ZZlgKvBT_-B7fFHygjqOQpJCaMGkRHEQ17_dcC6lo8AOP5xVVXP4jMk3JCQ" width="624"></strong></p>\n\n<p>If head points to the first node of the linked list then what will be the output of the following node?</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nhead=head-&gt;next-&gt;next-&gt;next-&gt;prev;\nhead-&gt;next-&gt;next-&gt;prev=head;\nprintf("%d",head-&gt;next-&gt;next-&gt;prev-&gt;next-&gt;value);\n</pre>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$1$</li>\n\t<li>$3$</li>\n\t<li>$5$</li>\n\t<li>$7$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'd', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '374984', 'text': '<p>A doubly linked list is declared as:</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nstruct Node {\n    int Value;\n    struct Node *prev;\n    struct Node *next;\n};\n</pre>\n\n<p>Which of the following segment of code deletes the node pointed to by $\\text{X}$ from the doubly linked list, if it is assumed that $\\text{X}$ points to neither the first nor the last node of the list?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{X} \\rightarrow$ prev $\\rightarrow $ next $= \\text{X} \\rightarrow$ next $; \\text{X} \\rightarrow$ next $\\rightarrow$ prev $= \\text{X} \\rightarrow$ prev; free(X);</li>\n\t<li>$\\text{X} \\rightarrow$ prev.next $ = \\text{X} \\rightarrow$ next $; X.$ next $\\rightarrow$ prev $ = \\text{X} \\rightarrow$ prev; free(X);</li>\n\t<li>$\\text{X} \\rightarrow.$ prev $\\rightarrow$ next $= \\text{X}.$prev $; \\text{X} \\rightarrow$ next.prev $= \\text{X}.$prev; free(X);</li>\n\t<li>$\\text{X} \\rightarrow$ prev $\\rightarrow$ next $= \\text{X} \\rightarrow$ prev $; \\text{X} \\rightarrow$ next $\\rightarrow$ prev $= \\text{X} \\rightarrow$ next; free(X);</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '375101', 'text': '<p>Consider a mutual pair of recursive functions g() and h().</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nint g(struct node *l) {\n    if (l == NULL || l-&gt;next == NULL) return 1;\n    if (l-&gt;value &lt; l-&gt;next-&gt;value) return h(l-&gt;next);\n    else return 0;\n}\n\nint h(struct node *l) {\n    if (l == NULL || l-&gt;next == NULL) return 1;\n    if (l-&gt;value &gt; l-&gt;next-&gt;value) return g(l-&gt;next);\n    else return 0;\n}\n</pre>\n\n<p>Let head be a pointer to a singly linked list having at least $3$ nodes.</p>\n\n<p>When will the expression (g(head) || h(head)) return $1$ or $0?$</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>g(head) || h(head) is $1$ if the linked list is in ascending order.</li>\n\t<li>g(head) || h(head) is $1$ if the linked list is in descending order.</li>\n\t<li>g(head) || h(head) is $1$ for every unsorted linked list.</li>\n\t<li>g(head) || h(head) is $1$ for the linked list $1\\rightarrow 3\\rightarrow 2\\rightarrow 4\\rightarrow 0\\rightarrow 6$</li>\n</ol>', 'type': 'Multiple Select', 'answer': 'd', 'award': 2, 'penalty': '0.0000', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,multiple-selects,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '374992', 'text': '<p>What is the run-time complexity of inserting a new element at the beginning of a circular, doubly-linked list with a head?</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$O(1)$</li>\n\t<li>$O(\\log \\text{N})$</li>\n\t<li>$O(\\text{N})$</li>\n\t<li>$O(\\text{N}^2)$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,time-complexity,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '375117', 'text': '<p>Given a doubly linked list where each node has two references (prev and next): one that points to a previous node and another that points to a next node. Assume the linked list below and provide the output for the following two lines.</p>\n\n<p><strong><img alt="" height="116" src="https://lh3.googleusercontent.com/rA07BmSdkwyMdbIppsBYIyYw3KTVJ8Sx2m4TTDEvO_w9hLCpqjcQeu0tCVU55Of36oq_YCZirtJqVQOXR8Us3cq73XMmjQccBz5oW2F7qcGvn7sJ-lmA-KAdwFgs-cK5urepC6UP8360GkP6Fg" width="608"></strong></p>\n\n<p>The list is restored to its initial state before each line executes:</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nLine1:&nbsp;printf(“%d”, head-&gt;next-&gt;next-&gt;next-&gt;prev-&gt;prev-&gt;data);\nLine2:&nbsp;printf(“%d”, tail-&gt;prev-&gt;prev-&gt;prev-&gt;prev-&gt;next-&gt;next-&gt;data);</pre>\n\n<p>Which of the options is correct.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>Output of line $1$ is $7$ and Output of line $2$ is $9$</li>\n\t<li>Output of line $1$ is $9$ and Output of line $2$ is $7$</li>\n\t<li>Both lines output $7$</li>\n\t<li>Both lines output $9$</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,1-mark', 'category': 'DS'}, {'contents': '', 'post_id': '375108', 'text': '<p>Consider the following code fragment.</p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nstruct node {\n    int data;\n    struct node *next;\n};\n    struct node *curr, *prev, *next;\n    //front is pointing to the head of the linked list as shown\n       in figure.\n    curr = front;\n    next = curr-&gt;next;\n    prev = NULL;\n    while (curr != NULL) {\n    (*)\n}\nfront = prev;\n</pre>\n\n<p>Which code must be added in the part marked (*) so the above code correctly inverts a non-empty singly linked list? See the figure to understand what ”invert” means.<br>\n&nbsp;</p>\n\n<p><strong><img alt="" height="62" src="https://lh5.googleusercontent.com/ExMplg9UNY-Df-uR_21bRFcr2ebe_V0MpzLyk6rKzmuPhGTGCZ-Bae9rDxak9bucs4lZO7wDhHfUPY1035kA_lIjo8o8feu7hLWLuTmDxe_JRZESbSddAj-kJXTyavSHvkaDfULmuMtL-XJOSw" width="756"></strong></p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>\n\t<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nnext-&gt;next = prev; prev = curr; curr = next; \nif (next != NULL) next = next-&gt;next;</pre>\n\n\t<p>&nbsp;</p>\n\t</li>\n\t<li>\n\t<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\ncurr-&gt;next= prev; prev = curr; curr = next; \nif (next != NULL) next = next-&gt;next;</pre>\n\n\t<p>&nbsp;</p>\n\t</li>\n\t<li>\n\t<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nnext-&gt;next=curr; prev = curr; curr = next; \nif (next != NULL) next = next-&gt;next;</pre>\n\n\t<p>&nbsp;</p>\n\t</li>\n\t<li>\n\t<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nprev = curr; curr = next; curr-&gt;next= prev; \nif (next != NULL) next = next-&gt;next;\n</pre>\n\t</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'b', 'award': 2, 'penalty': '0.6666', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,2-marks', 'category': 'DS'}, {'contents': '', 'post_id': '374990', 'text': '<p>Consider a function findCLL that takes a doubly circular linked list head and an integer value as input.</p>\n\n<p>One example of doubly circular linked list is given below –</p>\n\n<p><strong><img alt="" height="65" src="https://lh4.googleusercontent.com/sxY8JwjRr2XdCpqU02eJeocIprDrCTXFdo0gcN-V25kwzWG4cdNARKj1w7plxBe7QZGk6TgCR-gvvAQn_Fi7wOhY5glwTMvKwN5TsB7ND-c4wW8FkScoYKixsj8Y84JeGdMp18hrYmO7P6xFjg" width="672"></strong></p>\n\n<pre class="prettyprint linenums lang-c_cpp" data-pbcklang="c_cpp" data-pbcktabsize="4">\nint findCLL(struct node * first, int n) {\n\n    while (first -&gt; value != n)\n        first = first -&gt; next;\n\n    if (first -&gt; value == n)\n        return 1;\n    else\n        return -1;\n}\n</pre>\n\n<p><br>\nConsider two statements $\\text{S1}$ and $\\text{S2}$ given below.</p>\n\n<ul>\n\t<li>$\\text{S1}:$ Function returns $1$ if there exists a value in linked list</li>\n\t<li>$\\text{S2}:$ Function returns $-1$ if value does not exist in linked list</li>\n</ul>\n\n<p>Which of the following is the correct option.</p>\n\n<ol style="list-style-type:upper-alpha">\n\t<li>$\\text{S1}$ is True but $\\text{S2}$ is False.</li>\n\t<li>$\\text{S2}$ is True but $\\text{S1}$ is False.</li>\n\t<li>Both are True.</li>\n\t<li>Both are False.</li>\n</ol>', 'type': 'Multiple Choice', 'answer': 'a', 'award': 1, 'penalty': '0.3333', 'tags': 'goclasses2024-ds-1,goclasses,data-structures,linked-list,1-mark', 'category': 'DS'}]}]}
      </script>
      